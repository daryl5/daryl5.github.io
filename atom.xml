<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Daryl's Blog]]></title>
  <link href="http://daryl5.github.io/atom.xml" rel="self"/>
  <link href="http://daryl5.github.io/"/>
  <updated>2014-04-27T23:05:31+08:00</updated>
  <id>http://daryl5.github.io/</id>
  <author>
    <name><![CDATA[Daryl5]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction to C++ for iOS Developers]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers/"/>
    <updated>2014-04-24T21:43:30+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers</id>
    <content type="html"><![CDATA[<p>摘自<a href="http://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1">Introduction to C++ for iOS Developers</a>，这篇文章第二部分在<a href="http://www.raywenderlich.com/62990/introduction-c-ios-developers-part-2">这里</a>。<br/>
写了太久OC再去看C++，最好的方式当然是比较着来学习，所以说这篇博文真的太赞了。先挖坑，明天填。</p>

<!--more-->


<h3>Getting Started: A Brief History of Languages</h3>

<p>C++曾经叫做<code>"C with Classes"</code>，OC其实也是在C上做了类这一扩展，两者的区别在于：C++的很多行为发生在编译期而OC更多在运行时期。所以像<code>Method Swizzling</code>这种东西C++是不可能有的。C++也没有<code>Introspection</code>和<code>Reflection methods</code>，不可能知道一个对象属于哪个类。</p>

<h3>C++ Classes</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// MyClass.h</span>
</span><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyClass</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// MyClass.m</span>
</span><span class='line'><span class="cp">#import “MyClass.h”</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MyClass</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// MyClass.h</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// MyClass.cpp</span>
</span><span class='line'><span class="cp">#include “MyClass.h”</span>
</span><span class='line'><span class="cm">/* Nothing else in here */</span>
</span></code></pre></td></tr></table></div></figure>


<p>在OC中所有的类都集成自NSObject，如果删掉会编译报错<code>Class 'Test' defined without specifying a base class</code>。<br/>
OC给C引入了#import来保证一个文件只能被包含一次，C++无对应机制。</p>

<h3>Class Member Variables and Functions</h3>

<p>1.C++里叫<code>成员变量&amp;成员函数</code>，OC里叫<code>实例变量&amp;实例方法</code>。C++中没有<code>method</code>这个术语。在OC中，method就是通过消息派送来调用的东西，而函数是静态的C方式的函数调用如myFunction(intValue)。
2.C++中成员变量和方法默认是<code>Private</code>的，OC中没有绝对的private。<br/>
3.C++使用类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//注意这里没有星号，m是存在栈上的，在Memory Management部分可以看到，OC里所有对象都必须加星号声明，使之存在堆</span>
</span><span class='line'><span class="c1">//存在栈上的所以不用new</span>
</span><span class='line'><span class="n">MyClass</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="n">m</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="n">m</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'><span class="n">m</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Implementing Class Member Functions</h3>

<p>1.<code>MyClass::foo() {}</code>这里的<code>::</code>就是表示foo函数是作为MyClass的一部分实现的。<br/>
2.在头文件中直接实现成员函数就是<code>让编译器去尝试内联</code>。内联就是说当调用该函数时，不会跳到一个新的函数块，而是把整个函数的代码都在编译时候内联在了调用处。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// MyClass.h</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Do something</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Namespaces</h3>

<p>1.比如<code>::</code>就是对命名空间的一种指定方式，用来告诉编译器<code>应该去哪里找这个foo函数</code>。<br/>
2.C++命名空间的使用。OC无命名空间，只有设定工程的<code>类名前缀</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">namespace</span> <span class="n">MyNamespace</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">namespace</span> <span class="n">LibraryNamespace</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">MyNamespace</span><span class="o">::</span><span class="n">Person</span> <span class="n">pOne</span><span class="p">;</span>
</span><span class='line'><span class="n">LibraryNamespace</span><span class="o">::</span><span class="n">Person</span> <span class="n">pTwo</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Memory Management</h3>

<p>1.栈和堆<br/>
a.栈固定大小；当指定函数运行时，数据将会入栈，函数运行完同样数量的数据将会出栈。因此随着程序运行，对栈容量的需求不会持续增长。<br/>
b.堆也是一块用于运行程序的内存，不过大小不固定；随着程序运行，占用堆将会增多；程序会把在函数外还会使用的东西放在堆上（比如函数调用传指针，用来当做参数的指针在栈里，而指针所指内容在外部需要用到，因此指针内容在堆上）；此外比较大的数据也会在堆上因为栈很小。
2.C++和OC对堆栈使用的区别</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span> <span class="n">stackInt</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">//用的栈空间，函数返回时存储数字&#39;5&#39;的内存会被自动释放</span>
</span><span class='line'><span class="c1">//heapInt用堆空间，需要手动释放</span>
</span><span class='line'><span class="c1">//是不是应该说存储5的内存是分配在堆上的而不是heapInt，heapInt和stackInt应该在符号表什么的吧</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">heapInt</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class='line'><span class="o">*</span><span class="n">heapInt</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="n">free</span><span class="p">(</span><span class="n">heapInt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在OC中尝试分配到栈上<code>NSString stackString;</code>将会有编译错误<code>interface type cannot be statically allocated</code>。OC需要所有object都在堆上这样RC就能控制所有对象的生存与否。<br/>
C++中对象也可以在栈上，如<code>MyPerson person</code>vs<code>MyPerson *person = new MyPerson()</code>，参考Implementing Class Member Functions部分和下面这一部分。</p>

<h3>C++ new and delete</h3>

<p>C++引入new和delete来创建&amp;摧毁堆上的对象</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Person</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span> <span class="c1">//对应OC里的alloc init</span>
</span><span class='line'><span class="k">delete</span> <span class="n">person</span><span class="p">;</span> <span class="c1">//OC里没有delete，这一操作由运行时在对象的引用计数为0时自动完成</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//标量也行</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">();</span>
</span><span class='line'><span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="k">delete</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Accessing Members of Stack and Heap Objects</h3>

<p>1.C++访问栈里对象的成员变量或调用成员函数要用点，堆里的用->。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Person</span> <span class="n">stackPerson</span><span class="p">;</span>
</span><span class='line'><span class="n">stackPerson</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="err">“</span><span class="n">Bob</span> <span class="n">Smith</span><span class="err">”</span><span class="p">;</span> <span class="c1">///&lt; Setting a member variable</span>
</span><span class='line'><span class="n">stackPerson</span><span class="p">.</span><span class="n">doSomething</span><span class="p">();</span> <span class="c1">///&lt; Calling a member function</span>
</span><span class='line'>
</span><span class='line'><span class="n">Person</span> <span class="o">*</span><span class="n">heapPerson</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>
</span><span class='line'><span class="n">heapPerson</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="err">“</span><span class="n">Bob</span> <span class="n">Smith</span><span class="err">”</span><span class="p">;</span> <span class="c1">///&lt; Setting a member variable</span>
</span><span class='line'><span class="n">heapPerson</span><span class="o">-&gt;</span><span class="n">doSomething</span><span class="p">();</span> <span class="c1">///&lt; Calling a member function</span>
</span></code></pre></td></tr></table></div></figure>


<p>OC里面对property的访问用消息发送和点操作符都行（点操作符会被转为消息发送，应该是在编译阶段），对非property的实例变量直接访问或者用->都行（无property则不会响应这一消息所以点操作符不行）。<br/>
2.this和self对应，用来在类成员函数（实例方法）内部访问当前对象。<br/>
3.OC里给nil发送任何消息都ok，C++里对NULL对象去调用函数会崩溃（nullObject->doSomething();）。</p>

<h3>References</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">changeValue</span><span class="p">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">foo</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">//注意这个声明方式</span>
</span><span class='line'><span class="n">foo</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">changeValue</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span> <span class="c1">//foo.x还是1，因为C++会做一个foo的拷贝作为参数并不是想的</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面是<code>传值</code>，<code>传址</code>和<code>传引用</code>都会真正改变foo.x，如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//传址</span>
</span><span class='line'><span class="kt">void</span> <span class="n">changeValue</span><span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">foo</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//传引用。对上述例子直接加&amp;就好了</span>
</span><span class='line'><span class="kt">void</span> <span class="n">changeValue</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Inheritance</h3>

<p>1.普通继承</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">@interface</span> <span class="nc">Person</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Employee</span> : <span class="nc">Person</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//public说明Person中所有public的成员变量在Employee仍然是public</span>
</span><span class='line'><span class="c1">//这块可以看看文章-http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Employee</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.多继承<br/>
OC也可以实现“多继承”，不过如下play和manage方法都必须实现，对C++只需要在base class中实现就行了，子类自动继承其实现。<br/>
当两个base class都实现了就要消除歧义；OC用协议的话PlayerManager必须自己去实现foo，就没有这个问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Player</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">play</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Manager</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">manage</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PlayerManager</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Player</span><span class="p">,</span> <span class="k">public</span> <span class="n">Manager</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Player和Manager都有foo函数</span>
</span><span class='line'><span class="n">PlayerManager</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'><span class="n">p</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>          <span class="c1">///&lt; Error! Which foo?</span>
</span><span class='line'><span class="n">p</span><span class="p">.</span><span class="n">Player</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span>  <span class="c1">///&lt; Call foo from Player</span>
</span><span class='line'><span class="n">p</span><span class="p">.</span><span class="n">Manager</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span> <span class="c1">///&lt; Call foo from Manager</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">@protocol</span> <span class="nc">Player</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">play</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@protocol</span> <span class="nc">Manager</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">manage</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Player</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Manager</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">Manager</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">PlayerManager</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">Player</span><span class="p">,</span> <span class="n">Manager</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Practices & Tips]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c/"/>
    <updated>2014-04-23T19:19:22+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c</id>
    <content type="html"><![CDATA[<!--more-->


<h3>4.用block实现代理</h3>

<p>关于block的大致介绍，<a href="http://onevcat.com/2011/11/objective-c%E4%B8%AD%E7%9A%84block/">Objective-C中的Block</a>这篇博文写的挺好。其中提到的一点需要注意，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="mf">1.99</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">float</span> <span class="p">(</span><span class="o">^</span><span class="n">finalPrice</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//Price is accessible here</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">quantiy</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">orderQuantity</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="c1">//Ordering 10 units, final price is: $19.90</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Ordering %d units, final price is: $%2.2f&quot;</span><span class="p">,</span> <span class="n">orderQuantity</span><span class="p">,</span> <span class="n">finalPrice</span><span class="p">(</span><span class="n">orderQuantity</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="n">price</span> <span class="o">=</span> <span class="mf">.99</span><span class="p">;</span>
</span><span class='line'><span class="c1">//Ordering 10 units, final price is: $19.90</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Ordering %d units, final price is: $%2.2f&quot;</span><span class="p">,</span> <span class="n">orderQuantity</span><span class="p">,</span> <span class="n">finalPrice</span><span class="p">(</span><span class="n">orderQuantity</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>可以理解为在block内的price是readonly的，只在定义block时能够被赋值（补充说明，实际上是因为price是value type，block内的price是在申明block时复制了一份到block内，block外面的price无论怎么变化都和block内的price无关了。如果是reference type的话，外部的变化实际上是会影响block内的）。</p></blockquote>

<p>解决办法有两种：<br/>
1.将局部变量声明为__block，表示外部变化将会在block内进行同样操作;<br/>
2.使用实例变量。关于这点有引文：</p>

<blockquote><p>这个比较没什么好说的，实例内的变量横行于整个实例内..可谓霸道无敌…=_=
block外的对象和基本数据一样，也可以作为block的参数。而让人开心的是，block将自动retain传递进来的参数，而不需担心在block执行之前局部对象变量已经被释放的问题。这里就不深究这个问题了，只要严格遵循Apple的thread safe来写，block的内存管理并不存在问题。（更新，ARC的引入再次简化了这个问题，完全不用担心内存管理的问题了）</p></blockquote>

<p>这里有个问题就是：因为block会自动retain传进来的参数，所以会出现<a href="http://stackoverflow.com/questions/14556605/capturing-self-strongly-in-this-block-is-likely-to-lead-to-a-retain-cycle">capturing self strongly in this block is likely to lead to a retain cycle</a>的问题，即就是传进去<code>self.xxx</code>之后，会retain self，即构成了循环引用。解决办法是定义一个<code>__weak</code>的self然后在block中使用。</p>

<p><strong>回到正题，block代替protocol</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//In DRDHandWriting.h</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">didFinishWriting</span><span class="p">)(</span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">didFinishWriting</span> <span class="n">didFinishWritingBlock</span><span class="p">;</span><span class="c1">//注意这里是copy</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//In DRDHandWriting.m</span>
</span><span class='line'><span class="c1">//Submit charUnitArray to Document</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">didFinishWritingBlock</span><span class="p">(</span><span class="n">segmentedCharUnitArray</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//In DRDManuscriptController::loadHandWritingView</span>
</span><span class='line'><span class="n">handWritingView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">DRDHandWriting</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="n">handWritingRect</span><span class="p">];</span>
</span><span class='line'><span class="n">__weak</span> <span class="n">DRDManuscriptController</span> <span class="o">*</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="c1">//这里的参数只是被代理对象需要返回给代理的数据，具体就是手写视图需要返回切分好的字符给controller</span>
</span><span class='line'><span class="c1">//另一种情形就是多个AlertView的代理，这里就可以传回当前alertView</span>
</span><span class='line'><span class="p">[</span><span class="n">handWritingView</span> <span class="nl">setDidFinishWritingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">segmentedArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">weakSelf</span><span class="p">.</span><span class="n">document</span> <span class="nl">addOrInsertCharUnitArray:</span><span class="n">segmentedArray</span><span class="p">];</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于上例中block的copy，有<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">官方文档</a>：</p>

<blockquote><p>Note: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. For more information, see Blocks Programming Topics.</p></blockquote>

<p>block在创建的时候是分配在栈上的，如果<code>retain</code>（栈上的东西不能retain），在调用block的时候程序就会崩溃，实际上ARC下测试了一下retain，只是代码编辑阶段即给出警告<code>Retain'ed block property does not copy the block - use copy attribute instead</code>并且程序正常运行。而如果是<code>copy</code>，将会把这个block拷贝到堆里，同时retain这个block所引用的所有东西。block在堆上的时候进行copy就没事，不会再拷贝一遍，只是相当于retain。这段摘自<a href="http://blog.refractalize.org/post/10476042560/copy-vs-retain-for-objective-c-blocks">Copy vs retain for Objective-C blocks</a>。</p>

<p><strong>结论：</strong><br/>
自己实验了一下上面那个改变price输出总价不变的例子，block在创建的时候是分配在栈上的。<br/>
1.如果block里用到了局部变量，那么就会拷贝一份：比如<code>int a = 5</code>就会拷贝一个int变量其值为5；如果是<code>int *ptr = 5</code>就会拷贝ptr这个指针，这样改变*ptr的值，block里也会跟着变。<br/>
2.如果用到了实例变量，那么不管是value type还是指针型的，都不会出现外部更新而block内部没跟着变的情况，猜想是因为block引用实例变量其实就是对self指针的弱引用，用到实例变量时候用指针去读的。<br/>
3.上面<code>capturing self strongly in this block is likely to lead to a retain cycle</code>这一问题，是因为用到了实例变量。两种情况：如果是property那么隐含<code>self.propertyXXX</code>；如果是非property的实例变量，隐含<code>self-&gt;iVar</code>，都有self。因为是用block实现代理，那么需要传block给被代理对象，被代理对象copy block，同时运行时会copy block到堆上并retain block里所有的东西，这就相当于被代理对象里声明了一个<code>@property (strong, nonatomic) id&lt;XXXProtocol&gt; delegate</code>，所以就造成了循环引用。上面那个SO的链接讲得很清楚。<br/>
4.最后，什么时候用block什么时候用delegation，<a href="http://stablekernel.com/blog/blocks-or-delegation/">Blocks or Delegation</a>讲了，实在不想看了，先马克- -！</p>

<h3>3.Category也能Conform to a protocol</h3>

<h3>2.对集合中每个对象发送消息</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// remove all subviews</span>
</span><span class='line'><span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="n">subviews</span><span class="p">]</span> <span class="nl">makeObjectsPerformSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">removeFromSuperview</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>1.<a href="http://ironwolf.dangerousgames.com/blog/archives/913">The Code Commandments: Best Practices for Objective-C Coding </a></h3>

<p><strong>a.在实例变量前加<code>@private</code></strong>[放在类扩展就好]</p>

<ul>
<li>表明该变量与API无关</li>
<li>默认是<code>@protected</code>即就是子类可以访问，如果子类不需要那就不要暴露，面向对象的<code>信息隐藏</code>，（其实最好的应该是子类和其他类用到的在.h，私有变量和方法在类扩展）</li>
</ul>


<p><strong>b.为每一个<code>data member</code>创建<code>@property</code>，在.m中都用<code>self.name</code>来访问</strong>[这个有问题]</p>

<ul>
<li>property会把访问权限加入，如readonly</li>
<li>property会把内存管理加入，strong&amp;weak</li>
</ul>


<p><strong>c.<code>实例变量</code>就是只给当前类及其子类使用，<code>@property</code>就是外部类也能用</strong><br/>
之前看到在头文件里interface部分定义实例变量，同时又用@property重新写一遍。对于想要公开给这个类及其子类以外的类的实例变量，那么就为其写一个对应的property。<br/>
<strong>d.关于<code>readonly</code></strong>
就是说这个property在外界不能修改，如<code>self.document.displayHeight</code>会产生<code>assign to readonly property</code>。在类的实现文件里可以通过实例变量来修改，如<code>_displayHeight = 600</code>，此外，在实现文件还可以通过<code>self-&gt;_displayHeight = 600</code>来修改，这里之所以用->大概是因为类本身拥有这个实例变量就意味着类的实例有一个指向这个实例变量的指针，而property只是用于公开给外部，在这里没property什么事。
另外还可以在类扩展里告诉编译器我还需要一个setter，但只是在实现文件里：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//公有可读，私有可写</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">YourClass</span> <span class="p">()</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">eventDomain</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个问题在<a href="http://stackoverflow.com/questions/4586516/readonly-properties-in-objective-c">Readonly Properties in Objective-C?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Effective Objective-C 2.0』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0/"/>
    <updated>2014-04-07T13:22:29+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0</id>
    <content type="html"><![CDATA[<p>《Effective Objective-C 2.0：52 Specific Ways to Improve Your iOS and OS X Programs》 作者：<a href="http://www.galloway.me.uk/">Matt Galloway</a></p>

<!--more-->


<h2><strong>1: Accustoming Yourself to Objective-C</strong></h2>

<h3>Item 2: 缩减头文件&mdash;Minimize Importing Headers in Headers</h3>

<p>a.如下引文，试了一下互相import，没有报错- -！</p>

<blockquote><p>The use of #import rather than #include doesn&rsquo;t end in an infinite loop but does mean that one of ther classes won&rsquo;t compile correctly.</p></blockquote>

<p>b.协议相关<br/>
一些代理相关的协议，可以把协议头文件在.m文件里再引入，把代理<code>id&lt;XXXProtocol&gt; delegate</code>定义放在类扩展里。
也可以考虑单独创建一个头文件，里面只放协议定义。</p>

<!--more-->


<h3>Item 3: 使用字面量语法而不是其等价方法&mdash;Prefer Literal Syntax over the Equivalent Methods</h3>

<p>a.字面量使用</p>

<pre><code>NSString *str           = @"Test String";
NSNumber *boolValue     = @YES;
NSNumber *charValue     = @'a';
NSNumber *expressionVal = @(x * y);//int x &amp; float y

NSArray *animals        = @[@"cat", @"dog"];
NSString *dog           = animails[1];//下标直接访问

NSDictionary *person    = @{@"firstName" : @"Matt", @"age" : @28};
NSString *firstName     = person[@"firstName"];//key值直接访问value

//Assign value or replace
mutableArray[1] = @"dog";
mutableDictionary[@"lastName"] = @"Galloway";
</code></pre>

<p>b.好处<br/>
如果NSArray用3个object来初始化，第二个是nil，那么arrayWithObjects将会返回一个只包含object1的array，而字面量初始化会报错。<strong>“报错”比“少了个数”更安全。</strong>
对于NSDictonary，初始化会在遇到nil时候停止，dictionaryWithObjectsAndKeys可能会少了某一个value；字面量更安全。<br/>
c.缺点<br/>
字面量语法只能用于Foundation框架的一些类，对于自定义的类没法这样定义（显然）。<br/>
对于mutable对象的定义，需要进行mutableCopy。增加了额外的方法调用和对象创建</p>

<pre><code>NSMutableArray *mutable = [@[@1, @2, @3] mutableCopy];
</code></pre>

<h3>Item 4: 使用类型化常量而不是预处理指令#define&mdash;Prefer Typed Constants to Preprocessor #define</h3>

<p>a.#define的缺点<br/>
预处理指令<code>#define ANIMATION_DURATION 0.3</code>只是在预处理阶段进行<code>替换</code>，它没有包含类型信息。（如果定义在头文件，所有包含该头文件的文件也都会进行替换。）<br/>
b.类型化常量的使用（static const）<br/>
用上编译器让常量有类型信息：<code>static const NSTimerInterval kAnimationDuration = 0.3;</code>
常量命名规范：</p>

<blockquote><p>The usual convertion for constants is to prefix with lettr k for constants that are local to a translation unit(implementation file). For constants that are exposed outside of a class, it is usual to prefix with the class name.<br/>
在.m中定义，对于这个translation unit是局部变量的话用k作前缀；如果要暴露给外界，用类名开头，如EOCViewClassAnimationDuration。</p></blockquote>

<p><code>static</code>关键词说明这个变量对于当前translation unit是局部的，如果没定义为static，编译器将会为其创建一个external symbol，如果另一translation unit声明了一个同名变量，链接器将会报错；<code>const</code>关键词说明不能被修改。</p>

<blockquote><p>A translation unit is the input the compiler receives to generate one object file. In OC, this usually means that there is one translation unit per class: every .m file.</p></blockquote>

<p>SO的一个问题：<a href="http://stackoverflow.com/questions/11382502/how-different-static-variable-declarations-in-objective-c">How different static variable declarations in Objective-C?</a><br/>
c.类型化常量的使用（extern）<br/>
跟<code>NSNotification</code>相关，通知名应该这样处理：</p>

<pre><code>// In .h
// extern--"Trust me, there's a variable called EOCStringConstant declared in another file"
// EOC是类名
extern NSString *const EOCStringConstant;

// In .m
//反着读：EOCStringConstantis a const pointer point to NSString
NSString *const EOCStringConstant = @"NotificationName";
//如果不是对象那这里是const NSTimeInterval EOCAnimated...
</code></pre>

<p>d.总结<br/>
类型化常量有类型- -！
类型化常量借助编译器来确保常量的一致性（const），预处理指令#define可以在别的地方重定义。<br/>
.m的局部变量如动画时间等用k开头放在.m文件里用static；通知名等用类名+通知名，.m里声明+定义，.h里extern，如UIApplication类里声明+定义的UIApplicationDidEnterBackGroundNotifation。</p>

<h2><strong>2: Objects, Messaging, and the Runtime</strong></h2>

<h3>Item 6: 理解Properties-Understand Properties【需要再看】</h3>

<p>a.自己写了Accessor中的一个，编译器将会synthesize另一个，LazyLoading就是这样的。如果不想让编译器自动synthesize，可以用<code>@dynamitc</code>指令，这样编译器不会生成Accessor和对应的实例变量名，而且编译时候编译器会忽略Accessor还没有被定义但是已经在self.property，编译器会认为Accessor在runtime时会有的。<br/>
b.<code>weak</code>不会release旧值，也不会retain新值，类似assign，不过这个property所指对象被销毁时，这个property会被nilled out。<br/>
<code>unsafe_unretained</code>也和assign类似，只是关于object的assign，unretained对应nonowning，unsafe对应不会被nilled out，这一点和weak不一样。<br/>
<code>copy</code>对应mutable copy，如果不想让对象把传进来的值改变了，应该做一下copy，也就是immutable copy。虽然增加了拷贝操作，但是会更安全。<br/>
c.关于自定义getter名在BOOL上的应用，为了加is为什么不直接把property命名成isXxx。</p>

<h3>Item 10: 在既有类中适用关联对象存放自定义数据-Use Associated Objects to Attach Custom Data to Existing Classed</h3>

<p>a.一般都是通过<code>继承</code>来给既有类添加数据，但行不通的时候就要用到<code>关联对象</code>了。以UIAlertView为例：</p>

<ul>
<li>一般的实现中buttonIndex和其action的对应，即button的定义和其响应方法的声明不在一个地方，这样可读性不好；</li>
<li>如果同一个类里有多个alertView，那么在代理方法中还要判断是哪一个，然后再判断buttonIndex；</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">EOCMyAlertViewKey</span> <span class="o">=</span> <span class="s">&quot;EOCMyAlertViewKey&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">askUserAQuestion</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIAlertView</span> <span class="o">*</span><span class="n">alert</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAlertView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTitle:</span><span class="s">@&quot;Question&quot;</span>
</span><span class='line'>                                                    <span class="nl">message:</span><span class="s">@&quot;What do you want to do?&quot;</span>
</span><span class='line'>                                                   <span class="nl">delegate:</span><span class="n">self</span>
</span><span class='line'>                                          <span class="nl">cancelButtonTitle:</span><span class="s">@&quot;Cancel&quot;</span>
</span><span class='line'>                                          <span class="nl">otherButtonTitles:</span><span class="s">@&quot;Continue&quot;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="n">NSInteger</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSInteger</span> <span class="n">buttonIndex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">buttonIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span> <span class="n">doCancel</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span> <span class="n">doContinue</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">alert</span><span class="p">,</span> <span class="n">EOCMyAlertViewKey</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_COPY</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">alert</span> <span class="n">show</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// UIAlertViewDelegate protocol method</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">alertView:</span><span class="p">(</span><span class="n">UIAlertView</span> <span class="o">*</span><span class="p">)</span><span class="nv">alertView</span> <span class="nf">clickedButtonAtIndex:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">buttonIndex</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="n">NSInteger</span><span class="p">)</span> <span class="o">=</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">alertView</span><span class="p">,</span> <span class="n">EOCMyAlertViewKey</span><span class="p">);</span>
</span><span class='line'>    <span class="n">block</span><span class="p">(</span><span class="n">buttonIndex</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>b.总结<br/>
关联对象就是把两个object链接在一起了；关联对象只有在其他方法都不可行的时候才使用，因为很容易造成<code>Retain Cycle</code>；上例中还可以通过继承AlertView并附加这个block对象来实现，如果类中alertView要多次用到，更建议继承而不是关联对象。</p>

<h3>Item 14: 理解类的对象- Understand What a Class Object Is</h3>

<p>a.OC是<code>动态类型</code>的，对象的类型并不是在编译时候进行绑定的，而是在运行时进行查找。</p>

<h2><strong>4: Protocols and Categories</strong></h2>

<h3>Item 23: 通过委托和数据源协议进行对象间通信</h3>

<p>a.有一句话没太懂，这个单词居然查不出来，完了看看Item6，里面有这个单词：</p>

<blockquote><p>A delegate property will always be defined using either the weak attribute to benefit from <code>autonilling</code> or unsafe_unretained if autonilling is not required.</p></blockquote>

<p>b.在interface中声明遵守协议的话，别的类会知道这一行为，一般把“遵守协议”放在类扩展部分，虽然没太多影响。要知道一个对象是否遵守某个协议可以这样：<code>[self conformsToProtocol:@protocol(DRDHandWritingProtocol)]</code><br/>
c.可以把正在代理的对象也传回给代理，这样方便判断具体是哪个代理对象在调用代理方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">networkFetcher:</span><span class="p">(</span><span class="n">EOCNetworkFetcher</span> <span class="o">*</span><span class="p">)</span><span class="nv">fetcher</span> <span class="nf">didReceiveData:</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">fetcher</span> <span class="o">==</span> <span class="n">_myFetcherA</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//Handle data</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fetcher</span> <span class="o">==</span> <span class="n">_myFetcherB</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//Handle data</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>d.如果开发API，用代理可以实现一些属性设置，如<code>- (BOOL)networkFetcher:(EOCNetworkFetcher *)fetcher shouldFollowRedirectToURL:(NSURL *)url;</code>，甚至这里可以给fetcher传递一个NSDictionary来进行Fetcher一系列属性的设置。<br/>
e.对<code>@optional</code>的代理方法，方法调用者负责通过<code>[delegate respondsToSelector]</code>确保程序不会崩溃，unrecognized selector。<code>@required</code>的话编译器会确认。如果没设置，默认都是required。<br/>
f.对dataSource类的delegate，在获取每一个小的data piece的时候都查询一次respondsToSelector是低效的，应该将当前对象对协议的遵守情况缓存下来。如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//有个DataModel或者ViewController是该对象的代理</span>
</span><span class='line'><span class="c1">//In class extension</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">EOCNetworkFetcher</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">didReceiveData</span>      <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">didFailWithError</span>    <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">didUpdateProgressTO</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="n">_delegateFlags</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//In delegate Setter</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setDelegate:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">EOCNetworkFetcher</span><span class="o">&gt;</span><span class="p">)</span><span class="n">delegate</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_delegate</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didReceiveData</span> <span class="o">=</span> <span class="p">[</span><span class="n">delegate</span> <span class="nl">respondsToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkFetcher:didReceiveData:</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Query if responds to selector (FRENQUENTLY)</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didReceiveData</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">_delegate</span> <span class="nl">networkFetcher:</span><span class="n">self</span> <span class="nl">didReceiveData:</span><span class="n">dataReceived</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>g.协议的“继承”</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">@protocol</span> <span class="nc">A</span>
</span><span class='line'>    <span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">methodA</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@protocol</span> <span class="nc">B</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">methodB</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress & Alfred Workflow]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/02/use-alfred-with-octopress/"/>
    <updated>2014-04-02T15:54:07+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/02/use-alfred-with-octopress</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.alfredapp.com/">Alfred</a>真是神器！</strong>自己做了两个workflow来简化Octopress发表博文和修改博文的流程，实现的很简单。</p>

<!--more-->


<p><code>发博文</code>用的是：Templates-Essentials-Keyword to Terminal Command。新建并用xcode打开空的博文后终端会运行<code>rake preview</code>，这样就直接进入编辑并预览状态。命令是<code>pb（post blog）</code>
<img src="http://daryl5.github.io/blogimage/2014/pb.png" alt="pb" /></p>

<p><code>修改博文</code>用的是：Templates-Files and Apps-File filter from keyword and open。根据关键词显示相关文件，回车用xcode打开，打开终端运行<code>rake preview</code>。命令是<code>mb（modify blog）</code></p>

<p><img src="http://daryl5.github.io/blogimage/2014/mb.png" alt="mb" /><br></p>

<h2>下载</h2>

<p>可以戳<a href="http://daryl5.github.io/blogfile/2014/%E5%BD%92%E6%A1%A3.zip">这里</a>下载然后根据自己的需求修改。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIDocument的使用]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument/"/>
    <updated>2014-04-01T21:42:32+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument</id>
    <content type="html"><![CDATA[<p>读<a href="https://github.com/sprang/Inkpad">Inkpad</a>源码时看到使用了<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIDocument_Class/UIDocument/UIDocument.html#//apple_ref/c/tdef/UIDocumentState">UIDocument</a>，然后搜到了Ray Wenderlich的博文：<a href="http://www.raywenderlich.com/12779/icloud-and-uidocument-beyond-the-basics-part-1">iCloud and UIDocument: Beyond the Basics</a>，整理了一下大致用法。</p>

<!--more-->


<h3>1. 继承UIDocument并重写方法</h3>

<p>需要重写<code>loadFromContents:ofType:error</code>方法来读，重写<code>contentsForType:error</code>方法来写。</p>

<h3>2. 输入输出格式</h3>

<p>UIDocument支持两种类，<code>NSData</code>适用于文档只是一个单一文档，<code>NSFileWrapper</code>相当于文件夹，适用于文档包含多个想要单独加载的文件，比如矢量图绘制App要显示一个缩略图，这个需要单独提前加载。FileWrapper内部是Key-Value形式的存储，文件名是key，文件存在本地的archive内容（或是archive文件名）是value，所以会有：</p>

<!--more-->


<pre><code>//从文件名（如xxxx.title，不是xxxx.note）得到FileWrapper
NSFileWrapper *fileWrapper = [self.fileWrapper.fileWrappers objectForKey:preferredFilename];

//从FileWrapper得到文件内容
NSData *data = [fileWrapper regularFileContents];
NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
</code></pre>

<h3>3. iCloud</h3>

<p>Apple规定，应用的所有documents要么在沙盒，要么在iCloud本地文件夹，用户不能选择某一文件来让其单独的存储在iCloud。</p>

<blockquote><p>All documents of an application are stored either in the local sandbox or in an iCloud container directory. A user should not be able to select individual documents for storage in iCloud.</p></blockquote>

<!--more-->


<h3>4. 关于undo/redo</h3>

<p>UIDocument有undo/redo支持，访问器是注册undo动作最合适的地方，所以document类里，对需要添加undo/redo功能的数据要重写访问器。对不需要undo/redo功能的数据，直接给document用property添加一个model就好。</p>

<h3>5. 整体的实现结构</h3>

<p>以记事本为例，title和content两个model，其中都只包含一个NSString。主视图直接在title，detailViewController再加载content。</p>

<blockquote><p><code>TitleModel</code>和<code>ContentModel</code>都实现<code>NSCoding</code>协议方法，这里可以考虑把<code>VersionNumber</code>encode进去以便后期支持文件格式扩展。
<strong>NoteDocument.h</strong></p>

<blockquote><p><code>@property (nonatomic, strong) TitleModel *titleModel;
//这里对ContentModel中的内容实现访问器，原因第4条有，方便undo/redo</code>
<code>- (NSString *)contentString;</code><br/>
<code>- (void)setContentString:(NSString *)str;</code></p></blockquote>

<p><strong>NoteDocument.m</strong></p>

<blockquote><ul>
<li>类扩展里定义<code>contentModel</code>和<code>fileWrapper</code>(读文件时候用)，<code>titleModel</code>直接放在头文件是因为It’s OK if the user accesses the metadata directly though, as it’s not something the app will modify. Instead, the metadata will be automatically updated when the user sets the photo.</li>
<li>重写<code>loadFromContents</code>和<code>contentsForType</code>，loadFromContents里面self.wrapper = (NSFileWrapper *)contents;给wrapper赋值，contentsForType里面把两个model encode进wrapper</li>
<li>重写<code>titleModel</code>和<code>contentModel</code>两个getter实现Lazy Loading，需要的时候再decode；如果文件不存在则把model初始化为nil</li>
<li>实现ContentModel的content的Accessor来实现undo/redo，在Setter里面执行如下代码块：</li>
</ul>
</blockquote></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">contentModel</span><span class="p">.</span><span class="n">content</span> <span class="nl">isEqual:</span><span class="n">str</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">oldContent</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">contentModel</span><span class="p">.</span><span class="n">content</span><span class="p">;</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">contentModel</span><span class="p">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">undoManager</span> <span class="nl">setActionName:</span><span class="s">@&quot;Content Change&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">undoManager</span> <span class="nl">registerUndoWithTarget:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">setContentString:</span><span class="p">)</span> <span class="nl">object:</span><span class="n">oldContent</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>其他</h2>

<h3>1. 设备旋转支持</h3>

<p>好多大厂的App居然也能支持反过来操作，真是不可理解。代码摘自引用博文实现的工程。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">shouldAutorotateToInterfaceOrientation:</span><span class="p">(</span><span class="n">UIInterfaceOrientation</span><span class="p">)</span><span class="nv">interfaceOrientation</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">interfaceOrientation</span> <span class="o">!=</span> <span class="n">UIInterfaceOrientationPortraitUpsideDown</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2. Undo/Redo</h3>

<p><a href="http://blog.163.com/chenchen..1986/blog/static/760631462013222314817/">这里</a>的例子简单有效。</p>

<h3>3. 自己画的大致思路，实际实现没这么做。</h3>

<p><img src="http://daryl5.github.io/blogimage/2014/useuidocument.jpg" alt="useuidocument" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读Inkpad源代码]]></title>
    <link href="http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code/"/>
    <updated>2014-03-30T19:55:11+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/sprang/Inkpad">Inkpad</a>是一个开源的基于OpenGLES的画矢量图的App，这篇博文记录阅读其源代码时的收获。</p>

<!--more-->


<h3>0. 内联函数的使用</h3>

<p>内联函数只是给编译器的提示，最终能不能内联还要看编译器。</p>

<h4>(1)相同点</h4>

<p><code>static inline double radians (double degrees) { return degrees * M_PI/180; }</code>；都是在与处理阶段对代码块进行替换。</p>

<h4>(2)不同点</h4>

<p>内联函数是值传递，宏定义是简单替换。内联函数有类型检查，此外<code>省去了很多函数调用汇编代码如：call和ret等</code>。<br/>
<code>#define MAX(a, b) a&gt;b?a:b</code>如果<code>MAX( num1, num2 )</code>就没问题，但是如果是<code>MAX( 17+32, 25+21)</code>，展开后是<code>17+32&gt;25+21?17+32:25+21</code>。甚至<code>#define A 2+3</code>，然后<code>c = 4 * A</code>都会成为<code>4 * 2 + 3</code>。比较安全的写法是<code>#define MAX( (a), (b) ) (a)&gt;(b)?(a)b)</code>，但是这样还是有问题，<code>MAX(i++,j++)</code>完了每个都会加2了。
宏定义执行快是因为没有<code>函数调用</code>的开销，但是如果宏用的多文件就会变很大，执行文件太大可能导致执行时换页频繁（略夸张）。</p>

<h3>1. 一些简洁的写法</h3>

<ul>
<li><p><code>CGRectGetWidth</code>，以前总是写成<code>self.frame.size.width</code>。此外还有<code>CGRectGetMidX</code>，直接得到矩形中心点的X坐标。</p>

<pre><code>  CGPointMake(CGRectGetWidth(frame) / 2, CGRectGetHeight(frame) / 2);
</code></pre></li>
<li><p><code>[NSDictionary objectForKey]</code>，可以直接<code>dictionary[key]</code>。</p></li>
<li><p><code>BOOL isolate</code>转NSString，<code>@(isolate)</code>。NSArray的类似写法：</p>

<pre><code>  NSArray *items = @[actionItem_, gearItem_, albumItem_, zoomToFitItem_];
</code></pre></li>
</ul>


<h3>2. Best Practice</h3>

<h4>(1) “帮助”、“关于”视图</h4>

<p>应用的<strong><code>帮助</code></strong>, <strong><code>关于</code></strong>等信息可以做成html页面。建立本地文件夹，在其中放置html、图片、css等，然后直接<code>self.view = webview;</code>即可。</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span> <span class="nf">helpURL</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">resource</span> <span class="o">=</span> <span class="n">NSLocalizedString</span><span class="p">(</span><span class="s">@&quot;index&quot;</span><span class="p">,</span> <span class="s">@&quot;Name of Help html file&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="nl">pathForResource:</span><span class="n">resource</span> <span class="nl">ofType:</span><span class="s">@&quot;html&quot;</span> <span class="nl">inDirectory:</span><span class="s">@&quot;Help&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">fileURLWithPath:</span><span class="n">path</span> <span class="nl">isDirectory:</span><span class="n">NO</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">loadView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">UIWebView</span> <span class="o">*</span><span class="n">webView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIWebView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="p">[[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">bounds</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">webView</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="o">=</span> <span class="n">UIViewAutoresizingFlexibleWidth</span> <span class="o">|</span> <span class="n">UIViewAutoresizingFlexibleHeight</span><span class="p">;</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="o">=</span> <span class="n">webView</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">webView</span> <span class="nl">loadRequest:</span><span class="p">[</span><span class="n">NSURLRequest</span> <span class="nl">requestWithURL:</span><span class="p">[</span><span class="n">self</span> <span class="n">helpURL</span><span class="p">]]];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>(2) 应用“设置”功能</h4>

<p>以“显示网格”这一设置项为例，通过<code>UILable  UISwitch</code>来实现。其实可以全部通过NSUserDefaults实现，但inkpad中有个NSMutableDictionary的settings_作为”中间变量“:</p>

<ul>
<li>可能是考虑到在初始化时一次读取NSUserDefaults而不是需要属性就去查NSUserDefaults更好;</li>
<li>还有个原因就是每个drawing都会把settings_当做Document的一部分进行存储，NSMutableDictionary才能去存储。</li>
</ul>


<p>在<code>WDDrawingController</code>中有<code>WDPropertyManager</code>。除了下面的示例代码，很多属性的管理都在这里，<strong>区别是</strong>settings_只管理<code>设置</code>视图里能改变的属性，并且其值会被存储到document里，跟单独drawing相关；<del>而propertyManager管理<code>应用状态</code>，比如不选路径的时候“路径”的popover tableView里就全部不可用，如添加锚点、合并路径。</del></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// constantly updating the user defaults kills responsiveness after the keyboard has been made visible</span>
</span><span class='line'><span class="c1">// so use this temporary dictionary to avoid hitting the defaults all the time  </span>
</span><span class='line'><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">defaults_</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span><span class="c1">//in init</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//- (void) didEnterBackground:(NSNotification *)aNotification</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">updateUserDefaults</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="k">in</span> <span class="p">[</span><span class="n">defaults_</span> <span class="n">allKeys</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">setObject:</span><span class="n">defaults_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="nl">forKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>相关代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//属性设置-在“设置”界面控件响应方法中</span>
</span><span class='line'><span class="c1">//WDSettingsController</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">takeShowGridFrom:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">UISwitch</span>    <span class="o">*</span><span class="n">mySwitch</span> <span class="o">=</span> <span class="p">(</span><span class="n">UISwitch</span> <span class="o">*</span><span class="p">)</span><span class="n">sender</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">setBool:</span><span class="n">mySwitch</span><span class="p">.</span><span class="n">isOn</span> <span class="nl">forKey:</span><span class="n">WDShowGrid</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="n">synchronize</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawing_</span><span class="p">.</span><span class="n">showGrid</span> <span class="o">=</span> <span class="n">mySwitch</span><span class="p">.</span><span class="n">isOn</span><span class="p">;</span><span class="c1">//Setter方法</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性管理的中间类-在Accessor中设置和应用，发送通知最终应用设置</span>
</span><span class='line'><span class="c1">//WDDrawing:NSObject</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">setShowGrid:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">showGrid</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">settings_</span><span class="p">[</span><span class="n">WDShowGrid</span><span class="p">]</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">showGrid</span><span class="p">);</span><span class="c1">//settings_是NSMutableDictionary，WDShowGrid是NSString “WDShowGrid”</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">postNotificationName:</span><span class="n">WDDrawingChangedNotification</span> <span class="nl">object:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// this isn&#39;t an undoable action so it does not dirty the document</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">document</span> <span class="n">markChanged</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span> <span class="nf">showGrid</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">settings_</span><span class="p">[</span><span class="n">WDShowGrid</span><span class="p">]</span> <span class="n">boolValue</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性改变的即时应用-接收通知并通过setNeedsDisplay处发drawRect重绘</span>
</span><span class='line'><span class="c1">//WDCanvas</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">invalidateFromNotification:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">aNotification</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSValue</span>     <span class="o">*</span><span class="n">rectValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">aNotification</span> <span class="n">userInfo</span><span class="p">][</span><span class="s">@&quot;rect&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSArray</span>     <span class="o">*</span><span class="n">rects</span> <span class="o">=</span> <span class="p">[</span><span class="n">aNotification</span> <span class="n">userInfo</span><span class="p">][</span><span class="s">@&quot;rects&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGRect</span>      <span class="n">dirtyRect</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">float</span>       <span class="n">fudge</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">)</span> <span class="o">/</span> <span class="n">viewScale_</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">rectValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//...</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rects</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//...</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//没有任何userInfo，对应showGrid这一属性的改变</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">drawing_</span><span class="p">.</span><span class="n">showGrid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">drawingIsolatedLayer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="nl">drawGrid:</span><span class="n">ctx</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性的保存-主要在WDSettingsController，设置并同步</span>
</span><span class='line'><span class="err">借助</span><span class="n">NSUserDefaults</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性的加载-各种init方法中从NSUserDefaults初始化settings_</span>
</span><span class='line'><span class="c1">//WDDrawing</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nl">initWithSize:</span><span class="p">(</span><span class="n">CGSize</span><span class="p">)</span><span class="n">size</span> <span class="nl">andUnits:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">units</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// each drawing saves its own settings, but when a user alters them they become the default settings for new documents</span>
</span><span class='line'>    <span class="c1">// since this is a new document, look up the values in the defaults...</span>
</span><span class='line'>    <span class="n">NSUserDefaults</span> <span class="o">*</span><span class="n">defaults</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSArray</span> <span class="o">*</span><span class="n">keyArray</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">WDShowGrid</span><span class="p">,</span> <span class="n">WDSnapToGrid</span><span class="p">,</span> <span class="n">WDSnapToPoints</span><span class="p">,</span> <span class="n">WDSnapToEdges</span><span class="p">,</span> <span class="n">WDDynamicGuides</span><span class="p">,</span> <span class="n">WDRulersVisible</span><span class="p">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="k">in</span> <span class="n">keyArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">settings_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="err">@</span><span class="p">([</span><span class="n">defaults</span> <span class="nl">boolForKey:</span><span class="n">key</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. <code>NSNotification</code>的名字应该在哪定义</h3>

<p>在<code>WDToolManager.m</code>中，<code>NSString *WDActiveToolDidChange = @"WDActiveToolDidChange";</code>，然后在头文件中<code>extern NSString *WDActiveToolDidChange;</code>。一般来说关心这个通知（当前工具改变）的类都引用了这个类的头文件，这样比放在一个<code>ConstantsDefine.h</code>里要好。</p>

<h3>4.枚举定义中为什么要用左移</h3>

<p>这里解释的很详细<a href="http://stackoverflow.com/questions/3999922/why-use-the-bitwise-shift-operator-for-values-in-a-c-enum-definition">Why use the Bitwise-Shift operator for values in a C enum definition?</a>。如果用</p>

<pre><code>typedef enum { WDToolDefault, WDToolShiftKey, WDToolOptionKey }  
</code></pre>

<p>那么<code>WDToolDefault | WDToolShiftKey</code>就是<code>1 | 2</code>会得到3！！用左移就不会有这个问题，就是<strong><em>可以在一个变量中支持多个枚举值</em></strong>（将其相加或者取或），判断的时候取与。</p>

<pre><code>typedef enum {
    WDToolDefault           = 0,
    WDToolShiftKey          = 1 &lt;&lt; 0,
    WDToolOptionKey         = 1 &lt;&lt; 1,
    WDToolControlKey        = 1 &lt;&lt; 2,
    WDToolSecondaryTouch    = 1 &lt;&lt; 3
} WDToolFlags;  
</code></pre>

<h3>5. 子类不能重写touchesBegan但要在其发生同时完成处理</h3>

<p><code>FingerTackerView</code>重写<code>touchesBegan</code>等等方法，然后在其内部进行一些操作后调用<code>[self methodForSubclassOverwritten]</code>，这个方法可以置空。<code>HandWritingView</code>，<code>GestureEditorView</code>等继承自<code>FingerTrackerView</code>的类里重写<code>[self methodForSubclassOverwritten]</code>，这样就能在采集点的同时，对点的处理根据当前选择功能（即所处的视图）来由对应的子类来处理。子类不会出现<code>touchesBegan</code>等，但是可以通过重写方法来实现手势运动时处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[所有遇到过的坑们]]></title>
    <link href="http://daryl5.github.io/blog/2014/03/21/mutablearray-of-keng/"/>
    <updated>2014-03-21T12:22:22+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/03/21/mutablearray-of-keng</id>
    <content type="html"><![CDATA[<!--more-->


<h3>12.DRDPoint和DRDInkPoint的encode decode</h3>

<h3>11.连按删除按钮时候下标越界</h3>

<p>在<code>- (void)deleteDataUnit</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">tempArray</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">dataUnitArray</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//删除</span>
</span><span class='line'><span class="p">[</span><span class="n">tempArray</span> <span class="nl">removeObjectAtIndex:</span><span class="n">cursorIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//触发KVO去绘制</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">dataUnitArray</span> <span class="o">=</span> <span class="n">tempArray</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在<code>- (UIImage *)generatePageImageWithPageIndex:(int)pageIndex</code>中就越界了。</p>

<p><strong>原因</strong>是tempArray和dataUnitArray指的同一块内存，比如原本长度12，删除一个变为11，在后台线程中绘制这个11长度的数组的时候，又按了一下删除，这时候已经触发了KVO，又多了一个绘制线程，之前那个绘制线程在绘制11长度，但是现在的长度是10，所以按的快的时候就会越界，按的慢等每一次绘制结束就没事。</p>

<p><strong>解决办法</strong>是给tempArray赋值的时候进行一下mutable copy，这样每一个绘制线程就用的不同的拷贝，不会导致越界。</p>

<p><strong>更好的解决办法</strong>：类似的情形下，数据改变了就应该停止之前的绘制线程，直接进入新的绘制。打印了一下当前线程，按的快了最多同时开了6个线程在绘制。</p>

<p><a href="http://stackoverflow.com/questions/12660706/nsoperation-cancelalloperations-does-not-stop-the-operation">[NSOperation cancelAllOperations]; does not stop the operation</a>，这个链接里面提到了利用<code>NSOperationQueue</code>的<code>cancelAllOperations</code>来实现“有新数据则停止处理旧数据，从而直接转入对新数据的处理”，实际使用中的确起到了这样的效果，但是跟帖子中例子不同，我的函数里有很多<code>对象</code>，而一个RunLoop就会开一个autoreleasepool，在runloop里我没有去手动释放内存而直接返回，然后内存占用飙升了。懒得再去改进了，只求用户不要太变态。</p>

<h3>10.iOS7中自定义导航栏、状态栏的样式</h3>

<p>设置状态栏：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//In AppDelegate</span>
</span><span class='line'><span class="c1">//Config StatusBar appearance</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">setStatusBarStyle:</span><span class="n">UIStatusBarStyleLightContent</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Config UINavigationController appearance</span>
</span><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setBarTintColor:</span><span class="n">UIColorFromRGB</span><span class="p">(</span><span class="mh">0x3395E3</span><span class="p">)];</span> <span class="c1">// 51, 149, 227</span>
</span><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setTitleTextAttributes:</span><span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">dictionaryWithObjectsAndKeys:</span>
</span><span class='line'>                                                      <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithWhite:</span><span class="mf">0.9</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">],</span>
</span><span class='line'>                                                      <span class="n">NSForegroundColorAttributeName</span><span class="p">,</span>
</span><span class='line'>                                                      <span class="p">[</span><span class="n">UIFont</span> <span class="nl">systemFontOfSize:</span><span class="mf">20.0</span><span class="p">],</span>
</span><span class='line'>                                                      <span class="n">NSFontAttributeName</span><span class="p">,</span> <span class="nb">nil</span><span class="p">]];</span>
</span><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setTintColor:</span><span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithWhite:</span><span class="mf">0.93</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//In ViewController--进入全屏模式，因为主体背景是白色，在AppDelegate设置状态栏是LightContent，全屏了就很瞎眼</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">setStatusBarStyle:</span><span class="n">UIStatusBarStyleDefault</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Leave full screen</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">setStatusBarStyle:</span><span class="n">UIStatusBarStyleLightContent</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/">Customizing Navigation Bar and Status Bar in iOS 7</a>，这个不错。不过里面对单独viewController的statusbar设置<code>UIStatusBarStyle</code>没有成功，没搞懂。<a href="http://stackoverflow.com/questions/17678881/how-to-change-status-bar-text-color-in-ios-7/17768797#17768797">How to change Status Bar text color in iOS 7.</a>和这个<a href="http://stackoverflow.com/questions/19022210/preferredstatusbarstyle-isnt-called/19032879#19032879">preferredStatusBarStyle isn&rsquo;t called</a>可以看看。发现我很蛋疼，老是关注这些意义不大的东西。</p>

<h3>9.UIButton设置tintColor</h3>

<p><code>tintColor</code>属性并不是所有button都有的，只有<code>[UIButton buttonWithType:UIButtonTypeSystem]</code>才能设置。如果是init或者initWithFrame，设置了不会显示。</p>

<h3>8.在主线程更新UI-闪烁光标的实现</h3>

<p>在KVO里要调用drawCursorWithRect画光标，而且这个函数里会启动timer来实现光标闪烁，如果直接调用会不闪烁，然后过一会儿闪一次。记着所有跟UI相关的东西都放在主线程执行。这里还有就是NSValue的<code>valueWithCGRect</code>和<code>CGRectValue</code>。还有就是<code>runloop</code>相关的东西，后面看看。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">keyPath</span> <span class="nl">isEqual:</span><span class="s">@&quot;cursorStartPoint&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">cursorStartPoint</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">document</span><span class="p">.</span><span class="n">cursorStartPoint</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGRect</span> <span class="n">cursorRect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">cursorStartPoint</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cursorStartPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">kCursorOffsetY</span><span class="p">,</span> <span class="n">kCursorWidth</span><span class="p">,</span> <span class="n">kCursorHeight</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSValue</span> <span class="o">*</span><span class="n">cursorRectValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGRect:</span><span class="n">cursorRect</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">performSelectorOnMainThread:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">drawCursorWithRect:</span><span class="p">)</span> <span class="nl">withObject:</span><span class="n">cursorRectValue</span> <span class="nl">waitUntilDone:</span><span class="n">NO</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外一个问题是，当有新的手写字符时光标要移动，直接改变cursorLayer的frame属性，会有移动过程的动画，看<a href="http://stackoverflow.com/questions/12103142/calayer-animates-with-frame-change">CALayer animates with frame change?</a>。去掉这个动画的方法是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">[</span><span class="n">CATransaction</span> <span class="n">begin</span><span class="p">];</span>
</span><span class='line'><span class="c1">//或者[CATransaction setAnimationDuration:0];</span>
</span><span class='line'><span class="c1">//或者[CATransaction setDisableActions:YES];</span>
</span><span class='line'><span class="p">[</span><span class="n">CATransaction</span> <span class="nl">setValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCFBooleanTrue</span> <span class="nl">forKey:</span><span class="n">kCATransactionDisableActions</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">myView</span><span class="p">.</span><span class="n">myCALayer</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">){</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span> <span class="p">}</span> <span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">CATransaction</span> <span class="n">commit</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>7.程序突然运行不起来</h3>

<p>先记着后面写，可能是因为最开始建工程时候包含storyboard，中途删掉了storyboard改了Main Interface和AppDelegate和plist，但是可能设备里还是有storyboard的。这样删了程序重新跑的时候就错了。很悲剧的时，设置了异常断点，而问题出在main.m里，这个都没报错的，去掉了才说找不到storyboard。<br/>
试了一下只是简单的在viewDidLoad里改背景颜色，感觉还是怪怪的。直接删了storyboard不改工程配置也能运行，完了删了app重新运行也行，甚至删掉makeKeyAndVisible都能，但是这时候再把Main Interface里的Main删掉，就是黑屏了。</p>

<h3>6.Decode Mutable的东西时要注意mutableCopy</h3>

<blockquote><p>Decoding an archive gives you immutable objects regardless of whether they were mutable or immutable when you encoded them.</p></blockquote>

<p>需要<code>[self setMyArray:[[decoder decodeObjectForKey:@"myArray"] mutableCopy];</code><br/>
还要注意的就是object要copy不然会autorelease <code>You must also copy or retain the string object, otherwise it will be autoreleased:</code>。链接在<a href="http://stackoverflow.com/questions/10391803/nskeyedarchiver-and-nskeyedunarchiver-with-nsmutablearray/10392017#10392017">NSKeyedArchiver and NSKeyedUnarchiver with NSMutableArray</a></p>

<h3>5.toolbar死活不显示</h3>

<p>navigationController的setToolbarHidden属性没设置默认是TRUE。</p>

<h3>4.CGBitmapContext画透明图的实现</h3>

<p>之前是先用一个特定的颜色填充，然后画内容，画完之后再把之前那个颜色mask掉。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Use a &quot;strange or unique&quot; color fill the context add mask it after drawing</span>
</span><span class='line'><span class="n">UIColor</span> <span class="o">*</span><span class="n">fillColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRed:</span><span class="mf">220.0</span><span class="o">/</span><span class="mf">255.0</span> <span class="nl">green:</span><span class="mf">198.0</span><span class="o">/</span><span class="mf">255.0</span> <span class="nl">blue:</span><span class="mf">225.0</span><span class="o">/</span><span class="mf">255.0</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">];</span>
</span><span class='line'><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bitmapContext</span><span class="p">,</span> <span class="n">fillColor</span><span class="p">.</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class='line'><span class="n">CGContextFillRect</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bitmapContext</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">realDisplayWidth</span><span class="p">,</span> <span class="n">realDisplayHeight</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Mask</span>
</span><span class='line'><span class="n">CGImageRef</span> <span class="n">pageImageRef</span> <span class="o">=</span> <span class="n">CGBitmapContextCreateImage</span><span class="p">(</span><span class="n">bitmapContext</span><span class="p">);</span>
</span><span class='line'><span class="k">const</span> <span class="kt">float</span> <span class="n">colorMasking</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">220</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">198</span><span class="p">,</span> <span class="mi">198</span><span class="p">,</span> <span class="mi">225</span><span class="p">,</span> <span class="mi">225</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">};</span>
</span><span class='line'><span class="n">CGImageRef</span> <span class="n">pageImageMask</span> <span class="o">=</span> <span class="n">CGImageCreateWithMaskingColors</span><span class="p">(</span><span class="n">pageImageRef</span><span class="p">,</span> <span class="n">colorMasking</span><span class="p">);</span>
</span><span class='line'><span class="n">UIImage</span> <span class="o">*</span><span class="n">pageImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageWithCGImage:</span><span class="n">pageImageMask</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样的实现非常2，内存开销增加了很大。用<code>CGContextClearRect(bitmapContext, CGRectMake(0, 0, realDisplayWidth, realDisplayHeight));</code>就好了，函数说明就是<code>Paints a transparent rectangle</code>。实现新功能时候先查查比较好的实现方式或者查文档很重要。<br/>
同时要注意，要创建透明位图就要在初始化位图上下文时指定CGBitmapInfo为<code>kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedLast</code>，也可以换成<code>kCGImageAlphaPremultipliedFirst</code>，last就是RGBA反之是ARGB，预乘alpha就代表图像是有alpha通道的，不设置这个clearRect后会是黑色。假如一个像素(A，R，G，B)的四个分量都用规一化的数值表示，(A，R，G，B)为(1，1，0，0)时显示红色。当像素为 (0.5,1,0,0)时，预乘的结果就变成(0.5,0.5,0,0)，这表示原来该像素显示的红色的强度为1，而现在显示的红色的强度降了一半。<br/>
另，<code>颜色深度</code>就是颜色位数，比如RGB一个分量用8位，总共24位，每个像素可以用2的24次方就是16777216中颜色表示，也就是几年前卖手机时候说的1600w色- -！</p>

<h3>3.使用CGBitmapContext并行绘图时报错</h3>

<p>用如下代码进行简单的并行绘制每个字符，结果出现<code>CGContextAddLineToPoint: no current point</code>的错误，就是说在<code>CGContextAddLineToPoint</code>之前并没有一个<code>CGContextMoveToPoint</code>的操作。<br/>
想了一下下面代码有问题，并行绘图的代码里会有这两个操作，待绘制字符多的时候并行程度高，就可能在绘制单个字符的代码中一个的<code>CGContextStrokePath</code>刚执行完，<strong>Stroking the path resets the context&rsquo;s current path to empty, so there is no currentpoint after you call CGContextStrokePath().</strong> context中move到的point已经释放，而另一个正好要执行<code>CGContextAddLineToPoint</code>，于是就<code>no current point</code>了。下面的引文来自<a href="http://lists.apple.com/archives/quartz-dev/2011/Feb/msg00030.html">这里</a></p>

<blockquote><p>Stroking the path resets the context&rsquo;s current path to empty, so there is no currentpoint after you call CGContextStrokePath().ClosePath() isn&rsquo;t there to balance BeginPath() — it modifies the current path by adding a line segment from the current point to the beginning of the current subpath (in such a way that there&rsquo;s a linejoin at that point rather than a pair of line ends).</p></blockquote>

<p>并行绘制最终没想到一个好的并行办法，因为context必须用同一个。最后的解决办法是，能保留上次绘制的context就保留，在其基础上接着绘制- -！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Draw characters concurrently</span>
</span><span class='line'><span class="n">NSIndexSet</span> <span class="o">*</span><span class="n">indexSetToDraw</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSIndexSet</span> <span class="nl">indexSetWithIndexesInRange:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">characterNum</span><span class="p">)];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dataUnitArray</span> <span class="nl">enumerateObjectsAtIndexes:</span><span class="n">indexSetToDraw</span>
</span><span class='line'>                                      <span class="nl">options:</span><span class="n">NSEnumerationConcurrent</span>
</span><span class='line'>                                   <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">DRDCharUnit</span> <span class="o">*</span><span class="n">charUnitToDraw</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                                       <span class="n">currentCharUnit</span> <span class="o">=</span> <span class="n">charUnitToDraw</span><span class="p">;</span>
</span><span class='line'>                                       <span class="n">originPoint</span> <span class="o">=</span> <span class="n">dataUnitUpperLeftPoints</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="n">startIndex</span><span class="p">];</span>
</span><span class='line'>                                       <span class="p">[</span><span class="n">self</span> <span class="nl">drawCharacter:</span><span class="n">currentCharUnit</span> <span class="nl">withOrigin:</span><span class="n">originPoint</span> <span class="nl">inContext:</span><span class="n">bitmapContext</span><span class="p">];</span>
</span><span class='line'>                                   <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://stackoverflow.com/questions/9150665/trouble-drawing-coregraphics-lines-in-drawrect-method">Trouble drawing CoreGraphics lines in drawRect() method</a> 里的回答:You have to place CGContextStrokePath(context); outside the for loop. Otherwise it will create a fresh path on every run through the loop and that fails.
这个人的问题在于for循环最后都strokePath了，而for循环开头都没有moveToPoint，于是错误发生。<br/>
<a href="http://stackoverflow.com/questions/9799682/cgcontextaddlinetopoint-no-current-point">CGContextAddLineToPoint: no current point</a> 还有一个回答：You must first create a path with CGContextBeginPath before you can start adding points and lines to it. 然后有一个针对这个答案的评论：Not true. A CGContext always has a current path (possibly an empty one) which you can add elements to. You need CGContextBeginPath only when you want to discard the current path and start with a new empty path.</p>

<h3>2.创建支持Retina的CGBitmapContext</h3>

<p>原理是创建两倍长两倍宽的位图，同时ScaleCTM使系统绘图时进行坐标转换。代码如下，摘自<a href="http://stackoverflow.com/questions/10867767/how-to-create-a-cgbitmapcontext-which-works-for-retina-display-and-not-wasting-s">这里</a>：</p>

<blockquote><p>A key factor is that, CGContextScaleCTM(context, scaleFactor, scaleFactor); is used to adjust the coordinate system, so that any drawing by Core Graphics, such as CGContextMoveToPoint, etc, will automatically work, no matter it is standard resolution or the Retina resolution.</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//The sample is to create a 768 x 768 point region.  </span>
</span><span class='line'><span class="c1">//On The New iPad, it will be 1536 x 1536 pixel.  </span>
</span><span class='line'><span class="c1">//On iPad 2, it is 768 x 768 pixel.</span>
</span><span class='line'><span class="kt">float</span> <span class="n">scaleFactor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">scale</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGSize</span> <span class="n">size</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">768</span><span class="p">,</span> <span class="mi">768</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGColorSpaceRef</span> <span class="n">colorSpace</span> <span class="o">=</span> <span class="n">CGColorSpaceCreateDeviceRGB</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGContextRef</span> <span class="n">context</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                           <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span>
</span><span class='line'>                           <span class="mi">8</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scaleFactor</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">colorSpace</span><span class="p">,</span>
</span><span class='line'>                           <span class="n">kCGImageAlphaPremultipliedFirst</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">scaleFactor</span><span class="p">,</span> <span class="n">scaleFactor</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>1.CGBitmapContextCreate: unsupported parameter combination</h3>

<p>创建位图上下文时出现的错误：</p>

<blockquote><p>CGBitmapContextCreate: unsupported parameter combination: 8 integer bits/component; 32 bits/pixel; 3-component colorspace; kCGImageAlphaNoneSkipFirst; XXX bytes/row.</p></blockquote>

<p>代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">contextToDraw</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">charUnit</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">charUnit</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span>
</span><span class='line'>                                      <span class="mi">8</span><span class="p">,</span>
</span><span class='line'>                                      <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">colorSpace</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">kCGBitmapByteOrderDefault</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在iOS7之前的代码中，最后一个CGBitmapInfo是kCGImageAlphaPremultipliedFirst，在iOS7下用这个会有警告</p>

<blockquote><p>Implicit conversion from enumeration type &lsquo;enum CGImageAlphaInfo&rsquo; to different enumeration type &lsquo;CGBitmapInfo&rsquo; (aka &lsquo;enum CGBitmapInfo&rsquo;)</p></blockquote>

<p>解决办法是改为<code>kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst</code>。这是因为iOS7中最后一个属性有变化，由<code>CGImageAlphaInfo</code>变为<code>CGBitmapInfo</code>。<a href="http://www.cnblogs.com/wuxiufang/p/3397070.html">这里</a>说的很详细。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不要戳进来]]></title>
    <link href="http://daryl5.github.io/blog/1989/08/13/i-love-grace/"/>
    <updated>1989-08-13T17:23:25+09:00</updated>
    <id>http://daryl5.github.io/blog/1989/08/13/i-love-grace</id>
    <content type="html"><![CDATA[<!--more-->


<p>我爱你，王小妞。</p>
]]></content>
  </entry>
  
</feed>
