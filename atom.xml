<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Daryl's Blog]]></title>
  <link href="http://daryl5.github.io/atom.xml" rel="self"/>
  <link href="http://daryl5.github.io/"/>
  <updated>2015-05-22T17:29:27+08:00</updated>
  <id>http://daryl5.github.io/</id>
  <author>
    <name><![CDATA[Daryl5]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《iOS设计模式解析》笔记]]></title>
    <link href="http://daryl5.github.io/blog/2015/05/21/ios-design-pattern/"/>
    <updated>2015-05-21T14:14:16+08:00</updated>
    <id>http://daryl5.github.io/blog/2015/05/21/ios-design-pattern</id>
    <content type="html"><![CDATA[<!--more-->


<p>[TOC]</p>

<h2>第一章 你好，设计模式</h2>

<h4>1.5.4 作为复合设计模式的MVC</h4>

<p>MVC本身并不是最基本的设计模式，它包含了很多更加基本的设计模式，在MVC中，基本设计模式相互配合。<br/>
Cocoa及Cocoa Touch的MVC中包含的基本模式有：Composite、Command、Mediator、Strategy、Observer。</p>

<ul>
<li>Composite：视图间的相互组合</li>
<li>Command：Target-Action模式，action代码的执行被延迟到特定事件发生</li>
<li>Mediator：Controller在Model和View中起的作用</li>
<li>Strategy：原话是“控制器可以是视图对象的一个策略”，我理解类似代理吧</li>
<li>Observer：模型对象向它所关注的控制器等对象发出内部状态变化的通知，KVO嘛，应该是模型对象向关注它的控制器等对象发出通知</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Software Architecture Patterns』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2015/04/08/reading-software-architecture-patterns/"/>
    <updated>2015-04-08T20:29:54+08:00</updated>
    <id>http://daryl5.github.io/blog/2015/04/08/reading-software-architecture-patterns</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Node.js开发RESTful WebService]]></title>
    <link href="http://daryl5.github.io/blog/2014/08/07/learn-node-dot-js/"/>
    <updated>2014-08-07T19:26:41+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/08/07/learn-node-dot-js</id>
    <content type="html"><![CDATA[<!--more-->


<h2>Node.js的Hello World</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//当有http请求发送过来时，就会调用此回调函数</span>
</span><span class='line'><span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;Content-Type&#39;</span><span class="o">:</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">});</span>
</span><span class='line'>    <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">&#39;Hello World\n&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Node.js是什么</h2>

<p>在Chrome V8引擎上进行扩展从而生成的一个<code>Javascript运行环境/引擎</code>。一般JS都运行在客户端，Node.js使得JS可以在服务器端运行。</p>

<h2>Node.js的特点</h2>

<p><code>1.事件驱动、异步编程</code><br/>
在传统的网络编程中会用到回调函数，比如当socket资源达到某一状态时注册的回调函数就会执行。以Node.js中的Net模块为例，net.Socket对象就有connect、data、end等事件，开发者可以根据自己的业务逻辑注册响应的回调函数到这些事件。在代码中这些事件看上去是顺次注册的，但是它们并<code>不依赖自身出现的顺序</code>，而是在相应事件发生时触发。<br/>
这两个特点得益于Node.js采用的语言是<code>Javascript</code>，Javascript的<code>匿名函数</code>和<code>闭包</code>特性非常适合事件驱动、异步编程。<br/>
<code>2.高性能</code><br/>
选择C++和V8而不选择Ruby或其他虚拟机就是出于性能考虑。<br/>
事实上Node.js是以<code>单进程、单线程</code>模式运行的，事件驱动机制是Node.js通过对内部单线程高效率的维护时间循环队列来实现，没有多线程的资源占用和上下文切换。面对大规模http请求，Node.js凭借事件驱动搞定一切。实验表明Node.js的事件驱动机制和单进程单线程模式导致CPU占用很高。现在已经有一些支持多进程的模块。</p>

<h2>使用Express</h2>

<p><a href="http://expressjs.com/">Express</a>是基于Node.js的web开发框架，它被作为Node.js的一个module导入项目。下面借助Express来实现简单的REST API，这个主题的内容来自<a href="http://blog.modulus.io/nodejs-and-express-create-rest-api">这里</a>。什么是<code>REST API</code>？可以看<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_APIs">维基</a>。简单来说是由GET, PUT, POST和DELETE四种类型的方法组成。<br/>
<code>1.集成Express到项目</code><br/>
修改<code>package.json</code>然后使用<code>npm install</code>来集成。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;first-express-app&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;description&quot;</span><span class="o">:</span> <span class="s2">&quot;a fine piece of express art&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;version&quot;</span><span class="o">:</span> <span class="s2">&quot;0.0.1&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s2">&quot;dependencies&quot;</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="s2">&quot;express&quot;</span><span class="o">:</span> <span class="s2">&quot;3.x&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上例中会有警告，没有README之类的，添加private为true就没有警告了。<br/>
<code>2.Express版的Hello World</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span> <span class="c1">//app是Express server的一个实例</span>
</span><span class='line'>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">res</span><span class="p">.</span><span class="nx">type</span><span class="p">(</span><span class="s1">&#39;text/plain&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Hello World from Express&#39;</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//使用process.env.PORT就是说如果设置了PORT环境变量那就会用设置的端口，否则就是自己设定的3000</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">PORT</span> <span class="o">||</span> <span class="mi">3000</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Server is running...&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后<code>node filename.js</code>并在浏览器访问<code>http://localhost:3000</code>即可。<br/>
<code>3.添加route实现新的API</code><br/>
route可以译作路由，就是访问网站时站点名后加的参数等等，用于实现在网站内跳转。在上面的代码中添加代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">quotes</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'><span class="p">{</span> <span class="nx">author</span> <span class="o">:</span> <span class="s1">&#39;Audrey Hepburn&#39;</span><span class="p">,</span> <span class="nx">text</span> <span class="o">:</span> <span class="s2">&quot;Nothing is impossible, the word itself says &#39;I&#39;m possible&#39;!&quot;</span><span class="p">},</span>
</span><span class='line'><span class="p">{</span> <span class="nx">author</span> <span class="o">:</span> <span class="s1">&#39;Walt Disney&#39;</span><span class="p">,</span> <span class="nx">text</span> <span class="o">:</span> <span class="s2">&quot;You may not realize it when it happens,  </span>
</span><span class='line'><span class="s2">            but a kick in the teeth may be the best thing in the world for you&quot;</span><span class="p">},</span>
</span><span class='line'><span class="p">{</span> <span class="nx">author</span> <span class="o">:</span> <span class="s1">&#39;Unknown&#39;</span><span class="p">,</span> <span class="nx">text</span> <span class="o">:</span> <span class="s2">&quot;Even the greatest was once a beginner. Don&#39;t be afraid to take that first step.&quot;</span><span class="p">},</span>
</span><span class='line'><span class="p">{</span> <span class="nx">author</span> <span class="o">:</span> <span class="s1">&#39;Neale Donald Walsch&#39;</span><span class="p">,</span> <span class="nx">text</span> <span class="o">:</span> <span class="s2">&quot;You are afraid to die, and you&#39;re afraid to live. What a way to exist.&quot;</span><span class="p">}</span>
</span><span class='line'><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//bodyParser中间件，可以parse请求的body，然后把body传给request的body property</span>
</span><span class='line'><span class="c1">//用于解析POST请求的内容</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">bodyParser</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">(</span><span class="nx">quotes</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/quote/random&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">id</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">quotes</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">quotes</span><span class="p">[</span><span class="nx">id</span><span class="p">];</span>
</span><span class='line'>    <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">(</span><span class="nx">q</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//支持传入参数</span>
</span><span class='line'><span class="c1">//http://localhost:3000/quote/2</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/quote/:id&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="nx">quotes</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span> <span class="o">||</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">res</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">404</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Error 404: No quote found&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">quotes</span><span class="p">[</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">];</span>
</span><span class='line'>    <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">(</span><span class="nx">q</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//curl -v -H &quot;Accept: application/json&quot; -H &quot;Content-type: application/json&quot; -X  </span>
</span><span class='line'><span class="c1">//POST -d &#39;{&quot;author&quot;: &quot;daryl&quot;, &quot;text&quot;: &quot;daryls post&quot;}&#39; http://localhost:3000/quote/</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/quote&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;author&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">res</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">400</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Error 400: Post syntax incorrect.&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">newQuote</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">author</span> <span class="o">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">author</span><span class="p">,</span>
</span><span class='line'>        <span class="nx">text</span> <span class="o">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">text</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">quotes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">newQuote</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//curl -I -X DELETE http://localhost:3000/quote/7</span>
</span><span class='line'><span class="nx">app</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">&#39;/quote/:id&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="nx">quotes</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">res</span><span class="p">.</span><span class="nx">statusCode</span> <span class="o">=</span> <span class="mi">404</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Error 404: No quote found&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">quotes</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考文献</h2>

<p>1.<a href="http://www.infoq.com/cn/articles/what-is-nodejs">深入浅出Node.js（一）：什么是Node.js</a>  系列文章在<a href="http://www.infoq.com/cn/master-nodejs">这里</a><br/>
2.<a href="http://blog.modulus.io/nodejs-and-express-create-rest-api">NODE.JS AND EXPRESS &ndash; CREATING A REST API</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于产品官方微博运营的想法]]></title>
    <link href="http://daryl5.github.io/blog/2014/07/10/gfdi-weibo-operation/"/>
    <updated>2014-07-10T14:40:20+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/07/10/gfdi-weibo-operation</id>
    <content type="html"><![CDATA[<p>分享给小伙伴们的文章，在作业部落写的，博客也存一份，<a href="https://www.zybuluo.com/daryl5/note/19349">这里</a>阅读效果更好。</p>

<!--more-->


<p>很久没有像这样写大段文字了，所以下面的内容很可能出现各种语死早的表达，大家觉得写得很乱、表意不明或者写得恶心的地方直接微信我。下面都是在说微博，微信没怎么玩过不了解。直接开始。</p>

<h3>1.做“有故事”的运营</h3>

<p>如果GFDI（暂时先这么叫了）上线了，官方微博需要宣传一下来引来最初的几十几百个下载，那么设想下面两个场景：</p>

<ul>
<li>发长微博，内容是App主要功能点使用截图加上功能描述，比如“愿望清单/把你最想做的/记录下来/一个一个去实现”，配图就是愿望清单的截图；</li>
<li>发长微博，内容是<code>小W，北方一所211高校的学生</code>，配图是大学宿舍里台灯下一个打Dota的男生的背影，可以是照片或者漫画形式；然后，<code>他学习中等偏上，等到毕业，应该能找到一份不错的工作</code>，配图是小W在睡觉，梦里的他穿着正装面无表情的坐在电脑前上班，隔间的名牌上写着“市场部经理 WXX”，这里要突出一个无聊；然后，<code>但是他觉得大学很没意思，甚至，人生也没什么意思</code>，配图是宿舍、食堂、自习室三点一线，背景图是水印形式大字体的“买房、买车、加薪”这样的字眼，这里还是要突出一个无聊没意思；然后，<code>练一身肌肉、学一种乐器、一次远行、一段爱情......很近，也很遥远</code>，配图是发呆的小W，脑袋上的气泡里各种我想我想我想；然后，<code>但其实，你觉得遥远，只是因为，你根本一步都没有走出去！如果每天一小步，那么一个月，一年？</code>，配图是小W拿着手机，手机屏幕上是App“愿望清单”的界面，有一项是“减肥15斤”，App同时显示着“距离愿望发起 12天 还剩 18天 已付出35小时”，然后列表里这一项的右边是一个闹钟类似图标，实际上就是“马上去做”按钮，点了就开启计时器，来为这个愿望付出时间。这里就真正开始介绍App功能了，不用写明这个愿望清单到底有什么功能那个闹钟点了到底有什么用，把潜在用户带入这个场景之后，基本看一眼就明白了。</li>
</ul>


<p>“有故事”也可以说是“有意义”。简单说就是不用截图文字直接介绍App功能，而是在一个故事里慢慢介绍。再设想如果我在刷微博，看到有人转发了上面第二个方案里的长微博时候我的内心活动，看到第一句时候，“恩我也是”，看到第二句“好吧我也差不多”，第三句“想想是挺没意思的”，第四句“我也想过练肌肉学乐器什么的”，第四句“卧槽确实是，说了健身了从来就没去过健身房”，然后看到“点一下闹钟图标马上开始为一个愿望付出时间”这个场景，觉得这个不错，有点意思，而且应用界面看着不错，搜一下看看，然后就多了一个下载- -！这段yy的有点恶心不过之所以写出这么个故事是因为这个小W跟我很像，所以他的故事能触动我的“痛点”，在长微博中他最后自我拯救了我会感觉我也能，所以我会去下这个App。
好的故事总是能让人想很多，如果故事本身跟自己的经历很像而且还是个好故事，让自己产生一种“这tm简直就是在说我”的感觉，那应该会更容易读下去并去主动接受关于App的介绍最终去下载。针对GFDI的运营，我觉得有个优势就是，现在很屌丝，而屌丝是这个App目标用户群的很大一部分，真正能自我约束积极上进的人并不太需要这么个App，所以如果能从自身出发，讲出好的故事去打动屌丝群体，应该会比直接列功能效果好很多。对其他目标群体用一样的方法。
之前想过一个“衣橱管家”的App，因为我女朋友每天早上上班前都会为穿什么发愁，就让我做一个App把她所有衣服收录在手机里然后晚上睡觉前就能躺在床上把第二天要穿的衣服挑好。当时就想到一个故事，故事的目标听众是整天忙忙碌碌累死累活的女白领，具体的就不写了，也是这种以“小X是XX公司的一个&hellip;”开头的故事，当时就觉得，这种讲故事的形式的推广效果应该会不错。
微博上其实也有类似的行为，天才小熊猫的各种手游的软广都是在讲故事或者跟所长唱双簧。这种营销没太大成本，有一些画漫画的会接这种活，然后找周围朋友转一转，应该会不错。
另外，讲故事可以一直在官微进行，可以长微博可以大段文字，可以讲粉丝自我拯救的故事或者假装是粉丝自我拯救实际上是自己编的故事。最后我真的觉得上面虚构的那个故事会打动我，会让想我去尝试这个App。</p>

<h3>2.“好玩”太重要了</h3>

<p>这个其实没什么好说的，我猜大家都会认同。做成段子手的官微有很多，粉丝活跃程度都不错，反而一本正经介绍产品的，没几个人愿意转发。
比如说，如果QQ拼音新版发布，新增了<code>云剪贴板</code>的功能（查了下3年前就有这个功能），就是能在手机上复制，在电脑上粘贴类似的。想到一个文案，“老板你在家里的电脑上ctrl+c在公司电脑上ctrl+v真的行啊！”，参考下面这个老笑话：</p>

<blockquote><p>是这样的张总, 您在家里的电脑上按了ctrl+c，然后在公司的电脑上再按ctrl+v是肯定不行的。即使同一篇文章也不行。不不，多贵的电脑都不行。</p></blockquote>

<p>这应该比直接文字介绍能引来更多转发，而且功能介绍、使用场景什么的都介绍了。
具体到GFDI的运营，刚想到一个，直接在微博里搜“想减肥”，会发现好多姑娘发的下面这种微博（还有好多减肥药广告- -！）：</p>

<blockquote><p>1.又虐心了，唉，过不去[感冒]我想减肥，一直没坚持。我想垫鼻子，一直不敢。我想了结并重新开始一些事情，一直都顾此失彼。我想决定确认一些东西，一直都拖着放着。人终究还是可怜的，卑微的，能够左右掌握的东西太少。时间太快，我已开始变老，生活实属太多力不从心无可奈何。要尽快了…<br/>
2.我想减肥，想穿好看得衣服，但又想吃好吃得。为什么活着这么纠结了[抓狂][抓狂][抓狂]我好痛苦[不想上班]</p></blockquote>

<p>然后官微可以直接去评论并转发“什么都别说，想减肥敢不敢吃完晚饭马上去操场跑十圈！！”，这个事情可以持续几个小时，到时候官微上全是转发的类似微博，转发内容也都是这一句话。晚点时候可以再发一条“还没吐槽累呢就到一天最大微博数了，小浪你到底行不行”，或者花钱雇营销大号发“发现野生2b小编一只@GFDI”这种微博，配图就是官微截图，一整页的转发微博。如果是我我会点过去围观这个逗b的官微的。当然有个大前提，开通会员，置顶微博是介绍App的微博，不然人点进来都不知道GFDI是什么，那就悲剧了。
这个例子写的太过具体，实际运营时候不一定适用，总的来说我觉得官微必须好玩甚至逗b，必须有性格有血有肉。
另外有一个“变得好玩”的简单又猥琐的办法，找韩寒或者其他粉丝活跃度高的微博，去复制粘贴赞的最多的评论引最初的粉丝去转发，这个不像抄别人的段子，抄段子会被投诉，抄精品评论没有风险，不过也没有节操。</p>

<h3>3.有性格、b格各种格</h3>

<p>最近玉林狗肉节闹得很火，如果官微运营人员三观正，有思想敢吐槽，比如持“猪可以吃那么狗也可以吃，不过宠物狗不能吃，非法捕杀的不能吃”的观点，然后很犀利的发出来，有人转发了，然后官微遭“狗粉”狂喷。我觉得这不见得是坏事，只要保证不惹大部分人嫌弃，高的曝光肯定是好的。
这个例子不是很恰当，并不是想说不择手段争取高的曝光度，而是说官微不一定要一直一直宣传产品，也可以真正做有血有肉的人，典型的如杜蕾斯的官微，感觉很有性格。</p>

<h3>4.好的内容</h3>

<p>这个其实就是列一下，好的内容来吸引粉丝这应该是微博营销这个事儿最应该是的样子吧。不过搜集好的内容或者自己原创真的很麻烦，可以考虑转发新绿芽的微博，也正好互相带一带。</p>

<h2>最后</h2>

<p>这四点真是越写越短，因为写着写着就觉得这个事儿没啥可写的，具体执行时候动点脑子就会不错吧。写的也都很简单，具体执行时候也得再具体考虑（比如上面第二点说的转发姑娘要减肥的微博并吐槽，刚突然想到发太多微博会惹人烦会被取关的，在最初只有僵尸粉的时候可以这么干一下或者换一种形式做），不过我觉得写的这些东西都是一些值得思考的方向。
最后，真正运营的时候，可能一天都需要发几十条微博，每条都十分用心那太累了，上面想的那些，严格说并不是日常运营的思路，只是去创造App下载量“引爆点”的方法。
最最后，大家一起努力，先上线了才能有这些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make A Swipeable TableviewCell]]></title>
    <link href="http://daryl5.github.io/blog/2014/06/25/swipeable-table-view-cell/"/>
    <updated>2014-06-25T19:59:06+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/06/25/swipeable-table-view-cell</id>
    <content type="html"><![CDATA[<p>来自RW的博文<a href="http://www.raywenderlich.com/62435/make-swipeable-table-view-cell-actions-without-going-nuts-scroll-views">How To Make A Swipeable Table View Cell With Actions – Without Going Nuts With Scroll Views</a>。</p>

<!--more-->


<h3>1.UITableViewCell结构解析</h3>

<p><code>给view添加背景色</code>和<code>recursiveDescription</code>都可以用来解析控件结构。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#ifdef DEBUG</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Cell recursive description:</span><span class="se">\n\n</span><span class="s">%@</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">cell</span> <span class="nl">performSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">recursiveDescription</span><span class="p">)]);</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>iOS7上tableViewCell的结构如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">TableViewCell</span>
</span><span class='line'>    <span class="n">CellScrollView</span>
</span><span class='line'>        <span class="c1">//SeparatorView</span>
</span><span class='line'>        <span class="n">Button</span>                 <span class="n">disclosure</span> <span class="n">button</span>
</span><span class='line'>            <span class="n">ImageView</span>          <span class="n">button</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">image</span>
</span><span class='line'>        <span class="n">ContentView</span>
</span><span class='line'>            <span class="n">Label</span>              <span class="n">cell</span> <span class="n">text</span> <span class="n">label</span>
</span><span class='line'>        <span class="c1">//SeparatorView</span>
</span></code></pre></td></tr></table></div></figure>


<p>删除时候结构如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">TableViewCell</span>
</span><span class='line'>    <span class="n">CellScrollView</span>
</span><span class='line'>        <span class="n">DeleteConfirmationView</span>
</span><span class='line'>            <span class="n">Confirmation</span> <span class="n">Button</span>
</span><span class='line'>                <span class="n">Label</span>          <span class="s">&quot;Delete&quot;</span>
</span><span class='line'>        <span class="c1">//SeparatorView</span>
</span><span class='line'>        <span class="n">ContentView</span>
</span><span class='line'>            <span class="n">Label</span>
</span><span class='line'>        <span class="c1">//Separator View</span>
</span><span class='line'>        <span class="n">Button</span>
</span><span class='line'>            <span class="n">ImageView</span>
</span></code></pre></td></tr></table></div></figure>


<p>iOS8上如下，对比iOS7主要是少了<code>UITableViewCellScrollView</code>，这是个UIScrollView的实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">TableViewCell</span>
</span><span class='line'>    <span class="n">ContentView</span>
</span><span class='line'>        <span class="n">Label</span>                  <span class="n">cell</span> <span class="n">text</span> <span class="n">label</span>
</span><span class='line'>    <span class="c1">//SeparatorView</span>
</span><span class='line'>    <span class="n">Button</span>
</span><span class='line'>        <span class="n">ImageView</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据官方文档，自定义cell只能在ContentView上添加subview。我们要做的，就是参照苹果实现滑动展示删除按钮的思路，在ContentView上另外实现一套，然后把原本的删除禁掉。</p>

<h3>2.一个Swipeable TableViewCell的必要成分</h3>

<p>由上一部分最后一段可以知道，我们需要一些<code>需要展示的UIButton</code>，然后一个位于这些按钮之上的<code>Container view</code>来显示所有内容，然后需要一个UIScrollView或者<code>UIPanGestureRecognizer</code>来显示或者隐藏按钮，这里我们用后者。最后，<code>需要展示cell内容的views</code>。然后把这些内容都贴到cell的ContentView上。这里有点拗口，对应上面iOS7的cell结构。<br/>
需要禁掉系统cell的滑动删除：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span> <span class="nf">canEditRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.建立自定义cell</h3>

<p>直接在storyboard中编辑prototypecell，然后绑定cell所属类，并在tableview代理中返回相应的类型。这里非常坑，半天显示不出来两个按钮，基础太差代码写的太少了，哎。原因见<a href="http://stackoverflow.com/questions/22352587/xcode-5-1-uitableview-in-uiviewcontroller-custom-tableviewcell-outlets-are-nil">Xcode 5.1 UITableView in UIViewController &ndash; Custom TableViewCell Outlets are nil</a>。具体原因是：</p>

<ol>
<li>如果在xib或者storyboard中建立cell了，那么直接deque就能获得cell；</li>
<li>如果要用自定义的cell，那么就要先registerclass，然后重用的时候deque；这时候虽然没有xib，但是运行时也知道如何去建立cell，就用刚注册过的类建立。</li>
</ol>


<p>未完待续&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Language Highlights: An Objective-C Developer’s Perspective]]></title>
    <link href="http://daryl5.github.io/blog/2014/06/06/swift-language-highlights-an-objc-develpers-perspective/"/>
    <updated>2014-06-06T13:57:06+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/06/06/swift-language-highlights-an-objc-develpers-perspective</id>
    <content type="html"><![CDATA[<!--more-->


<p><a href="http://www.raywenderlich.com/73997/swift-language-highlights">原文</a>是RW Tutorials里Matt Galloway写的，跟之前自己写的<a href="http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers/">Introduction to C++ for iOS Developers</a>类似，这篇文章是站在Objc开发者的角度来看Swift。这种通过比较两种语言的特性来学习的方法，我认为是最好的。</p>

<h4>1.Types</h4>

<p>a.Swift引入了<a href="http://en.wikipedia.org/wiki/Type_inference">Type Inference</a>，开发者不需要显式指定变量类型，<code>编译器</code>会根据变量被赋的值来推断变量的类型，如下例。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// automatically inferred</span>
</span><span class='line'><span class="n">var</span> <span class="n">name1</span> <span class="o">=</span> <span class="s">&quot;Matt&quot;</span>
</span><span class='line'><span class="c1">// explicit typing (optional in this case)</span>
</span><span class='line'><span class="n">var</span> <span class="nl">name2:</span><span class="n">String</span> <span class="o">=</span> <span class="s">&quot;Matt&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift还引入了<a href="http://en.wikipedia.org/wiki/Type_safety">Type Safety</a>。在Swift中，大多数情形下编译器明确知道一个对象所属的类型，这使得编译器能够在编译期间做更多的事，比如优化。其他少数情形可以参考C++中的<a href="http://en.wikipedia.org/wiki/Vtable">虚表</a>适用情形。<br/>
b.Objc是<code>Dynamic Typing</code>的，编译期间不会知道变量类型，<code>运行时</code>负责处理对象类型分析、消息分派等。这使得我们拥有在运行时给一个类动态添加方法等等黑魔法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">Person</span> <span class="o">*</span><span class="n">matt</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithName:</span><span class="s">@&quot;Matt Galloway&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">matt</span> <span class="n">sayHello</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>对上面的代码，编译器会去Person类的头文件去查看是否有sayHello方法，但是只会进行最简单的方法存在确认，由于Objc的动态特性，编译器不知道sayHello方法是否会在运行时改变，甚至不知道sayHello到底有没有实现。这种情形需要手动调用<code>respondsToSelector:</code>来检查。<br/>
正是因为这种动态类型的特性，编译器能做的优化很少。系统用<code>objc_msgSend</code>来处理方法调度，在这个方法中运行时会根据调用方法的selector去寻找其对应实现并调用。这个过程增加了一些开销。<br/>
c.下面分析Swifit对于类型的处理，如下例。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">var</span> <span class="n">matt</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="p">:</span><span class="s">&quot;Matt Galloway&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">matt</span><span class="o">.</span><span class="n">sayHello</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译器明确知道matt是Person类的实例，并知道sayHello方法具体定义在哪儿。那么在编译时就可以优化使得运行时能直接跳到方法实现的地方，而不需要动态调用。在其他特殊情形下，会利用类似C++<a href="http://en.wikipedia.org/wiki/Vtable">虚表</a>的机制来实现，这虽然增加了一些开销但是比<code>Dynamic Dispatch</code>少了很多。</p>

<blockquote><p>总的来说：<br/>
The compiler is much more helpful in Swift. It will help stop subtle type related bugs from entering your codebase. It will also make your code run faster by enabling smart optimisations.</p></blockquote>

<h4>2.Generics</h4>

<p>Swift引入了<a href="http://en.wikipedia.org/wiki/Generic_programming">泛型</a>，类似C++中的<code>模板</code>。这里有引文：</p>

<blockquote><p> Swift is strict about types, you must declare a function to take parameters of certain types. But sometimes you have some functionality that is the same for multiple different types.</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">struct</span> <span class="n">IntPair</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">a:</span> <span class="n">Int</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">b:</span> <span class="n">Int</span><span class="o">!</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">a:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">b:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="n">equal</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">intPair</span> <span class="o">=</span> <span class="n">IntPair</span><span class="p">(</span><span class="nl">a:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">b:</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="n">intPair</span><span class="p">.</span><span class="n">a</span> <span class="c1">// 5</span>
</span><span class='line'><span class="n">intPair</span><span class="p">.</span><span class="n">b</span> <span class="c1">// 10</span>
</span><span class='line'><span class="n">intPair</span><span class="p">.</span><span class="n">equal</span><span class="p">()</span> <span class="c1">// false</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果还需要一个FloatPair的话，就需要用到泛型了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">struct</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="nl">T:</span> <span class="n">Equatable</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">a:</span> <span class="n">T</span><span class="o">!</span>
</span><span class='line'>    <span class="n">let</span> <span class="nl">b:</span> <span class="n">T</span><span class="o">!</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nl">a:</span> <span class="n">T</span><span class="p">,</span> <span class="nl">b:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="n">equal</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">pair</span> <span class="o">=</span> <span class="n">Pair</span><span class="p">(</span><span class="nl">a:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">b:</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="n">pair</span><span class="p">.</span><span class="n">a</span> <span class="c1">// 5</span>
</span><span class='line'><span class="n">pair</span><span class="p">.</span><span class="n">b</span> <span class="c1">// 10</span>
</span><span class='line'><span class="n">pair</span><span class="p">.</span><span class="n">equal</span><span class="p">()</span> <span class="c1">// false</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">floatPair</span> <span class="o">=</span> <span class="n">Pair</span><span class="p">(</span><span class="nl">a:</span> <span class="mf">3.14159</span><span class="p">,</span> <span class="nl">b:</span> <span class="mf">2.0</span><span class="p">)</span>
</span><span class='line'><span class="n">floatPair</span><span class="p">.</span><span class="n">a</span> <span class="c1">// 3.14159</span>
</span><span class='line'><span class="n">floatPair</span><span class="p">.</span><span class="n">b</span> <span class="c1">// 2.0</span>
</span><span class='line'><span class="n">floatPair</span><span class="p">.</span><span class="n">equal</span><span class="p">()</span> <span class="c1">// false</span>
</span></code></pre></td></tr></table></div></figure>


<h4>3.Containers</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Objective-C高级编程』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/05/10/pro-multithreading-and-memory-management-for-ios-and-os-x/"/>
    <updated>2014-05-10T19:20:32+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/05/10/pro-multithreading-and-memory-management-for-ios-and-os-x</id>
    <content type="html"><![CDATA[<!--more-->


<h1>第一章 ARC</h1>

<h2>1.2 内存管理</h2>

<h4>1.2.2 ARC进行内存管理的思考方式</h4>

<ul>
<li>自己生成的对象，自己持有（alloc/new/copy/mutableCopy了就也retain了）</li>
<li>非自己生成的对象，自己也能持有（retain）</li>
<li>自己不再需要持有的对象时释放（release）</li>
<li>非自己持有的对象无法释放（没retain/alloc/new/copy/mutableCopy就不能release）</li>
</ul>


<p>1.OC的内存管理方法实际上不在OC语言里，而是包含在Cocoa框架中的。（OC是C的超集，Cocoa是对OC加了内存管理、多媒体、网络通讯等等的类库形成的用来给OS X开发应用的框架，Cocoa Touch是对Cocoa进行移动适配形成的另一套OC的类库）<br/>
2.Cocoa框架中Foundation框架类库中的NSObject类担负内存管理的职责，内存管理调用的alloc、retain等方法指代的就是NSObject类中的alloc类方法、retain实例方法等。（所有对象继承自NSObject，alloc、retain等内存管理方法在NSObject中实现，这也就是为什么初始化对象时候要先[super init]以及dealloc最末要[super dealloc]）<br/>
3.<code>[NSObject new</code>和<code>[[NSObject alloc] init]</code>是完全等价的。<br/>
4.类似<code>id obj = [NSMutableArray array]</code>这样的生成的类对象并不会被obj所持有，也就是说这行代码里不包含<code>[obj retain]</code>(有<code>[obj autorelease]</code>)，总是这么写不过都是在ARC下，没意识到这个问题。如果是手动管理，加retain就好。</p>

<h4>1.2.3 alloc/retain/release/dealloc实现</h4>

<p>1.NSZone是为了防止内存碎片化而引入的结构。如果分配几块内存依次是小大小大小大，这样释放所有的“小”之后就形成了碎片，所以要有一大一小两种<code>区域</code>，小的去小的大的去大的。<br/>
<strong>现在的运行时的内存管理已经很高效，使用NSZone反而可能会降低效率或使源代码复杂，所以运行时都会忽略NSZone</strong>。<br/>
2.GNUstep是Cocoa框架的互换框架，两者实现不一定相同不过行为是一样的，这一节主要通过读GNUstep中<code>NSObject.m</code>中alloc、retain等方法的源代码来深入了解内存管理。<br/>
3.GNUstep使用<code>内存块头部管理引用计数</code>，苹果使用<code>引用计数表</code>管理引用计数。</p>

<h4>1.2.5 autorelease</h4>

<p>1.和C语言的<code>局部变量(Automatic Variable)</code>类似，如在函数内定义的int，除了函数就废掉了。autorelease的作用范围是NSAutoreleasePool，在<code>[pool drain]</code>时每个调用过autorelease的对象都会调用release。
2.只要不drain pool，生成的对象就不会被释放，内存就越来越少，所以在for循环里如果有很多autorelease对象那就定义一个NSAutoreleasePool来降低内存峰值。
3.Cocoa框架也有很多类方法会返回autorelease的对象。如<code>[NSMutableArray arrayWithCapacity:1]</code>等效于<code>[[[NSMutableArray alloc] initWithCapacity:1] autorelease]</code>。</p>

<h3>1.2.6 autorelease的实现</h3>

<p>1.本质就是<code>调用NSAutoreleasePool的addObject方法</code>。<br/>
2.NSAutoreleasePool的管理应该用的是栈，一个pool是就是栈中的一个项目。</p>

<h2>1.3 ARC规则</h2>

<h4>1.3.3 所有权修饰符</h4>

<p>1.ARC有效时，一共有4种修饰符：</p>

<ol type="a">
<li>__strong</li>
<li>__weak</li>
<li>__unsafe__unretained</li>
<li>__autoreleasing</li>
</ol>


<p>2.所有id和对象都必须加上所有权修饰符，默认是__strong，也就是说:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//这两个等效</span>
</span><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span> <span class="n">__strong</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.所谓强/弱引用实际就是<code>指针对一块内存（或者说一个对象）的引用</code>。<br/>
强引用就是，别人可以release，但是运行时不能销毁这个对象，因为我还强引用着呢。其实就是给retainCounter加了1，所以对象不会被销毁，除非自己再去调用release。<br/>
弱引用就是我在用但是我没给引用计数加1，别人release了我也就用不了了。<br/>
4.简单总结<br/>
<code>ARC实现方式</code><br/>
GNUstep中每个对象头部都存储着自身的引用计数；<br/>
Apple用runtime统一存储所有对象的引用计数，用的是哈希表，以对象地址作为key，引用计数值和真正的内存地址作为值。有一个好处，即使因为故障导致对象所在内存被破坏，但只要引用计数表还在，就能确认内存块位置（这里真的没太懂，可以参考下面__weak的部分，存储指针的地址）。<br/>
<code>__autoreleasing</code><br/>
用该关键词修饰的变量会被注册到autoreleasepool；<br/>
当方法名不是alloc/new/copy/mutablecopy时候，如果要返回object，这个object会被注册到autoreleasepool；<br/>
访问__weak修饰的变量时，该变量会被注册到autoreleasepool，以确保不会因为原有对象被释放而非法访问，因为只要pool还在，该对象都是有效的。<br/>
<code>__weak</code><br/>
也称智能指针，因为当对象被release时候指针会被置nil。<br/>
实现原理是：本质也是<code>哈希表</code>，把对象地址作为key，然后把指向对象的指针的地址（可能有多个指针都指着）作为value。这样当release对象的时候就在weak表中找到所有指向该对象的指针的地址，进而将所有指针都设置为nil。然后还会在weak表中删除该键值对。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to C++ for iOS Developers]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers/"/>
    <updated>2014-04-24T21:43:30+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers</id>
    <content type="html"><![CDATA[<p>摘自<a href="http://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1">Introduction to C++ for iOS Developers</a>，这篇文章第二部分在<a href="http://www.raywenderlich.com/62990/introduction-c-ios-developers-part-2">这里</a>。<br/>
写了太久OC再去看C++，最好的方式当然是比较着来学习，所以说这篇博文真的太赞了。先挖坑，明天填。如果要学可以去<a href="http://www.learncpp.com">Learn C++</a>。</p>

<!--more-->


<h3>1.Getting Started: A Brief History of Languages</h3>

<p>C++曾经叫做<code>"C with Classes"</code>，OC其实也是在C上做了类这一扩展，两者的区别在于：C++的很多行为发生在编译期而OC更多在运行时期。所以像<code>Method Swizzling</code>这种东西C++是不可能有的。C++也没有<code>Introspection</code>和<code>Reflection methods</code>，不可能知道一个对象属于哪个类。</p>

<h3>2.C++ Classes</h3>

<p>OC的类</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// MyClass.h</span>
</span><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyClass</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// MyClass.m</span>
</span><span class='line'><span class="cp">#import “MyClass.h”</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MyClass</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++的类</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// MyClass.h</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// MyClass.cpp</span>
</span><span class='line'><span class="cp">#include “MyClass.h”</span>
</span><span class='line'><span class="cm">/* Nothing else in here */</span>
</span></code></pre></td></tr></table></div></figure>


<p>在OC中所有的类都集成自<code>NSObject</code>，如果删掉会编译报错<code>Class 'Test' defined without specifying a base class</code>。OC给C引入了<code>#import</code>来保证一个文件只能被包含一次，C++无对应机制。</p>

<h3>3.Class Member Variables and Functions</h3>

<p>1.C++里叫<code>成员变量&amp;成员函数</code>，OC里叫<code>实例变量&amp;实例方法</code>。C++中没有<code>method</code>这个术语。在OC中，method就是通过消息派送来调用的东西，而函数是静态的C方式的函数调用如myFunction(intValue)。<br/>
2.C++中成员变量和方法默认是<code>Private</code>的，OC中没有绝对的private。<br/>
3.C++使用类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//注意这里没有星号，m是存在栈上的，在Memory Management部分可以看到，OC里所有对象都必须加星号声明，使之存在堆</span>
</span><span class='line'><span class="c1">//存在栈上的所以不用new</span>
</span><span class='line'><span class="n">MyClass</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'><span class="n">m</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="n">m</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span><span class='line'><span class="n">m</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.Implementing Class Member Functions</h3>

<p>1.<code>MyClass::foo() {}</code>这里的<code>::</code>就是表示foo函数是作为MyClass的一部分实现的。<br/>
2.在头文件中直接实现成员函数就是<code>让编译器去尝试内联</code>。内联就是说当调用该函数时，不会跳到一个新的函数块，而是把整个函数的代码都在编译时候内联在了调用处。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// MyClass.h</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Do something</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5.Namespaces</h3>

<p>1.比如<code>::</code>就是对命名空间的一种指定方式，用来告诉编译器<code>应该去哪里找这个foo函数</code>。<br/>
2.C++命名空间的使用。OC无命名空间，只有设定工程的<code>类名前缀</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">namespace</span> <span class="n">MyNamespace</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">namespace</span> <span class="n">LibraryNamespace</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span> <span class="err">…</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">MyNamespace</span><span class="o">::</span><span class="n">Person</span> <span class="n">pOne</span><span class="p">;</span>
</span><span class='line'><span class="n">LibraryNamespace</span><span class="o">::</span><span class="n">Person</span> <span class="n">pTwo</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.Memory Management</h3>

<p>a.栈固定大小；当指定函数运行时，数据将会入栈，函数运行完同样数量的数据将会出栈。因此随着程序运行，对栈容量的需求不会持续增长。<br/>
b.堆也是一块用于运行程序的内存，不过大小不固定；随着程序运行，占用堆将会增多；程序会把在函数外还会使用的东西放在堆上（比如函数调用传指针，用来当做参数的指针在栈里，而指针所指内容在外部需要用到，因此指针内容在堆上）；此外比较大的数据也会在堆上因为栈很小。</p>

<p>C++和OC对堆栈使用的区别</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span> <span class="n">stackInt</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">//用的栈空间，函数返回时存储数字&#39;5&#39;的内存会被自动释放</span>
</span><span class='line'><span class="c1">//heapInt用堆空间，需要手动释放</span>
</span><span class='line'><span class="c1">//是不是应该说存储5的内存是分配在堆上的而不是heapInt，heapInt和stackInt应该在符号表什么的吧</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">heapInt</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class='line'><span class="o">*</span><span class="n">heapInt</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="n">free</span><span class="p">(</span><span class="n">heapInt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在OC中尝试分配到栈上<code>NSString stackString;</code>将会有编译错误<code>interface type cannot be statically allocated</code>。OC需要所有object都在堆上这样RC就能控制所有对象的生存与否。<br/>
C++中对象也可以在栈上，如<code>MyPerson person</code>vs<code>MyPerson *person = new MyPerson()</code>，参考Implementing Class Member Functions部分和下面这一部分。</p>

<h3>7.C++ new and delete</h3>

<p>C++引入new和delete来创建&amp;摧毁堆上的对象</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Person</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span> <span class="c1">//对应OC里的alloc init</span>
</span><span class='line'><span class="k">delete</span> <span class="n">person</span><span class="p">;</span> <span class="c1">//OC里没有delete，这一操作由运行时在对象的引用计数为0时自动完成</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//标量也行</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">();</span>
</span><span class='line'><span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="k">delete</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>8.Accessing Members of Stack and Heap Objects</h3>

<p>1.C++访问栈里对象的成员变量或调用成员函数要用点，堆里的用->。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Person</span> <span class="n">stackPerson</span><span class="p">;</span>
</span><span class='line'><span class="n">stackPerson</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="err">“</span><span class="n">Bob</span> <span class="n">Smith</span><span class="err">”</span><span class="p">;</span> <span class="c1">///&lt; Setting a member variable</span>
</span><span class='line'><span class="n">stackPerson</span><span class="p">.</span><span class="n">doSomething</span><span class="p">();</span> <span class="c1">///&lt; Calling a member function</span>
</span><span class='line'>
</span><span class='line'><span class="n">Person</span> <span class="o">*</span><span class="n">heapPerson</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>
</span><span class='line'><span class="n">heapPerson</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="err">“</span><span class="n">Bob</span> <span class="n">Smith</span><span class="err">”</span><span class="p">;</span> <span class="c1">///&lt; Setting a member variable</span>
</span><span class='line'><span class="n">heapPerson</span><span class="o">-&gt;</span><span class="n">doSomething</span><span class="p">();</span> <span class="c1">///&lt; Calling a member function</span>
</span></code></pre></td></tr></table></div></figure>


<p>OC里面对property的访问用消息发送和点操作符都行（点操作符会被转为消息发送，应该是在编译阶段），对非property的实例变量直接访问或者用->都行（无property则不会响应这一消息所以点操作符不行）。<br/>
2.this和self对应，用来在类成员函数（实例方法）内部访问当前对象。<br/>
3.OC里给nil发送任何消息都ok，C++里对NULL对象去调用函数会崩溃（nullObject->doSomething();）。</p>

<h3>9.References</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">changeValue</span><span class="p">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">foo</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">//注意这个声明方式</span>
</span><span class='line'><span class="n">foo</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">changeValue</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span> <span class="c1">//foo.x还是1，因为C++会做一个foo的拷贝作为参数并不是想的</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面是<code>传值</code>，<code>传址</code>和<code>传引用</code>都会真正改变foo.x，如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//传址</span>
</span><span class='line'><span class="kt">void</span> <span class="n">changeValue</span><span class="p">(</span><span class="n">Foo</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">foo</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//传引用。对上述例子直接加&amp;就好了</span>
</span><span class='line'><span class="kt">void</span> <span class="n">changeValue</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>10.Inheritance</h3>

<p>1.普通继承</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">@interface</span> <span class="nc">Person</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Employee</span> : <span class="nc">Person</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//public说明Person中所有public的成员变量在Employee仍然是public</span>
</span><span class='line'><span class="c1">//这块可以看看文章-http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Employee</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.多继承<br/>
OC也可以实现“多继承”，不过如下play和manage方法都必须实现，对C++只需要在base class中实现就行了，子类自动继承其实现。<br/>
当两个base class都实现了就要消除歧义；OC用协议的话PlayerManager必须自己去实现foo，就没有这个问题。<br/>
C++多继承</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Player</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">play</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Manager</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">manage</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PlayerManager</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Player</span><span class="p">,</span> <span class="k">public</span> <span class="n">Manager</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Player和Manager都有foo函数</span>
</span><span class='line'><span class="n">PlayerManager</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'><span class="n">p</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>          <span class="c1">///&lt; Error! Which foo?</span>
</span><span class='line'><span class="n">p</span><span class="p">.</span><span class="n">Player</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span>  <span class="c1">///&lt; Call foo from Player</span>
</span><span class='line'><span class="n">p</span><span class="p">.</span><span class="n">Manager</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span> <span class="c1">///&lt; Call foo from Manager</span>
</span></code></pre></td></tr></table></div></figure>


<p>OC多继承</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">@protocol</span> <span class="nc">Player</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">play</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@protocol</span> <span class="nc">Manager</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">manage</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Player</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Manager</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">Manager</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">PlayerManager</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">Player</span><span class="p">,</span> <span class="n">Manager</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>11.Polymorphism</h3>

<p>1.“运行时”的OC和“编译时”的C++的一个区别：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">value</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">5</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">value</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Bar</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>
</span><span class='line'><span class="n">Foo</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="n">i</span><span class="err">”</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
</span><span class='line'><span class="c1">// Output = 5</span>
</span></code></pre></td></tr></table></div></figure>


<p>在OC中，把一个子类转换成它的父类是OK的，因为当给对象发送消息时，运行时会去查询该对象所属的类，并调用该类对应的方法。在上例中，就会识别出f其实是一个指向Bar对象的指针，所以会调用Bar::value()然后输出10。
在C++中，编译器遇到value函数调用，然后发现f是一个指向Foo对象的指针，所以去找Foo::value()。<br/>
2.Static Binding and Dynamic Binding<br/>
静态绑定就是编译器在编译时即把哪个函数会被调用这些信息生成到了可执行文件里，所以运行的时候是不可能动态改变调用哪个方法。
动态绑定就是运行时在运行的时候负责决定哪个方法应该被调用，所以可以在运行的时候动态的给类添加方法或者动态改变方法的实现。<br/>
不过C++也可以实现动态绑定，需要借助<code>虚函数</code>。<br/>
3.Virtual Functions and the Virtual Table<br/>
借助虚函数得到“情理之中”的结果，不过增加了查表的开销，如果是静态绑定那么只有函数调用的开销：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">value</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">5</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">value</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Bar</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>
</span><span class='line'><span class="n">Foo</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="n">i</span><span class="err">”</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
</span><span class='line'><span class="c1">// Output = 10</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++中很多设计都很灵活，把一些决定留给开发者去做，所以说其是一个<code>多范式</code>的语言；OC强制开发者使用严格的模式，特别是当使用Cocoa框架时。</p>

<h3>12.The Inner Workings of Virtual Functions</h3>

<p>如果foo()函数不是虚函数，那么编译器产出的代码将会直接跳到对应类的foo函数处进行函数调用。<br/>
如果是虚函数，那么会去查<code>v-table</code>，每一个类有一个虚表。对于上例，虽然强制转换了对象，但对象本身的<code>内容不变</code>，所以<code>虚表也不变</code>，进而就能找到正确的函数了。</p>

<h3>13.Constructors and Destructors</h3>

<p>1.普通构造器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>文艺构造器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">()</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果除了初始化对象的内部状态之外还有别的初始化逻辑或者函数调用，那么可以上面两者混用，也就是在文艺构造器中进一步实现一下函数体。
2.当用到<code>继承</code>的时候往往需要调用父类的初始化器，如OC中<code>self = [super init];</code>，在C++11之前是不能这么做的，不过可以通通去调用父类对应的初始化器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">()</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Bar</span><span class="p">()</span> <span class="o">:</span> <span class="n">Foo</span><span class="p">(),</span> <span class="n">y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.OC中一般都有指定初始化器，C++中无对应机制。如果两个初始化器有共同的初始化逻辑，那么就将其提出作为函数然后调用，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Bar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">commonInit</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Perform common initialisation</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Bar</span><span class="p">()</span> <span class="o">:</span> <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">-&gt;</span><span class="n">commonInit</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">Foo</span><span class="p">(),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">-&gt;</span><span class="n">commonInit</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++11之后终于有了类似指定初始化器的设计，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Bar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Bar</span><span class="p">()</span> <span class="o">:</span> <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Perform common initialisation</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//如果想通过加上一个y(y)来同时初始化y，那么在Xcode中会出现错误</span>
</span><span class='line'>    <span class="c1">//An initializer for a delegating constructor must appear alone</span>
</span><span class='line'>    <span class="n">Bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">Bar</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>4.析构器不需要参数，所以只有一个析构函数。跟上面虚函数的例子一样，析构函数也存在调用问题，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Foo</span> <span class="n">destructor</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Bar</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Bar</span> <span class="n">destructor</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Bar</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>
</span><span class='line'><span class="n">Foo</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="k">delete</span> <span class="n">f</span><span class="p">;</span>
</span><span class='line'><span class="c1">// Output:</span>
</span><span class='line'><span class="c1">// Foo destructor</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么跟上面一样，把析构函数做成虚函数即可。但是会发现先调用了子类的析构函数，然后还调用了父类的，这是因为析构函数比较特殊，子类的析构函数运行完了会自动调用父类的，就跟OC在不用ARC时候在<code>dealloc</code>函数末尾需要<code>[super dealloc]</code>一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Foo</span> <span class="n">destructor</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Bar</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="o">~</span><span class="n">Bar</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Bar</span> <span class="n">destructor</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Bar</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>
</span><span class='line'><span class="n">Foo</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="k">delete</span> <span class="n">f</span><span class="p">;</span>
</span><span class='line'><span class="c1">// Output:</span>
</span><span class='line'><span class="c1">// Bar destructor</span>
</span><span class='line'><span class="c1">// Foo destructor</span>
</span></code></pre></td></tr></table></div></figure>


<p>那为什么编译器不直接把析构函数作为虚函数来编译？因为虚函数有个查虚表的操作，每次析构对象都会调用，所以只要不继承就用普通析构函数就行。</p>

<h3>14.Operator overloading</h3>

<p>1.一般的运算符操作其实就是函数调用，这是对标量进行运算，要实现对对象的运算，就要借助运算符重载。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">//可能内部实现是int y = add(x, 5);</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.运算符重载示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">DoubleInt</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">DoubleInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//operator+函数，必须有operator关键字，然后加一个运算符</span>
</span><span class='line'>    <span class="n">DoubleInt</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">DoubleInt</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">DoubleInt</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//跟int型相加</span>
</span><span class='line'>    <span class="n">DoubleInt</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">DoubleInt</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">DoubleInt</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">DoubleInt</span> <span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span><span class='line'><span class="n">DoubleInt</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//DoubleInt(4, 6)</span>
</span><span class='line'>
</span><span class='line'><span class="n">DoubleInt</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">DoubleInt</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//DoubleInt(11, 12)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>15.Templates</h3>

<p>使用模板有一点需要注意：如果多个类用到同一模板，那么一定要把<code>模板的实现</code>放在头文件。因为当编译器看到一个模板函数调用时会为调用类型编译出一个版本来，也就是说编译器需要知道模板函数的实现。因为编译器是一次只能处理一个编译单元, 也就是一次处理一个cpp文件,所以实例化时需要看到该模板的完整定义。这不同于普通的函数, 在使用普通的函数时，编译时只需看到该函数的声明即可编译, 而在链接时由链接器来确定该函数的实体。</p>

<p>扩展：C++标准中提到，一个编译单元<code>translation unit</code>是指一个.cpp文件以及它所include的所有.h文件，.h文件里的代码将会被扩展到包含它的.cpp文件里，然后编译器编译该.cpp文件为一个.obj文件，后者拥有PE[PortableExecutable,即Windows可执行文件]文件格式，并且本身包含的就已经是二进制码，但是，不一定能够执行，因为并不保证其中一定有main函数。当编译器将一个工程里的所有.cpp文件以分离的方式编译完毕后，再由连接器(linker)进行连接成为一个.exe文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">ix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="n">swap</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>16.Template Classes</h3>

<p>原本实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">IntTriplet</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">IntTriplet</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">getA</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">getB</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">getC</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>改为模板：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Triplet</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Triplet</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">T</span> <span class="n">getA</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">getB</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">getC</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>模板类的使用。要注意这里尖括号里给出了类型，而调用模板函数的话直接<code>swap(ix, iy);</code>，这是因为模板函数的参数使得编译器能推断出需要编译哪个类型的版本。而对于模板类，需要明确告诉编译器要让其编译的类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Triplet</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intTriplet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="n">Triplet</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">floatTriplet</span><span class="p">(</span><span class="mf">3.141</span><span class="p">,</span> <span class="mf">2.901</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">);</span>
</span><span class='line'><span class="n">Triplet</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">personTriplet</span><span class="p">(</span><span class="n">Person</span><span class="p">(</span><span class="err">“</span><span class="n">Matt</span><span class="err">”</span><span class="p">),</span> <span class="n">Person</span><span class="p">(</span><span class="err">“</span><span class="n">Ray</span><span class="err">”</span><span class="p">),</span> <span class="n">Person</span><span class="p">(</span><span class="err">“</span><span class="n">Bob</span><span class="err">”</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了三个同类型成员变量，也可以支持三个不同类型的</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">TA</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TB</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TC</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Triplet</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">TA</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="n">TB</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>    <span class="n">TC</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Triplet</span><span class="p">(</span><span class="n">TA</span> <span class="n">a</span><span class="p">,</span> <span class="n">TB</span> <span class="n">b</span><span class="p">,</span> <span class="n">TC</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">TA</span> <span class="n">getA</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">TB</span> <span class="n">getB</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">TC</span> <span class="n">getC</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//使用</span>
</span><span class='line'><span class="n">Triplet</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="p">,</span> <span class="n">Person</span><span class="o">&gt;</span> <span class="n">mixedTriplet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">3.141</span><span class="p">,</span> <span class="n">Person</span><span class="p">(</span><span class="err">“</span><span class="n">Matt</span><span class="err">”</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<h3>17.Standard Template Library (STL)</h3>

<p>1.Containers<br/>
C++里所有容器都是<code>mutable</code>的，没有OC里的<code>immutable</code>。<br/>
2.Vector相当于数组:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span> <span class="c1">//内部可能用模板实现</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="kt">int</span> <span class="n">outOfBounds</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">//会检查是否越界，越界了产生异常</span>
</span></code></pre></td></tr></table></div></figure>


<p>List是双向链表：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;list&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>
</span><span class='line'><span class="n">l</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">thisInt</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="c1">//这里的i++和*i其实都是运算符重载</span>
</span><span class='line'>    <span class="c1">// Do something with thisInt</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外还有对应OC中set的std::set，对应dictionary的std::map，还有std::pair等等。<br/>
3.Shared Pointers<br/>
C++11才引入的，实现<code>引用计数</code>。因为共享指针本身是存在栈上的，所以在离开一个作用域后会被销毁，这正是ARC所做的。引文：</p>

<blockquote><p>Since shared pointers are stack objects themselves, they will be destroyed when they go out of scope. Therefore they will behave in much the same way that pointers to objects do under ARC in Objective-C.</p></blockquote>

<p>示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">///&lt; Use count = 1</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">doSomething</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span> <span class="c1">///&lt; Use count = 2;</span>
</span><span class='line'>    <span class="c1">// Do something with p2</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// p2 has gone out of scope and destroyed, so use count = 1</span>
</span><span class='line'>
</span><span class='line'><span class="n">p1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// p1 reset, so use count = 0</span>
</span><span class='line'><span class="c1">// The underlying int* is deleted</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么说会超出作用域？因为当以传值形式传递函数参数时（应该不限于传参数，使用成员变量等也是在用参数，也会将其拷贝到栈），会拷贝一份给函数。所以当传递共享指针时，一个新的共享指针会产生并传给函数，这个新的拷贝就会增加共享指针的<code>Use Count</code>，而且在函数结束时会减1。</p>

<h3>18.Objective-C++</h3>

<p>把实现文件从.m改为.mm就是告诉编译器，在这个文件里要用Objective-C++。注意OC++和OC的类不可能相互继承。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// Forward declare so that everything works below</span>
</span><span class='line'><span class="k">@class</span> <span class="nc">ObjcClass</span>;
</span><span class='line'><span class="n">class</span> <span class="n">CppClass</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// C++ class with an Objective-C member variable</span>
</span><span class='line'><span class="n">class</span> <span class="n">CppClass</span> <span class="p">{</span>
</span><span class='line'>  <span class="nl">public:</span>
</span><span class='line'>    <span class="n">ObjcClass</span> <span class="o">*</span><span class="n">objcClass</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Objective-C class with a C++ object as a property</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">ObjcClass</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="c1">//必须用assign，因为不能retain或者release一个不是OC object的对象，assign只是保证内存管理语义正确并让property生成accessor</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CppClass</span><span class="o">&gt;</span> <span class="n">cppClass</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ObjcClass</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Using the two classes above</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CppClass</span><span class="o">&gt;</span> <span class="n">cppClass</span><span class="p">(</span><span class="n">new</span> <span class="n">CppClass</span><span class="p">());</span>
</span><span class='line'><span class="n">ObjcClass</span> <span class="o">*</span><span class="n">objcClass</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ObjcClass</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">cppClass</span><span class="o">-&gt;</span><span class="n">objcClass</span> <span class="o">=</span> <span class="n">objcClass</span><span class="p">;</span>
</span><span class='line'><span class="n">objcClass</span><span class="p">.</span><span class="n">cppClass</span> <span class="o">=</span> <span class="n">cppClass</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>OC所有的对象都要求在堆上，而C++的可以在堆可以在栈。一个栈对象作为一个OC类的property就有点奇怪，但实际上还是在堆上的，因为这个类的对象本身肯定在堆上。
为了支持这种<code>栈对象</code>，编译器给alloc和dealloc添加了construct和destruct <code>"stack" C++ objects</code>的方法，<code>.cxx_construct &amp; .cxx_destruct</code>。引文没太懂：</p>

<blockquote><p>Note: ARC actually piggybacks on .cxx_destruct; it now creates one of these for all Objective-C classes to write all the automatic cleanup code.</p></blockquote>

<p>另外还有一点需要注意，如下，如果另外一个类需要使用MyClass，那么要import MyClass.h，也就是引入了一个使用了C++的文件，因此引用了MyClass的文件也需要被当做OC++来编译，哪怕它本身并不是用C++。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// MyClass.h</span>
</span><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;list&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyClass</span> : <span class="nc">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">listOfIntegers</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// MyClass.mm</span>
</span><span class='line'><span class="cp">#import “MyClass.h”</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MyClass</span>
</span><span class='line'><span class="c1">// …</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>解决这个问题的办法是：在公开的头文件里尽量少的使用C++的东西，可以把私有property或者实例变量放在实现文件并在其中使用C++。以免所有import该类头文件的都被强制当做OC++来编译。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Practices & Tips]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c/"/>
    <updated>2014-04-23T19:19:22+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c</id>
    <content type="html"><![CDATA[<!--more-->


<h3>4.用block实现代理</h3>

<p>关于block的大致介绍，<a href="http://onevcat.com/2011/11/objective-c%E4%B8%AD%E7%9A%84block/">Objective-C中的Block</a>这篇博文写的挺好。其中提到的一点需要注意，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="mf">1.99</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">float</span> <span class="p">(</span><span class="o">^</span><span class="n">finalPrice</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//Price is accessible here</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">quantiy</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">orderQuantity</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="c1">//Ordering 10 units, final price is: $19.90</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Ordering %d units, final price is: $%2.2f&quot;</span><span class="p">,</span> <span class="n">orderQuantity</span><span class="p">,</span> <span class="n">finalPrice</span><span class="p">(</span><span class="n">orderQuantity</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="n">price</span> <span class="o">=</span> <span class="mf">.99</span><span class="p">;</span>
</span><span class='line'><span class="c1">//Ordering 10 units, final price is: $19.90</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Ordering %d units, final price is: $%2.2f&quot;</span><span class="p">,</span> <span class="n">orderQuantity</span><span class="p">,</span> <span class="n">finalPrice</span><span class="p">(</span><span class="n">orderQuantity</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>可以理解为在block内的price是readonly的，只在定义block时能够被赋值（补充说明，实际上是因为price是value type，block内的price是在申明block时复制了一份到block内，block外面的price无论怎么变化都和block内的price无关了。如果是reference type的话，外部的变化实际上是会影响block内的）。</p></blockquote>

<p>解决办法有两种：<br/>
1.将局部变量声明为__block，表示外部变化将会在block内进行同样操作;<br/>
2.使用实例变量。关于这点有引文：</p>

<blockquote><p>这个比较没什么好说的，实例内的变量横行于整个实例内..可谓霸道无敌…=_=
block外的对象和基本数据一样，也可以作为block的参数。而让人开心的是，block将自动retain传递进来的参数，而不需担心在block执行之前局部对象变量已经被释放的问题。这里就不深究这个问题了，只要严格遵循Apple的thread safe来写，block的内存管理并不存在问题。（更新，ARC的引入再次简化了这个问题，完全不用担心内存管理的问题了）</p></blockquote>

<p>这里有个问题就是：因为block会自动retain传进来的参数，所以会出现<a href="http://stackoverflow.com/questions/14556605/capturing-self-strongly-in-this-block-is-likely-to-lead-to-a-retain-cycle">capturing self strongly in this block is likely to lead to a retain cycle</a>的问题，即就是传进去<code>self.xxx</code>之后，会retain self，即构成了循环引用。解决办法是定义一个<code>__weak</code>的self然后在block中使用。</p>

<p><strong>回到正题，block代替protocol</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//In DRDHandWriting.h</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">didFinishWriting</span><span class="p">)(</span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">didFinishWriting</span> <span class="n">didFinishWritingBlock</span><span class="p">;</span><span class="c1">//注意这里是copy</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//In DRDHandWriting.m</span>
</span><span class='line'><span class="c1">//Submit charUnitArray to Document</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">didFinishWritingBlock</span><span class="p">(</span><span class="n">segmentedCharUnitArray</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//In DRDManuscriptController::loadHandWritingView</span>
</span><span class='line'><span class="n">handWritingView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">DRDHandWriting</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="n">handWritingRect</span><span class="p">];</span>
</span><span class='line'><span class="n">__weak</span> <span class="n">DRDManuscriptController</span> <span class="o">*</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="c1">//这里的参数只是被代理对象需要返回给代理的数据，具体就是手写视图需要返回切分好的字符给controller</span>
</span><span class='line'><span class="c1">//另一种情形就是多个AlertView的代理，这里就可以传回当前alertView</span>
</span><span class='line'><span class="p">[</span><span class="n">handWritingView</span> <span class="nl">setDidFinishWritingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">segmentedArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">weakSelf</span><span class="p">.</span><span class="n">document</span> <span class="nl">addOrInsertCharUnitArray:</span><span class="n">segmentedArray</span><span class="p">];</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于上例中block的copy，有<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">官方文档</a>：</p>

<blockquote><p>Note: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. For more information, see Blocks Programming Topics.</p></blockquote>

<p>block在创建的时候是分配在栈上的，如果<code>retain</code>（栈上的东西不能retain），在调用block的时候程序就会崩溃，实际上ARC下测试了一下retain，只是代码编辑阶段即给出警告<code>Retain'ed block property does not copy the block - use copy attribute instead</code>并且程序正常运行。而如果是<code>copy</code>，将会把这个block拷贝到堆里，同时retain这个block所引用的所有东西。block在堆上的时候进行copy就没事，不会再拷贝一遍，只是相当于retain。这段摘自<a href="http://blog.refractalize.org/post/10476042560/copy-vs-retain-for-objective-c-blocks">Copy vs retain for Objective-C blocks</a>。</p>

<p><strong>结论：</strong><br/>
自己实验了一下上面那个改变price输出总价不变的例子，block在创建的时候是分配在栈上的。<br/>
1.如果block里用到了局部变量，那么就会拷贝一份：比如<code>int a = 5</code>就会拷贝一个int变量其值为5；如果是<code>int *ptr = 5</code>就会拷贝ptr这个指针，这样改变*ptr的值，block里也会跟着变。<br/>
2.如果用到了实例变量，那么不管是value type还是指针型的，都不会出现外部更新而block内部没跟着变的情况，猜想是因为block引用实例变量其实就是对self指针的弱引用，用到实例变量时候用指针去读的。<br/>
3.上面<code>capturing self strongly in this block is likely to lead to a retain cycle</code>这一问题，是因为用到了实例变量。两种情况：如果是property那么隐含<code>self.propertyXXX</code>；如果是非property的实例变量，隐含<code>self-&gt;iVar</code>，都有self。因为是用block实现代理，那么需要传block给被代理对象，被代理对象copy block，同时运行时会copy block到堆上并retain block里所有的东西，这就相当于被代理对象里声明了一个<code>@property (strong, nonatomic) id&lt;XXXProtocol&gt; delegate</code>，所以就造成了循环引用。上面那个SO的链接讲得很清楚。<br/>
4.最后，什么时候用block什么时候用delegation，<a href="http://stablekernel.com/blog/blocks-or-delegation/">Blocks or Delegation</a>讲了，实在不想看了，先马克- -！</p>

<h3>3.Category也能Conform to a protocol</h3>

<h3>2.对集合中每个对象发送消息</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// remove all subviews</span>
</span><span class='line'><span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="n">subviews</span><span class="p">]</span> <span class="nl">makeObjectsPerformSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">removeFromSuperview</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>1.<a href="http://ironwolf.dangerousgames.com/blog/archives/913">The Code Commandments: Best Practices for Objective-C Coding </a></h3>

<p><strong>a.在实例变量前加<code>@private</code></strong>[放在类扩展就好]</p>

<ul>
<li>表明该变量与API无关</li>
<li>默认是<code>@protected</code>即就是子类可以访问，如果子类不需要那就不要暴露，面向对象的<code>信息隐藏</code>，（其实最好的应该是子类和其他类用到的在.h，私有变量和方法在类扩展）</li>
</ul>


<p><strong>b.为每一个<code>data member</code>创建<code>@property</code>，在.m中都用<code>self.name</code>来访问</strong>[这个有问题]</p>

<ul>
<li>property会把访问权限加入，如readonly</li>
<li>property会把内存管理加入，strong&amp;weak</li>
</ul>


<p><strong>c.<code>实例变量</code>就是只给当前类及其子类使用，<code>@property</code>就是外部类也能用</strong><br/>
之前看到在头文件里interface部分定义实例变量，同时又用@property重新写一遍。对于想要公开给这个类及其子类以外的类的实例变量，那么就为其写一个对应的property。<br/>
<strong>d.关于<code>readonly</code></strong>
就是说这个property在外界不能修改，如<code>self.document.displayHeight</code>会产生<code>assign to readonly property</code>。在类的实现文件里可以通过实例变量来修改，如<code>_displayHeight = 600</code>，此外，在实现文件还可以通过<code>self-&gt;_displayHeight = 600</code>来修改，这里之所以用->大概是因为类本身拥有这个实例变量就意味着类的实例有一个指向这个实例变量的指针，而property只是用于公开给外部，在这里没property什么事。
另外还可以在类扩展里告诉编译器我还需要一个setter，但只是在实现文件里：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//公有可读，私有可写</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">YourClass</span> <span class="p">()</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">eventDomain</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个问题在<a href="http://stackoverflow.com/questions/4586516/readonly-properties-in-objective-c">Readonly Properties in Objective-C?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Effective Objective-C 2.0』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0/"/>
    <updated>2014-04-07T13:22:29+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0</id>
    <content type="html"><![CDATA[<p>《Effective Objective-C 2.0：52 Specific Ways to Improve Your iOS and OS X Programs》 作者：<a href="http://www.galloway.me.uk/">Matt Galloway</a></p>

<!--more-->


<h2><strong>1: Accustoming Yourself to Objective-C</strong></h2>

<h3>Item 2: 缩减头文件&mdash;Minimize Importing Headers in Headers</h3>

<p>a.如下引文，试了一下互相import，没有报错- -！</p>

<blockquote><p>The use of #import rather than #include doesn&rsquo;t end in an infinite loop but does mean that one of ther classes won&rsquo;t compile correctly.</p></blockquote>

<p>b.协议相关<br/>
一些代理相关的协议，可以把协议头文件在.m文件里再引入，把代理<code>id&lt;XXXProtocol&gt; delegate</code>定义放在类扩展里。
也可以考虑单独创建一个头文件，里面只放协议定义。</p>

<!--more-->


<h3>Item 3: 使用字面量语法而不是其等价方法&mdash;Prefer Literal Syntax over the Equivalent Methods</h3>

<p>a.字面量使用</p>

<pre><code>NSString *str           = @"Test String";
NSNumber *boolValue     = @YES;
NSNumber *charValue     = @'a';
NSNumber *expressionVal = @(x * y);//int x &amp; float y

NSArray *animals        = @[@"cat", @"dog"];
NSString *dog           = animails[1];//下标直接访问

NSDictionary *person    = @{@"firstName" : @"Matt", @"age" : @28};
NSString *firstName     = person[@"firstName"];//key值直接访问value

//Assign value or replace
mutableArray[1] = @"dog";
mutableDictionary[@"lastName"] = @"Galloway";
</code></pre>

<p>b.好处<br/>
如果NSArray用3个object来初始化，第二个是nil，那么arrayWithObjects将会返回一个只包含object1的array，而字面量初始化会报错。<strong>“报错”比“少了个数”更安全。</strong>
对于NSDictonary，初始化会在遇到nil时候停止，dictionaryWithObjectsAndKeys可能会少了某一个value；字面量更安全。<br/>
c.缺点<br/>
字面量语法只能用于Foundation框架的一些类，对于自定义的类没法这样定义（显然）。<br/>
对于mutable对象的定义，需要进行mutableCopy。增加了额外的方法调用和对象创建</p>

<pre><code>NSMutableArray *mutable = [@[@1, @2, @3] mutableCopy];
</code></pre>

<h3>Item 4: 使用类型化常量而不是预处理指令#define&mdash;Prefer Typed Constants to Preprocessor #define</h3>

<p>a.#define的缺点<br/>
预处理指令<code>#define ANIMATION_DURATION 0.3</code>只是在预处理阶段进行<code>替换</code>，它没有包含类型信息。（如果定义在头文件，所有包含该头文件的文件也都会进行替换。）<br/>
b.类型化常量的使用（static const）<br/>
用上编译器让常量有类型信息：<code>static const NSTimerInterval kAnimationDuration = 0.3;</code>
常量命名规范：</p>

<blockquote><p>The usual convertion for constants is to prefix with lettr k for constants that are local to a translation unit(implementation file). For constants that are exposed outside of a class, it is usual to prefix with the class name.<br/>
在.m中定义，对于这个translation unit是局部变量的话用k作前缀；如果要暴露给外界，用类名开头，如EOCViewClassAnimationDuration。</p></blockquote>

<p><code>static</code>关键词说明这个变量对于当前translation unit是局部的，如果没定义为static，编译器将会为其创建一个external symbol，如果另一translation unit声明了一个同名变量，链接器将会报错；<code>const</code>关键词说明不能被修改。</p>

<blockquote><p>A translation unit is the input the compiler receives to generate one object file. In OC, this usually means that there is one translation unit per class: every .m file.</p></blockquote>

<p>SO的一个问题：<a href="http://stackoverflow.com/questions/11382502/how-different-static-variable-declarations-in-objective-c">How different static variable declarations in Objective-C?</a><br/>
c.类型化常量的使用（extern）<br/>
跟<code>NSNotification</code>相关，通知名应该这样处理：</p>

<pre><code>// In .h
// extern--"Trust me, there's a variable called EOCStringConstant declared in another file"
// EOC是类名
extern NSString *const EOCStringConstant;

// In .m
//反着读：EOCStringConstantis a const pointer point to NSString
NSString *const EOCStringConstant = @"NotificationName";
//如果不是对象那这里是const NSTimeInterval EOCAnimated...
</code></pre>

<p>d.总结<br/>
类型化常量有类型- -！
类型化常量借助编译器来确保常量的一致性（const），预处理指令#define可以在别的地方重定义。<br/>
.m的局部变量如动画时间等用k开头放在.m文件里用static；通知名等用类名+通知名，.m里声明+定义，.h里extern，如UIApplication类里声明+定义的UIApplicationDidEnterBackGroundNotifation。</p>

<h2><strong>2: Objects, Messaging, and the Runtime</strong></h2>

<h3>Item 6: 理解Properties-Understand Properties【需要再看】</h3>

<p>a.自己写了Accessor中的一个，编译器将会synthesize另一个，LazyLoading就是这样的。如果不想让编译器自动synthesize，可以用<code>@dynamitc</code>指令，这样编译器不会生成Accessor和对应的实例变量名，而且编译时候编译器会忽略Accessor还没有被定义但是已经在self.property，编译器会认为Accessor在runtime时会有的。<br/>
b.<code>weak</code>不会release旧值，也不会retain新值，类似assign，不过这个property所指对象被销毁时，这个property会被nilled out。<br/>
<code>unsafe_unretained</code>也和assign类似，只是关于object的assign，unretained对应nonowning，unsafe对应不会被nilled out，这一点和weak不一样。<br/>
<code>copy</code>对应mutable copy，如果不想让对象把传进来的值改变了，应该做一下copy，也就是immutable copy。虽然增加了拷贝操作，但是会更安全。<br/>
c.关于自定义getter名在BOOL上的应用，为了加is为什么不直接把property命名成isXxx。</p>

<h3>Item 7: Access Instance Variables Primarily Directly When Accessing Them Internally</h3>

<p><strong>a.总结</strong></p>

<ol>
<li>一般来说，要读实例变量的时候就直接访问，要写实例变量的时候就用property。</li>
<li>如果在初始化方法（或dealloc）中改变property的值，那么也是直接访问实例变量。因为如果初始化方法也用property，那么父类初始化时候其实会调用子类的初始化方法，可能会产生问题。另外，有时候是必须在初始化方法中使用setter的，比如当实例变量在父类中声明，那子类只能通过setter来访问。</li>
<li>如果property使用了<code>Lazy Loading</code>，那么需要使用getter来获取，不如可能获得空值。</li>
</ol>


<p><strong>b.<code>直接访问</code>和<code>使用property</code>的区别</strong></p>

<ol>
<li>直接访问无需<code>method dispatch</code>那么肯定更快；</li>
<li>直接使用实例变量会绕过property所设置的内存管理策略；</li>
<li>直接访问实例变量，KVO可能不会触发了；</li>
<li>使用property可以方便debug，知道谁在什么时候访问了某一实例变量。</li>
</ol>


<h3>Item 8: Understand Object Equality</h3>

<p>a.有的类实现了判断相等的方法，如NSString的<code>isEqualToString:</code>，这个比<code>isEqual:</code>，因为后者还需要查看所比较对象所属的类。</p>

<h1>看不下去了</h1>

<h3>Item 10: 在既有类中适用关联对象存放自定义数据-Use Associated Objects to Attach Custom Data to Existing Classed</h3>

<p>a.一般都是通过<code>继承</code>来给既有类添加数据，但行不通的时候就要用到<code>关联对象</code>了。以UIAlertView为例：</p>

<ul>
<li>一般的实现中buttonIndex和其action的对应，即button的定义和其响应方法的声明不在一个地方，这样可读性不好；</li>
<li>如果同一个类里有多个alertView，那么在代理方法中还要判断是哪一个，然后再判断buttonIndex；</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">EOCMyAlertViewKey</span> <span class="o">=</span> <span class="s">&quot;EOCMyAlertViewKey&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">askUserAQuestion</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIAlertView</span> <span class="o">*</span><span class="n">alert</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAlertView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTitle:</span><span class="s">@&quot;Question&quot;</span>
</span><span class='line'>                                                    <span class="nl">message:</span><span class="s">@&quot;What do you want to do?&quot;</span>
</span><span class='line'>                                                   <span class="nl">delegate:</span><span class="n">self</span>
</span><span class='line'>                                          <span class="nl">cancelButtonTitle:</span><span class="s">@&quot;Cancel&quot;</span>
</span><span class='line'>                                          <span class="nl">otherButtonTitles:</span><span class="s">@&quot;Continue&quot;</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="n">NSInteger</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSInteger</span> <span class="n">buttonIndex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">buttonIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span> <span class="n">doCancel</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span> <span class="n">doContinue</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">alert</span><span class="p">,</span> <span class="n">EOCMyAlertViewKey</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_COPY</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">alert</span> <span class="n">show</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// UIAlertViewDelegate protocol method</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">alertView:</span><span class="p">(</span><span class="n">UIAlertView</span> <span class="o">*</span><span class="p">)</span><span class="nv">alertView</span> <span class="nf">clickedButtonAtIndex:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">buttonIndex</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)(</span><span class="n">NSInteger</span><span class="p">)</span> <span class="o">=</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">alertView</span><span class="p">,</span> <span class="n">EOCMyAlertViewKey</span><span class="p">);</span>
</span><span class='line'>    <span class="n">block</span><span class="p">(</span><span class="n">buttonIndex</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>b.总结<br/>
关联对象就是把两个object链接在一起了；关联对象只有在其他方法都不可行的时候才使用，因为很容易造成<code>Retain Cycle</code>；上例中还可以通过继承AlertView并附加这个block对象来实现，如果类中alertView要多次用到，更建议继承而不是关联对象。</p>

<h3>Item 14: 理解类的对象- Understand What a Class Object Is</h3>

<p>a.OC是<code>动态类型</code>的，对象的类型并不是在编译时候进行绑定的，而是在运行时进行查找。</p>

<h2><strong>4: Protocols and Categories</strong></h2>

<h3>Item 23: 通过委托和数据源协议进行对象间通信</h3>

<p>a.有一句话没太懂，这个单词居然查不出来，完了看看Item6，里面有这个单词(尼玛，就是自动设置空的意思，对应weak)：</p>

<blockquote><p>A delegate property will always be defined using either the weak attribute to benefit from <code>autonilling</code> or unsafe_unretained if autonilling is not required.</p></blockquote>

<p>b.在interface中声明遵守协议的话，别的类会知道这一行为，一般把“遵守协议”放在类扩展部分，虽然没太多影响。要知道一个对象是否遵守某个协议可以这样：<code>[self conformsToProtocol:@protocol(DRDHandWritingProtocol)]</code><br/>
c.可以把正在代理的对象也传回给代理，这样方便判断具体是哪个代理对象在调用代理方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">networkFetcher:</span><span class="p">(</span><span class="n">EOCNetworkFetcher</span> <span class="o">*</span><span class="p">)</span><span class="nv">fetcher</span> <span class="nf">didReceiveData:</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">fetcher</span> <span class="o">==</span> <span class="n">_myFetcherA</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//Handle data</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fetcher</span> <span class="o">==</span> <span class="n">_myFetcherB</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//Handle data</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>d.如果开发API，用代理可以实现一些属性设置，如<code>- (BOOL)networkFetcher:(EOCNetworkFetcher *)fetcher shouldFollowRedirectToURL:(NSURL *)url;</code>，甚至这里可以给fetcher传递一个NSDictionary来进行Fetcher一系列属性的设置。<br/>
e.对<code>@optional</code>的代理方法，方法调用者负责通过<code>[delegate respondsToSelector]</code>确保程序不会崩溃，unrecognized selector。<code>@required</code>的话编译器会确认。如果没设置，默认都是required。<br/>
f.对dataSource类的delegate，在获取每一个小的data piece的时候都查询一次respondsToSelector是低效的，应该将当前对象对协议的遵守情况缓存下来。如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//有个DataModel或者ViewController是该对象的代理</span>
</span><span class='line'><span class="c1">//In class extension</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">EOCNetworkFetcher</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">didReceiveData</span>      <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">didFailWithError</span>    <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">didUpdateProgressTO</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="n">_delegateFlags</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//In delegate Setter</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setDelegate:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">EOCNetworkFetcher</span><span class="o">&gt;</span><span class="p">)</span><span class="n">delegate</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_delegate</span> <span class="o">=</span> <span class="n">delegate</span><span class="p">;</span>
</span><span class='line'>    <span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didReceiveData</span> <span class="o">=</span> <span class="p">[</span><span class="n">delegate</span> <span class="nl">respondsToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkFetcher:didReceiveData:</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Query if responds to selector (FRENQUENTLY)</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">_delegateFlags</span><span class="p">.</span><span class="n">didReceiveData</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">_delegate</span> <span class="nl">networkFetcher:</span><span class="n">self</span> <span class="nl">didReceiveData:</span><span class="n">dataReceived</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>g.协议的“继承”</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">@protocol</span> <span class="nc">A</span>
</span><span class='line'>    <span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">methodA</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@protocol</span> <span class="nc">B</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">methodB</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress & Alfred Workflow]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/02/use-alfred-with-octopress/"/>
    <updated>2014-04-02T15:54:07+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/02/use-alfred-with-octopress</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.alfredapp.com/">Alfred</a>真是神器！</strong>自己做了两个workflow来简化Octopress发表博文和修改博文的流程，实现的很简单。</p>

<!--more-->


<p><code>发博文</code>用的是：Templates-Essentials-Keyword to Terminal Command。新建并用xcode打开空的博文后终端会运行<code>rake preview</code>，这样就直接进入编辑并预览状态。命令是<code>pb（post blog）</code><br/>
<img src="http://daryl5.github.io/blogimage/2014/pb.png" alt="pb" /></p>

<p><code>修改博文</code>用的是：Templates-Files and Apps-File filter from keyword and open。根据关键词显示相关文件，回车用xcode打开，打开终端运行<code>rake preview</code>。命令是<code>mb（modify blog）</code></p>

<p><img src="http://daryl5.github.io/blogimage/2014/mb.png" alt="mb" /><br></p>

<h2>下载</h2>

<p>可以戳<a href="http://daryl5.github.io/blogfile/2014/%E5%BD%92%E6%A1%A3.zip">这里</a>下载然后根据自己的需求修改。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIDocument的使用]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument/"/>
    <updated>2014-04-01T21:42:32+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument</id>
    <content type="html"><![CDATA[<p>读<a href="https://github.com/sprang/Inkpad">Inkpad</a>源码时看到使用了<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIDocument_Class/UIDocument/UIDocument.html#//apple_ref/c/tdef/UIDocumentState">UIDocument</a>，然后搜到了Ray Wenderlich的博文：<a href="http://www.raywenderlich.com/12779/icloud-and-uidocument-beyond-the-basics-part-1">iCloud and UIDocument: Beyond the Basics</a>，整理了一下大致用法。</p>

<!--more-->


<h3>1. 继承UIDocument并重写方法</h3>

<p>需要重写<code>loadFromContents:ofType:error</code>方法来读，重写<code>contentsForType:error</code>方法来写。</p>

<h3>2. 输入输出格式</h3>

<p>UIDocument支持两种类，<code>NSData</code>适用于文档只是一个单一文档，<code>NSFileWrapper</code>相当于文件夹，适用于文档包含多个想要单独加载的文件，比如矢量图绘制App要显示一个缩略图，这个需要单独提前加载。FileWrapper内部是Key-Value形式的存储，文件名是key，文件存在本地的archive内容（或是archive文件名）是value，所以会有：</p>

<!--more-->


<pre><code>//从文件名（如xxxx.title，不是xxxx.note）得到FileWrapper
NSFileWrapper *fileWrapper = [self.fileWrapper.fileWrappers objectForKey:preferredFilename];

//从FileWrapper得到文件内容
NSData *data = [fileWrapper regularFileContents];
NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
</code></pre>

<h3>3. iCloud</h3>

<p>Apple规定，应用的所有documents要么在沙盒，要么在iCloud本地文件夹，用户不能选择某一文件来让其单独的存储在iCloud。</p>

<blockquote><p>All documents of an application are stored either in the local sandbox or in an iCloud container directory. A user should not be able to select individual documents for storage in iCloud.</p></blockquote>

<!--more-->


<h3>4. 关于undo/redo</h3>

<p>UIDocument有undo/redo支持，访问器是注册undo动作最合适的地方，所以document类里，对需要添加undo/redo功能的数据要重写访问器。对不需要undo/redo功能的数据，直接给document用property添加一个model就好。</p>

<h3>5. 整体的实现结构</h3>

<p>以记事本为例，title和content两个model，其中都只包含一个NSString。主视图直接在title，detailViewController再加载content。</p>

<blockquote><p><code>TitleModel</code>和<code>ContentModel</code>都实现<code>NSCoding</code>协议方法，这里可以考虑把<code>VersionNumber</code>encode进去以便后期支持文件格式扩展。
<strong>NoteDocument.h</strong></p>

<blockquote><p><code>@property (nonatomic, strong) TitleModel *titleModel;
//这里对ContentModel中的内容实现访问器，原因第4条有，方便undo/redo</code>
<code>- (NSString *)contentString;</code><br/>
<code>- (void)setContentString:(NSString *)str;</code></p></blockquote>

<p><strong>NoteDocument.m</strong></p>

<blockquote><ul>
<li>类扩展里定义<code>contentModel</code>和<code>fileWrapper</code>(读文件时候用)，<code>titleModel</code>直接放在头文件是因为It’s OK if the user accesses the metadata directly though, as it’s not something the app will modify. Instead, the metadata will be automatically updated when the user sets the photo.</li>
<li>重写<code>loadFromContents</code>和<code>contentsForType</code>，loadFromContents里面self.wrapper = (NSFileWrapper *)contents;给wrapper赋值，contentsForType里面把两个model encode进wrapper</li>
<li>重写<code>titleModel</code>和<code>contentModel</code>两个getter实现Lazy Loading，需要的时候再decode；如果文件不存在则把model初始化为nil</li>
<li>实现ContentModel的content的Accessor来实现undo/redo，在Setter里面执行如下代码块：</li>
</ul>
</blockquote></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">contentModel</span><span class="p">.</span><span class="n">content</span> <span class="nl">isEqual:</span><span class="n">str</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">oldContent</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">contentModel</span><span class="p">.</span><span class="n">content</span><span class="p">;</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">contentModel</span><span class="p">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">undoManager</span> <span class="nl">setActionName:</span><span class="s">@&quot;Content Change&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">undoManager</span> <span class="nl">registerUndoWithTarget:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">setContentString:</span><span class="p">)</span> <span class="nl">object:</span><span class="n">oldContent</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>其他</h2>

<h3>1. 设备旋转支持</h3>

<p>好多大厂的App居然也能支持反过来操作，真是不可理解。代码摘自引用博文实现的工程。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">shouldAutorotateToInterfaceOrientation:</span><span class="p">(</span><span class="n">UIInterfaceOrientation</span><span class="p">)</span><span class="nv">interfaceOrientation</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">interfaceOrientation</span> <span class="o">!=</span> <span class="n">UIInterfaceOrientationPortraitUpsideDown</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2. Undo/Redo</h3>

<p><a href="http://blog.163.com/chenchen..1986/blog/static/760631462013222314817/">这里</a>的例子简单有效。</p>

<h3>3. 自己画的大致思路，实际实现没这么做。</h3>

<p><img src="http://daryl5.github.io/blogimage/2014/useuidocument.jpg" alt="useuidocument" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读开源项目总结]]></title>
    <link href="http://daryl5.github.io/blog/2014/03/30/reading-source-code/"/>
    <updated>2014-03-30T19:55:11+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/03/30/reading-source-code</id>
    <content type="html"><![CDATA[<!--more-->


<h1><a href="https://github.com/liaojinxing/Voice2Note">懒人笔记</a>是一个很适合新手学习的项目，调用了讯飞语音识别库、友盟App统计和微信的分享库。功能很简单，实现的也很干净明晰。</h1>

<h3>1.隐藏键盘</h3>

<p>写新笔记界面有一个UITextField和一个UITextView，为了区分让哪一个resignFirstResponder，原作者添加了一个BOOL类型的_isEditingTitle，实际上用下面的代码即可保证界面上全部可能用到键盘的控件全部都resign了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">sendAction:</span><span class="k">@selector</span><span class="p">(</span><span class="n">resignFirstResponder</span><span class="p">)</span> <span class="nl">to:</span><span class="nb">nil</span> <span class="nl">from:</span><span class="nb">nil</span> <span class="nl">forEvent:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>其原理是<code>响应者链</code>，具体可以看<a href="http://www.cocoanetics.com/2012/09/the-amazing-responder-chain/">The Amazing Responder Chain</a>。</p>

<h3>2.根据cell的文本内容来获取cell的高度</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">heightWithString:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">string</span> <span class="nf">width:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">width</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">attributes</span> <span class="o">=</span> <span class="err">@</span><span class="p">{</span> <span class="nl">NSFontAttributeName:</span> <span class="p">[</span><span class="n">UIFont</span> <span class="nl">boldSystemFontOfSize:</span><span class="mi">17</span><span class="p">]</span> <span class="p">};</span>
</span><span class='line'>    <span class="n">CGSize</span> <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="n">string</span> <span class="nl">boundingRectWithSize:</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">kMaxTitleHeight</span><span class="p">)</span>
</span><span class='line'>                        <span class="nl">options:</span><span class="n">NSStringDrawingUsesLineFragmentOrigin</span>
</span><span class='line'>                        <span class="nl">attributes:</span><span class="n">attributes</span>
</span><span class='line'>                        <span class="nl">context:</span><span class="nb">nil</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ceilf</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1><a href="https://github.com/dasdom/DDHTimerControl">DDHTimerControl</a>是一个倒计时控件，做的很好看。</h1>

<h3>1.关于loadView和viewDidLoad</h3>

<p><a href="http://www.dreamingwish.com/frontui/article/default/correct-online-information-error-loadview-viewdidload-viewdidunload.html">这里</a>说的很清楚。</p>

<blockquote><p>loadView方法的默认实现是这样：先寻找有关可用的nib文件的信息，根据这个信息来加载nib文件，如果没有有关nib文件的信息，默认实现会创建一个空白的UIView对象，然后让这个对象成为controller的主view。 <br/>
所以，重载这个函数时，你也应该这么做。并把子类的view赋给view属性(property)（你create的view必须是唯一的实例，并且不被其他任何controller共享），而且你重载的这个函数不应该调用super。
如果你要进行进一步初始化你的views，你应该在viewDidLoad函数中去做。在iOS 3.0以及更高版本中，你应该重载viewDidUnload函数来释放任何对view的引用或者它里面的内容（子view等等）。</p></blockquote>

<h3>2.一个关于Setter的好的习惯</h3>

<p>自己重写了一个property的setter，然后别的地方有调用setXxx，那么最好在头文件中也声明一下setter，虽然不声明也没错，但是嘛。。。</p>

<h3>3.instancetype</h3>

<p><a href="http://blog.eddie.com.tw/2013/12/16/id-and-instancetype/">这里</a>说的很清楚。</p>

<blockquote><p>其實 instancetype 就只是個關鍵字(keyword)，它告訴編譯器回傳型態，讓編譯器可以在編譯階段就有足夠的資訊可以來判斷你寫的程式碼是不是有問題。只能用作返回值，id却可以随便用。</p></blockquote>

<p>具体例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">@interface</span> <span class="nc">Animal</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">createAnimal</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Animal</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">createAnimal</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">return</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Fox</span> : <span class="nc">Animal</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">say</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Fox</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">say</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;what does the fox say!?&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//编译能过，因为createAnimal回传类型是id，编译器不能在编译阶段infer出它的真实类型，</span>
</span><span class='line'><span class="c1">//所以只好先放过，然后在运行时候就会unrecognized selector sent to instance。</span>
</span><span class='line'><span class="c1">//可以通过respondToSelector来检查，更简单的方法是createAnimal返回instancetype</span>
</span><span class='line'><span class="p">[[</span><span class="n">Animal</span> <span class="n">createAnimal</span><span class="p">]</span> <span class="n">say</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.在类扩展里的<code>实例变量</code>和<code>property</code></h3>

<p>以往总是会写花括号然后写实例变量，用property一样实现“私有”，其好处有以下：</p>

<ol>
<li>可以重写getter，实现lazyloading</li>
<li>property对于实例变量可以设定权限</li>
</ol>


<h1><a href="https://github.com/sprang/Inkpad">Inkpad</a>是一个开源的基于OpenGLES的画矢量图的App。</h1>

<h3>0. 内联函数的使用</h3>

<p>内联函数只是给编译器的提示，最终能不能内联还要看编译器。</p>

<h4>(1)相同点</h4>

<p><code>static inline double radians (double degrees) { return degrees * M_PI/180; }</code>；都是在与处理阶段对代码块进行替换。</p>

<h4>(2)不同点</h4>

<p>内联函数是值传递，宏定义是简单替换。内联函数有类型检查，此外<code>省去了很多函数调用汇编代码如：call和ret等</code>。<br/>
<code>#define MAX(a, b) a&gt;b?a:b</code>如果<code>MAX( num1, num2 )</code>就没问题，但是如果是<code>MAX( 17+32, 25+21)</code>，展开后是<code>17+32&gt;25+21?17+32:25+21</code>。甚至<code>#define A 2+3</code>，然后<code>c = 4 * A</code>都会成为<code>4 * 2 + 3</code>。比较安全的写法是<code>#define MAX( (a), (b) ) (a)&gt;(b)?(a)b)</code>，但是这样还是有问题，<code>MAX(i++,j++)</code>完了每个都会加2了。
宏定义执行快是因为没有<code>函数调用</code>的开销，但是如果宏用的多文件就会变很大，执行文件太大可能导致执行时换页频繁（略夸张）。</p>

<h3>1. 一些简洁的写法</h3>

<ul>
<li><p><code>CGRectGetWidth</code>，以前总是写成<code>self.frame.size.width</code>。此外还有<code>CGRectGetMidX</code>，直接得到矩形中心点的X坐标。</p>

<pre><code>  CGPointMake(CGRectGetWidth(frame) / 2, CGRectGetHeight(frame) / 2);
</code></pre></li>
<li><p><code>[NSDictionary objectForKey]</code>，可以直接<code>dictionary[key]</code>。</p></li>
<li><p><code>BOOL isolate</code>转NSString，<code>@(isolate)</code>。NSArray的类似写法：</p>

<pre><code>  NSArray *items = @[actionItem_, gearItem_, albumItem_, zoomToFitItem_];
</code></pre></li>
</ul>


<h3>2. Best Practice</h3>

<h4>(1) “帮助”、“关于”视图</h4>

<p>应用的<strong><code>帮助</code></strong>, <strong><code>关于</code></strong>等信息可以做成html页面。建立本地文件夹，在其中放置html、图片、css等，然后直接<code>self.view = webview;</code>即可。</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span> <span class="nf">helpURL</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">resource</span> <span class="o">=</span> <span class="n">NSLocalizedString</span><span class="p">(</span><span class="s">@&quot;index&quot;</span><span class="p">,</span> <span class="s">@&quot;Name of Help html file&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="nl">pathForResource:</span><span class="n">resource</span> <span class="nl">ofType:</span><span class="s">@&quot;html&quot;</span> <span class="nl">inDirectory:</span><span class="s">@&quot;Help&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">fileURLWithPath:</span><span class="n">path</span> <span class="nl">isDirectory:</span><span class="n">NO</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">loadView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">UIWebView</span> <span class="o">*</span><span class="n">webView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIWebView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="p">[[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">bounds</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">webView</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="o">=</span> <span class="n">UIViewAutoresizingFlexibleWidth</span> <span class="o">|</span> <span class="n">UIViewAutoresizingFlexibleHeight</span><span class="p">;</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="o">=</span> <span class="n">webView</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">webView</span> <span class="nl">loadRequest:</span><span class="p">[</span><span class="n">NSURLRequest</span> <span class="nl">requestWithURL:</span><span class="p">[</span><span class="n">self</span> <span class="n">helpURL</span><span class="p">]]];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>(2) 应用“设置”功能</h4>

<p>以“显示网格”这一设置项为例，通过<code>UILable  UISwitch</code>来实现。其实可以全部通过NSUserDefaults实现，但inkpad中有个NSMutableDictionary的settings_作为”中间变量“:</p>

<ul>
<li>可能是考虑到在初始化时一次读取NSUserDefaults而不是需要属性就去查NSUserDefaults更好;</li>
<li>还有个原因就是每个drawing都会把settings_当做Document的一部分进行存储，NSMutableDictionary才能去存储。</li>
</ul>


<p>在<code>WDDrawingController</code>中有<code>WDPropertyManager</code>。除了下面的示例代码，很多属性的管理都在这里，<strong>区别是</strong>settings_只管理<code>设置</code>视图里能改变的属性，并且其值会被存储到document里，跟单独drawing相关；<del>而propertyManager管理<code>应用状态</code>，比如不选路径的时候“路径”的popover tableView里就全部不可用，如添加锚点、合并路径。</del></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// constantly updating the user defaults kills responsiveness after the keyboard has been made visible</span>
</span><span class='line'><span class="c1">// so use this temporary dictionary to avoid hitting the defaults all the time  </span>
</span><span class='line'><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">defaults_</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span><span class="c1">//in init</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//- (void) didEnterBackground:(NSNotification *)aNotification</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">updateUserDefaults</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="k">in</span> <span class="p">[</span><span class="n">defaults_</span> <span class="n">allKeys</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">setObject:</span><span class="n">defaults_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="nl">forKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>相关代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//属性设置-在“设置”界面控件响应方法中</span>
</span><span class='line'><span class="c1">//WDSettingsController</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">takeShowGridFrom:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">UISwitch</span>    <span class="o">*</span><span class="n">mySwitch</span> <span class="o">=</span> <span class="p">(</span><span class="n">UISwitch</span> <span class="o">*</span><span class="p">)</span><span class="n">sender</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">setBool:</span><span class="n">mySwitch</span><span class="p">.</span><span class="n">isOn</span> <span class="nl">forKey:</span><span class="n">WDShowGrid</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="n">synchronize</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawing_</span><span class="p">.</span><span class="n">showGrid</span> <span class="o">=</span> <span class="n">mySwitch</span><span class="p">.</span><span class="n">isOn</span><span class="p">;</span><span class="c1">//Setter方法</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性管理的中间类-在Accessor中设置和应用，发送通知最终应用设置</span>
</span><span class='line'><span class="c1">//WDDrawing:NSObject</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">setShowGrid:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">showGrid</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">settings_</span><span class="p">[</span><span class="n">WDShowGrid</span><span class="p">]</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">showGrid</span><span class="p">);</span><span class="c1">//settings_是NSMutableDictionary，WDShowGrid是NSString “WDShowGrid”</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">postNotificationName:</span><span class="n">WDDrawingChangedNotification</span> <span class="nl">object:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// this isn&#39;t an undoable action so it does not dirty the document</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">document</span> <span class="n">markChanged</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span> <span class="nf">showGrid</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">settings_</span><span class="p">[</span><span class="n">WDShowGrid</span><span class="p">]</span> <span class="n">boolValue</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性改变的即时应用-接收通知并通过setNeedsDisplay处发drawRect重绘</span>
</span><span class='line'><span class="c1">//WDCanvas</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">invalidateFromNotification:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">aNotification</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSValue</span>     <span class="o">*</span><span class="n">rectValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">aNotification</span> <span class="n">userInfo</span><span class="p">][</span><span class="s">@&quot;rect&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSArray</span>     <span class="o">*</span><span class="n">rects</span> <span class="o">=</span> <span class="p">[</span><span class="n">aNotification</span> <span class="n">userInfo</span><span class="p">][</span><span class="s">@&quot;rects&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGRect</span>      <span class="n">dirtyRect</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">float</span>       <span class="n">fudge</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">)</span> <span class="o">/</span> <span class="n">viewScale_</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">rectValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//...</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rects</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//...</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//没有任何userInfo，对应showGrid这一属性的改变</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">drawing_</span><span class="p">.</span><span class="n">showGrid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">drawingIsolatedLayer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="nl">drawGrid:</span><span class="n">ctx</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性的保存-主要在WDSettingsController，设置并同步</span>
</span><span class='line'><span class="err">借助</span><span class="n">NSUserDefaults</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性的加载-各种init方法中从NSUserDefaults初始化settings_</span>
</span><span class='line'><span class="c1">//WDDrawing</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nl">initWithSize:</span><span class="p">(</span><span class="n">CGSize</span><span class="p">)</span><span class="n">size</span> <span class="nl">andUnits:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">units</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// each drawing saves its own settings, but when a user alters them they become the default settings for new documents</span>
</span><span class='line'>    <span class="c1">// since this is a new document, look up the values in the defaults...</span>
</span><span class='line'>    <span class="n">NSUserDefaults</span> <span class="o">*</span><span class="n">defaults</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSArray</span> <span class="o">*</span><span class="n">keyArray</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">WDShowGrid</span><span class="p">,</span> <span class="n">WDSnapToGrid</span><span class="p">,</span> <span class="n">WDSnapToPoints</span><span class="p">,</span> <span class="n">WDSnapToEdges</span><span class="p">,</span> <span class="n">WDDynamicGuides</span><span class="p">,</span> <span class="n">WDRulersVisible</span><span class="p">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="k">in</span> <span class="n">keyArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">settings_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="err">@</span><span class="p">([</span><span class="n">defaults</span> <span class="nl">boolForKey:</span><span class="n">key</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. <code>NSNotification</code>的名字应该在哪定义</h3>

<p>在<code>WDToolManager.m</code>中，<code>NSString *WDActiveToolDidChange = @"WDActiveToolDidChange";</code>，然后在头文件中<code>extern NSString *WDActiveToolDidChange;</code>。一般来说关心这个通知（当前工具改变）的类都引用了这个类的头文件，这样比放在一个<code>ConstantsDefine.h</code>里要好。</p>

<h3>4.枚举定义中为什么要用左移</h3>

<p>这里解释的很详细<a href="http://stackoverflow.com/questions/3999922/why-use-the-bitwise-shift-operator-for-values-in-a-c-enum-definition">Why use the Bitwise-Shift operator for values in a C enum definition?</a>。如果用</p>

<pre><code>typedef enum { WDToolDefault, WDToolShiftKey, WDToolOptionKey }  
</code></pre>

<p>那么<code>WDToolDefault | WDToolShiftKey</code>就是<code>1 | 2</code>会得到3！！用左移就不会有这个问题，就是<strong><em>可以在一个变量中支持多个枚举值</em></strong>（将其相加或者取或），判断的时候取与。</p>

<pre><code>typedef enum {
    WDToolDefault           = 0,
    WDToolShiftKey          = 1 &lt;&lt; 0,
    WDToolOptionKey         = 1 &lt;&lt; 1,
    WDToolControlKey        = 1 &lt;&lt; 2,
    WDToolSecondaryTouch    = 1 &lt;&lt; 3
} WDToolFlags;  
</code></pre>

<h3>5. 子类不能重写touchesBegan但要在其发生同时完成处理</h3>

<p><code>FingerTackerView</code>重写<code>touchesBegan</code>等等方法，然后在其内部进行一些操作后调用<code>[self methodForSubclassOverwritten]</code>，这个方法可以置空。<code>HandWritingView</code>，<code>GestureEditorView</code>等继承自<code>FingerTrackerView</code>的类里重写<code>[self methodForSubclassOverwritten]</code>，这样就能在采集点的同时，对点的处理根据当前选择功能（即所处的视图）来由对应的子类来处理。子类不会出现<code>touchesBegan</code>等，但是可以通过重写方法来实现手势运动时处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读Inkpad源代码]]></title>
    <link href="http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code/"/>
    <updated>2014-03-30T19:55:11+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/sprang/Inkpad">Inkpad</a>是一个开源的基于OpenGLES的画矢量图的App，这篇博文记录阅读其源代码时的收获。</p>

<!--more-->


<h3>0. 内联函数的使用</h3>

<p>内联函数只是给编译器的提示，最终能不能内联还要看编译器。</p>

<h4>(1)相同点</h4>

<p><code>static inline double radians (double degrees) { return degrees * M_PI/180; }</code>；都是在与处理阶段对代码块进行替换。</p>

<h4>(2)不同点</h4>

<p>内联函数是值传递，宏定义是简单替换。内联函数有类型检查，此外<code>省去了很多函数调用汇编代码如：call和ret等</code>。<br/>
<code>#define MAX(a, b) a&gt;b?a:b</code>如果<code>MAX( num1, num2 )</code>就没问题，但是如果是<code>MAX( 17+32, 25+21)</code>，展开后是<code>17+32&gt;25+21?17+32:25+21</code>。甚至<code>#define A 2+3</code>，然后<code>c = 4 * A</code>都会成为<code>4 * 2 + 3</code>。比较安全的写法是<code>#define MAX( (a), (b) ) (a)&gt;(b)?(a)b)</code>，但是这样还是有问题，<code>MAX(i++,j++)</code>完了每个都会加2了。
宏定义执行快是因为没有<code>函数调用</code>的开销，但是如果宏用的多文件就会变很大，执行文件太大可能导致执行时换页频繁（略夸张）。</p>

<h3>1. 一些简洁的写法</h3>

<ul>
<li><p><code>CGRectGetWidth</code>，以前总是写成<code>self.frame.size.width</code>。此外还有<code>CGRectGetMidX</code>，直接得到矩形中心点的X坐标。</p>

<pre><code>  CGPointMake(CGRectGetWidth(frame) / 2, CGRectGetHeight(frame) / 2);
</code></pre></li>
<li><p><code>[NSDictionary objectForKey]</code>，可以直接<code>dictionary[key]</code>。</p></li>
<li><p><code>BOOL isolate</code>转NSString，<code>@(isolate)</code>。NSArray的类似写法：</p>

<pre><code>  NSArray *items = @[actionItem_, gearItem_, albumItem_, zoomToFitItem_];
</code></pre></li>
</ul>


<h3>2. Best Practice</h3>

<h4>(1) “帮助”、“关于”视图</h4>

<p>应用的<strong><code>帮助</code></strong>, <strong><code>关于</code></strong>等信息可以做成html页面。建立本地文件夹，在其中放置html、图片、css等，然后直接<code>self.view = webview;</code>即可。</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span> <span class="nf">helpURL</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">resource</span> <span class="o">=</span> <span class="n">NSLocalizedString</span><span class="p">(</span><span class="s">@&quot;index&quot;</span><span class="p">,</span> <span class="s">@&quot;Name of Help html file&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="nl">pathForResource:</span><span class="n">resource</span> <span class="nl">ofType:</span><span class="s">@&quot;html&quot;</span> <span class="nl">inDirectory:</span><span class="s">@&quot;Help&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">NSURL</span> <span class="nl">fileURLWithPath:</span><span class="n">path</span> <span class="nl">isDirectory:</span><span class="n">NO</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">loadView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">UIWebView</span> <span class="o">*</span><span class="n">webView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIWebView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame:</span><span class="p">[[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">bounds</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">webView</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="o">=</span> <span class="n">UIViewAutoresizingFlexibleWidth</span> <span class="o">|</span> <span class="n">UIViewAutoresizingFlexibleHeight</span><span class="p">;</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="o">=</span> <span class="n">webView</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">webView</span> <span class="nl">loadRequest:</span><span class="p">[</span><span class="n">NSURLRequest</span> <span class="nl">requestWithURL:</span><span class="p">[</span><span class="n">self</span> <span class="n">helpURL</span><span class="p">]]];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>(2) 应用“设置”功能</h4>

<p>以“显示网格”这一设置项为例，通过<code>UILable  UISwitch</code>来实现。其实可以全部通过NSUserDefaults实现，但inkpad中有个NSMutableDictionary的settings_作为”中间变量“:</p>

<ul>
<li>可能是考虑到在初始化时一次读取NSUserDefaults而不是需要属性就去查NSUserDefaults更好;</li>
<li>还有个原因就是每个drawing都会把settings_当做Document的一部分进行存储，NSMutableDictionary才能去存储。</li>
</ul>


<p>在<code>WDDrawingController</code>中有<code>WDPropertyManager</code>。除了下面的示例代码，很多属性的管理都在这里，<strong>区别是</strong>settings_只管理<code>设置</code>视图里能改变的属性，并且其值会被存储到document里，跟单独drawing相关；<del>而propertyManager管理<code>应用状态</code>，比如不选路径的时候“路径”的popover tableView里就全部不可用，如添加锚点、合并路径。</del></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// constantly updating the user defaults kills responsiveness after the keyboard has been made visible</span>
</span><span class='line'><span class="c1">// so use this temporary dictionary to avoid hitting the defaults all the time  </span>
</span><span class='line'><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">defaults_</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span><span class="c1">//in init</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//- (void) didEnterBackground:(NSNotification *)aNotification</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">updateUserDefaults</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="k">in</span> <span class="p">[</span><span class="n">defaults_</span> <span class="n">allKeys</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">setObject:</span><span class="n">defaults_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="nl">forKey:</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>相关代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//属性设置-在“设置”界面控件响应方法中</span>
</span><span class='line'><span class="c1">//WDSettingsController</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">takeShowGridFrom:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">UISwitch</span>    <span class="o">*</span><span class="n">mySwitch</span> <span class="o">=</span> <span class="p">(</span><span class="n">UISwitch</span> <span class="o">*</span><span class="p">)</span><span class="n">sender</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">setBool:</span><span class="n">mySwitch</span><span class="p">.</span><span class="n">isOn</span> <span class="nl">forKey:</span><span class="n">WDShowGrid</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="n">synchronize</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawing_</span><span class="p">.</span><span class="n">showGrid</span> <span class="o">=</span> <span class="n">mySwitch</span><span class="p">.</span><span class="n">isOn</span><span class="p">;</span><span class="c1">//Setter方法</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性管理的中间类-在Accessor中设置和应用，发送通知最终应用设置</span>
</span><span class='line'><span class="c1">//WDDrawing:NSObject</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">setShowGrid:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">showGrid</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">settings_</span><span class="p">[</span><span class="n">WDShowGrid</span><span class="p">]</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">showGrid</span><span class="p">);</span><span class="c1">//settings_是NSMutableDictionary，WDShowGrid是NSString “WDShowGrid”</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">postNotificationName:</span><span class="n">WDDrawingChangedNotification</span> <span class="nl">object:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// this isn&#39;t an undoable action so it does not dirty the document</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">document</span> <span class="n">markChanged</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span> <span class="nf">showGrid</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">settings_</span><span class="p">[</span><span class="n">WDShowGrid</span><span class="p">]</span> <span class="n">boolValue</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性改变的即时应用-接收通知并通过setNeedsDisplay处发drawRect重绘</span>
</span><span class='line'><span class="c1">//WDCanvas</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">invalidateFromNotification:</span><span class="p">(</span><span class="n">NSNotification</span> <span class="o">*</span><span class="p">)</span><span class="nv">aNotification</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSValue</span>     <span class="o">*</span><span class="n">rectValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">aNotification</span> <span class="n">userInfo</span><span class="p">][</span><span class="s">@&quot;rect&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSArray</span>     <span class="o">*</span><span class="n">rects</span> <span class="o">=</span> <span class="p">[</span><span class="n">aNotification</span> <span class="n">userInfo</span><span class="p">][</span><span class="s">@&quot;rects&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGRect</span>      <span class="n">dirtyRect</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">float</span>       <span class="n">fudge</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0f</span><span class="p">)</span> <span class="o">/</span> <span class="n">viewScale_</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">rectValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//...</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rects</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//...</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//没有任何userInfo，对应showGrid这一属性的改变</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">rect</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">drawing_</span><span class="p">.</span><span class="n">showGrid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">drawingIsolatedLayer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="nl">drawGrid:</span><span class="n">ctx</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性的保存-主要在WDSettingsController，设置并同步</span>
</span><span class='line'><span class="err">借助</span><span class="n">NSUserDefaults</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//属性的加载-各种init方法中从NSUserDefaults初始化settings_</span>
</span><span class='line'><span class="c1">//WDDrawing</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nl">initWithSize:</span><span class="p">(</span><span class="n">CGSize</span><span class="p">)</span><span class="n">size</span> <span class="nl">andUnits:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">units</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// each drawing saves its own settings, but when a user alters them they become the default settings for new documents</span>
</span><span class='line'>    <span class="c1">// since this is a new document, look up the values in the defaults...</span>
</span><span class='line'>    <span class="n">NSUserDefaults</span> <span class="o">*</span><span class="n">defaults</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSArray</span> <span class="o">*</span><span class="n">keyArray</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">WDShowGrid</span><span class="p">,</span> <span class="n">WDSnapToGrid</span><span class="p">,</span> <span class="n">WDSnapToPoints</span><span class="p">,</span> <span class="n">WDSnapToEdges</span><span class="p">,</span> <span class="n">WDDynamicGuides</span><span class="p">,</span> <span class="n">WDRulersVisible</span><span class="p">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">key</span> <span class="k">in</span> <span class="n">keyArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">settings_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="err">@</span><span class="p">([</span><span class="n">defaults</span> <span class="nl">boolForKey:</span><span class="n">key</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. <code>NSNotification</code>的名字应该在哪定义</h3>

<p>在<code>WDToolManager.m</code>中，<code>NSString *WDActiveToolDidChange = @"WDActiveToolDidChange";</code>，然后在头文件中<code>extern NSString *WDActiveToolDidChange;</code>。一般来说关心这个通知（当前工具改变）的类都引用了这个类的头文件，这样比放在一个<code>ConstantsDefine.h</code>里要好。</p>

<h3>4.枚举定义中为什么要用左移</h3>

<p>这里解释的很详细<a href="http://stackoverflow.com/questions/3999922/why-use-the-bitwise-shift-operator-for-values-in-a-c-enum-definition">Why use the Bitwise-Shift operator for values in a C enum definition?</a>。如果用</p>

<pre><code>typedef enum { WDToolDefault, WDToolShiftKey, WDToolOptionKey }  
</code></pre>

<p>那么<code>WDToolDefault | WDToolShiftKey</code>就是<code>1 | 2</code>会得到3！！用左移就不会有这个问题，就是<strong><em>可以在一个变量中支持多个枚举值</em></strong>（将其相加或者取或），判断的时候取与。</p>

<pre><code>typedef enum {
    WDToolDefault           = 0,
    WDToolShiftKey          = 1 &lt;&lt; 0,
    WDToolOptionKey         = 1 &lt;&lt; 1,
    WDToolControlKey        = 1 &lt;&lt; 2,
    WDToolSecondaryTouch    = 1 &lt;&lt; 3
} WDToolFlags;  
</code></pre>

<h3>5. 子类不能重写touchesBegan但要在其发生同时完成处理</h3>

<p><code>FingerTackerView</code>重写<code>touchesBegan</code>等等方法，然后在其内部进行一些操作后调用<code>[self methodForSubclassOverwritten]</code>，这个方法可以置空。<code>HandWritingView</code>，<code>GestureEditorView</code>等继承自<code>FingerTrackerView</code>的类里重写<code>[self methodForSubclassOverwritten]</code>，这样就能在采集点的同时，对点的处理根据当前选择功能（即所处的视图）来由对应的子类来处理。子类不会出现<code>touchesBegan</code>等，但是可以通过重写方法来实现手势运动时处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[所有遇到过的坑们]]></title>
    <link href="http://daryl5.github.io/blog/2014/03/21/mutablearray-of-keng/"/>
    <updated>2014-03-21T12:22:22+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/03/21/mutablearray-of-keng</id>
    <content type="html"><![CDATA[<!--more-->


<h3>23.OpenGLES绘制时候实现透明背景</h3>

<p>手写视图设置Alpah为0.5，这是之前的实现方式，缺点是笔迹的颜色会因为这个Alpha值而变淡，很不好看。所以需要一个方法让整个视图除了笔迹的部分，其他部分都透明。
<a href="http://stackoverflow.com/questions/3193607/is-it-possible-to-make-an-opengl-es-layer-transparent#">Is it possible to make an OpenGL ES layer transparent?</a>实测有效，代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//initialize your CAEAGLLayer, set the opaque property to NO (or FALSE).</span>
</span><span class='line'><span class="c1">//这个默认是不透明的</span>
</span><span class='line'><span class="n">eaglLayer</span><span class="p">.</span><span class="n">opaque</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//make sure your drawableProperties uses a color format that supports transparency (kEAGLColorFormatRGBA8 does,</span>
</span><span class='line'><span class="c1">//but kEAGLColorFormatRGB565 does not).</span>
</span><span class='line'><span class="c1">//这里就是设置绘制使用的颜色制式，可以看到后者就没有Alpah通道，而我之前使用的就是这个</span>
</span><span class='line'><span class="n">eaglLayer</span><span class="p">.</span><span class="n">drawableProperties</span> <span class="o">=</span> <span class="err">@</span><span class="p">{</span><span class="nl">kEAGLDrawablePropertyRetainedBacking:</span> <span class="err">@</span><span class="n">YES</span><span class="p">,</span>
</span><span class='line'><span class="nl">kEAGLDrawablePropertyColorFormat:</span> <span class="n">kEAGLColorFormatRGBA8</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//然后清屏的时候把Alpha设为0来保证全透明</span>
</span><span class='line'><span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于kEAGLDrawablePropertyRetainedBacking，搞不懂了啊，按理说应该是NO，但是设置为NO绘制的时候之前的笔迹就会一直在闪。<br/>
看到一个博文说：“在前面设置 drawable 属性时，我们设置 kEAGLDrawablePropertyRetainedBacking 为FALSE，表示不想保持呈现的内容，因此在下一次呈现时，应用程序必须完全重绘一次。将该设置为 TRUE 对性能和资源影像较大，因此只有当renderbuffer需要保持其内容不变时，我们才设置 kEAGLDrawablePropertyRetainedBacking为TRUE。”</p>

<p>有<a href="https://developer.apple.com/library/ios/documentation/iPhone/Reference/EAGLDrawable_Ref/EAGLDrawable/EAGLDrawable.html#//apple_ref/doc/uid/TP40007664-CH3-SW9">官方文档</a>:</p>

<blockquote><p>The key specifying whether the drawable surface retains its contents after displaying them. The value for this key is an NSNumber object containing a BOOL data type. If NO, you may not rely on the contents being the same after the contents are displayed. If YES, then the contents will not change after being displayed. Setting the value to YES is recommended only when you need the content to remain unchanged, as using it can result in both reduced performance and additional memory usage. The default value is NO.</p></blockquote>

<h3>22.设置状态栏颜色</h3>

<p>很常见的问题但是网上的答案都忽略了一点：<code>View controller-based status bar appearance的type一定要是Boolean</code>，一般代码方式修改plist文件，这里会是String，那么状态栏颜色不会改变。<br/>
具体设置方式如下：</p>

<ol>
<li>在Targets-Info下添加域<code>View controller-based status bar appearance</code></li>
<li>选择其type为Boolean，值为NO</li>
<li>AppDelegate中：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// Config status bar style</span>
</span><span class='line'><span class="p">[</span><span class="n">application</span> <span class="nl">setStatusBarStyle:</span><span class="n">UIStatusBarStyleLightContent</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者在Targets-General下面设置<code>Status Bar Style</code>为Light（原本是Default）<br/>
这里有点坑啊，既然在工程配置界面提供了状态栏设置，但这里设置起作用的前提是要去plist文件里添加一个属性，很奇怪。</p>

<h3>21.iOS7中tint UIImage</h3>

<p>给UIImageView设置tintColor，然后设置其image的渲染模式为<code>UIImageRenderingModeAlwaysTemplate</code>(忽略颜色信息)，可以把各种线图标弄成统一的自己想要的颜色，代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">UIImageView</span><span class="o">*</span> <span class="n">imageView</span> <span class="o">=</span> <span class="err">…</span>
</span><span class='line'><span class="n">UIImage</span><span class="o">*</span> <span class="n">originalImage</span> <span class="o">=</span> <span class="err">…</span>
</span><span class='line'><span class="n">UIImage</span><span class="o">*</span> <span class="n">imageForRendering</span> <span class="o">=</span> <span class="p">[</span><span class="n">originalImage</span> <span class="nl">imageWithRenderingMode:</span><span class="n">UIImageRenderingModeAlwaysTemplate</span><span class="p">];</span>
</span><span class='line'><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">imageForRendering</span><span class="p">;</span>
</span><span class='line'><span class="n">imageView</span><span class="p">.</span><span class="n">tintColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">];</span> <span class="c1">// or any color you want to tint it with</span>
</span></code></pre></td></tr></table></div></figure>


<h3>20.往NSUserDefaults保存UIColor</h3>

<p>参考自<a href="http://stackoverflow.com/questions/1275662/saving-uicolor-to-and-loading-from-nsuserdefaults">Saving UIColor to and loading from NSUserDefaults</a><br/>
NSUserDefaults只支持NSString、NSNumber、NSDate、NSArray、NSDictionary，如果尝试把自定义类放入NSArray任何存也是不行的。<br/>
因为UIColor实现了NSCoding协议的方法，所以下面的代码能行得通。下面代码优缺点，因为同时会把颜色配置信息写入，打印了一下colorData总共102字节，也没太大，就这样了= =！更好的办法是给UIColor做一个Category，来实现NSString和UIColor的互转。<br/>
写入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">NSData</span> <span class="o">*</span><span class="n">colorData</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSKeyedArchiver</span> <span class="nl">archiveDataWithRootObject:</span><span class="n">color</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">setObject:</span><span class="n">colorData</span> <span class="nl">forKey:</span><span class="s">@&quot;myColor&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>读取：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">NSData</span> <span class="o">*</span><span class="n">colorData</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSUserDefaults</span> <span class="n">standardUserDefaults</span><span class="p">]</span> <span class="nl">objectForKey:</span><span class="s">@&quot;myColor&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">UIColor</span> <span class="o">*</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSKeyedUnarchiver</span> <span class="nl">unarchiveObjectWithData:</span><span class="n">colorData</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>更进一步的，做成NSUserDefaults的Category。类似存UIColor，对自定义对象只要实现NSCoding任何就可以archive到data任何存：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#import &quot;NSUserDefaults+UIColor.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">NSUserDefaults</span> <span class="nl">(UIColor)</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nf">colorForKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">defaultName</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSData</span> <span class="o">*</span><span class="n">colorData</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">objectForKey:</span><span class="n">defaultName</span><span class="p">];</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">colorData</span><span class="o">!=</span><span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)[</span><span class="n">NSKeyedUnarchiver</span> <span class="nl">unarchiveObjectWithData:</span><span class="n">colorData</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setColor:</span><span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="p">)</span><span class="nv">value</span> <span class="nf">forKey:</span><span class="n">defaultName</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSData</span> <span class="o">*</span><span class="n">colorData</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSKeyedArchiver</span> <span class="nl">archivedDataWithRootObject:</span><span class="n">value</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span> <span class="nl">setObject:</span><span class="n">colorData</span> <span class="nl">forKey:</span><span class="n">defaultName</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>19.获取iOS7默认的蓝色tintColor</h3>

<p>1.如果不改UIWindow的tintColor，那么可以通过UIWindow获取，代码是<code>[[[[UIApplication sharedApplication] delegate] window] tintColor]</code>。如果开发的代码要作为共享库被集成，那么不要用这个。<br/>
*2.直接用RGB设置，这个颜色是<code>(0,122,255)</code>或者十六进制表示的<code>0x007aff</code>。<br/>
3.用如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//要做成UIColor的Category</span>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">UIColor</span><span class="o">*</span><span class="p">)</span><span class="nf">defaultSystemTintColor</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="k">static</span> <span class="n">UIColor</span><span class="o">*</span> <span class="n">systemTintColor</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>   <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>   <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">UIView</span><span class="o">*</span> <span class="n">view</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>      <span class="n">systemTintColor</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">tintColor</span><span class="p">;</span>
</span><span class='line'>   <span class="p">});</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">systemTintColor</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>*4.有引文</p>

<blockquote><p>In iOS v7.0, all subclasses of UIView derive their behavior for tintColor from the base class. See the discussion of tintColor at the UIView level for more information.</p></blockquote>

<p>所以<code>self.view.tintColor</code>也OK，从各种按钮什么的获取也OK。</p>

<h3>18.UIToolbar上</h3>

<p>自己写了一个TransparentToolbar，但在iOS7下按钮老是那个标准蓝色，因为toolbar那个是toolbar的默认tintColor。要用imageWithRenderingMode对按钮图片设置一下总是渲染原图。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Don&#39;t tint</span>
</span><span class='line'><span class="n">UIImage</span> <span class="o">*</span><span class="n">moodImage</span> <span class="o">=</span> <span class="p">[[</span><span class="n">buttonImage</span> <span class="nl">imageWithRenderingMode:</span><span class="n">UIImageRenderingModeAlwaysOriginal</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>17.UIDocument的读取是在后台进程完成的</h3>

<p>尝试读取document然后根据读到的内容显示天气和心情的图片，发现总是默认值，因为设置代码的位置不对。虽然是在读取文件的代码之后，但是因为读取操作在后台进行，所以读出来时候UI已经设置过了。要在<code>openWithCompletionHandler</code>中设置图片。</p>

<h3>16.随机数生成</h3>

<p><code>arc4random() % x</code>取的是0到x-1中间的整数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">getRandomNumberBetween:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">from</span> <span class="nf">to:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">to</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">from</span> <span class="o">+</span> <span class="n">arc4random</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">to</span><span class="o">-</span><span class="n">from</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>15.TableView的<code>sectionHeaderHeight</code>属性</h3>

<p>直接用<code>table_.sectionHeaderHeight = 40.0f;</code>设置是无效的，要重写如下代理方法才行。但是<code>table_.sectionFooterHeight = 0;</code>是可以的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGFloat</span> <span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span> <span class="nf">heightForHeaderInSection:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">section</span><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="mf">40.0f</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>14.自己实现getter和setter后便没有了_iVar</h3>

<p>使用property时候，编译器会自动添加<code>@synthesize property = _property</code>和<code>Accessor</code>，然后访问器里使用<em>property来读取和设置，同时加上内存管理语义。<br/>
自己实现了getter和setter后编译器就不会有synthesize操作了，当然就不会有</em>property，如果还需要用实例变量，那么自己写synthesize就好。</p>

<h3>13.深拷贝和浅拷贝</h3>

<p>简单来说这个bug主要是因为定义了临时变量来保存mutableArray但是没有对原变量做mutableCopy。<br/>
工程中用如下代码触发KVO。考虑到要在dataUnitArray变化时进行绘图，而且要给UIDocument实现undo/redo功能，所以没有直接<code>[self.dataUnitArray addObject:object]</code>，而是做一个临时变量然后直接赋值来是dataUnitArray变化进而触发KVO，同时，dataUnitArray的setter也是注册undo/redo行为最方便的地方。一开始有问题，写入字符时候点undo老是没反应，而且tempArray和dataUnitArray长度相等，很简单，一开始没有<code>mutableCopy</code>，直接指针赋值给了tempArray接着给tempArray添加也就是直接给dataUnitArray添加。
另外，通过临时变量再赋值触发KVO的方式不好；赋值整个dataUnitArray更不好。后面重构一下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">tempArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dataUnitArray</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">tempArray</span> <span class="nl">addObjectsFromArray:</span><span class="n">charUnitArray</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">dataUnitArray</span> <span class="o">=</span> <span class="n">tempArray</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>12.自定义Accessor</h3>

<p>自己实现了setter和getter后，synthesize就不会起作用了，也就是说<code>没有_propertyName</code>这个实例变量，这种情形下如果在Accessor中还需要直接访问实例变量，那就要手动的添加<code>@sythesize propertyName = _propertyName</code>。</p>

<h3>11.连按删除按钮时候下标越界</h3>

<p>在<code>- (void)deleteDataUnit</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">tempArray</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">dataUnitArray</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//删除</span>
</span><span class='line'><span class="p">[</span><span class="n">tempArray</span> <span class="nl">removeObjectAtIndex:</span><span class="n">cursorIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//触发KVO去绘制</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">dataUnitArray</span> <span class="o">=</span> <span class="n">tempArray</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在<code>- (UIImage *)generatePageImageWithPageIndex:(int)pageIndex</code>中就越界了。</p>

<p><strong>原因</strong>是tempArray和dataUnitArray指的同一块内存，比如原本长度12，删除一个变为11，在后台线程中绘制这个11长度的数组的时候，又按了一下删除，这时候已经触发了KVO，又多了一个绘制线程，之前那个绘制线程在绘制11长度，但是现在的长度是10，所以按的快的时候就会越界，按的慢等每一次绘制结束就没事。</p>

<p><strong>解决办法</strong>是给tempArray赋值的时候进行一下mutable copy，这样每一个绘制线程就用的不同的拷贝，不会导致越界。</p>

<p><strong>更好的解决办法</strong>：类似的情形下，数据改变了就应该停止之前的绘制线程，直接进入新的绘制。打印了一下当前线程，按的快了最多同时开了6个线程在绘制。</p>

<p><a href="http://stackoverflow.com/questions/12660706/nsoperation-cancelalloperations-does-not-stop-the-operation">[NSOperation cancelAllOperations]; does not stop the operation</a>，这个链接里面提到了利用<code>NSOperationQueue</code>的<code>cancelAllOperations</code>来实现“有新数据则停止处理旧数据，从而直接转入对新数据的处理”，实际使用中的确起到了这样的效果，但是跟帖子中例子不同，我的函数里有很多<code>对象</code>，而一个RunLoop就会开一个autoreleasepool，在runloop里我没有去手动释放内存而直接返回，然后内存占用飙升了。懒得再去改进了，只求用户不要太变态。</p>

<h3>10.iOS7中自定义导航栏、状态栏的样式</h3>

<p>设置状态栏：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//In AppDelegate</span>
</span><span class='line'><span class="c1">//Config StatusBar appearance</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">setStatusBarStyle:</span><span class="n">UIStatusBarStyleLightContent</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Config UINavigationController appearance</span>
</span><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setBarTintColor:</span><span class="n">UIColorFromRGB</span><span class="p">(</span><span class="mh">0x3395E3</span><span class="p">)];</span> <span class="c1">// 51, 149, 227</span>
</span><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setTitleTextAttributes:</span><span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">dictionaryWithObjectsAndKeys:</span>
</span><span class='line'>                                                      <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithWhite:</span><span class="mf">0.9</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">],</span>
</span><span class='line'>                                                      <span class="n">NSForegroundColorAttributeName</span><span class="p">,</span>
</span><span class='line'>                                                      <span class="p">[</span><span class="n">UIFont</span> <span class="nl">systemFontOfSize:</span><span class="mf">20.0</span><span class="p">],</span>
</span><span class='line'>                                                      <span class="n">NSFontAttributeName</span><span class="p">,</span> <span class="nb">nil</span><span class="p">]];</span>
</span><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setTintColor:</span><span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithWhite:</span><span class="mf">0.93</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//In ViewController--进入全屏模式，因为主体背景是白色，在AppDelegate设置状态栏是LightContent，全屏了就很瞎眼</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">setStatusBarStyle:</span><span class="n">UIStatusBarStyleDefault</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Leave full screen</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">setStatusBarStyle:</span><span class="n">UIStatusBarStyleLightContent</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/">Customizing Navigation Bar and Status Bar in iOS 7</a>，这个不错。不过里面对单独viewController的statusbar设置<code>UIStatusBarStyle</code>没有成功，没搞懂。<a href="http://stackoverflow.com/questions/17678881/how-to-change-status-bar-text-color-in-ios-7/17768797#17768797">How to change Status Bar text color in iOS 7.</a>和这个<a href="http://stackoverflow.com/questions/19022210/preferredstatusbarstyle-isnt-called/19032879#19032879">preferredStatusBarStyle isn&rsquo;t called</a>可以看看。发现我很蛋疼，老是关注这些意义不大的东西。</p>

<h3>9.UIButton设置tintColor</h3>

<p><code>tintColor</code>属性并不是所有button都有的，只有<code>[UIButton buttonWithType:UIButtonTypeSystem]</code>才能设置。如果是init或者initWithFrame，设置了不会显示。</p>

<h3>8.在主线程更新UI-闪烁光标的实现</h3>

<p>在KVO里要调用drawCursorWithRect画光标，而且这个函数里会启动timer来实现光标闪烁，如果直接调用会不闪烁，然后过一会儿闪一次。记着所有跟UI相关的东西都放在主线程执行。这里还有就是NSValue的<code>valueWithCGRect</code>和<code>CGRectValue</code>。还有就是<code>runloop</code>相关的东西，后面看看。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">keyPath</span> <span class="nl">isEqual:</span><span class="s">@&quot;cursorStartPoint&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">cursorStartPoint</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">document</span><span class="p">.</span><span class="n">cursorStartPoint</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGRect</span> <span class="n">cursorRect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">cursorStartPoint</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cursorStartPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">kCursorOffsetY</span><span class="p">,</span> <span class="n">kCursorWidth</span><span class="p">,</span> <span class="n">kCursorHeight</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSValue</span> <span class="o">*</span><span class="n">cursorRectValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCGRect:</span><span class="n">cursorRect</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">performSelectorOnMainThread:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">drawCursorWithRect:</span><span class="p">)</span> <span class="nl">withObject:</span><span class="n">cursorRectValue</span> <span class="nl">waitUntilDone:</span><span class="n">NO</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外一个问题是，当有新的手写字符时光标要移动，直接改变cursorLayer的frame属性，会有移动过程的动画，看<a href="http://stackoverflow.com/questions/12103142/calayer-animates-with-frame-change">CALayer animates with frame change?</a>。去掉这个动画的方法是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">[</span><span class="n">CATransaction</span> <span class="n">begin</span><span class="p">];</span>
</span><span class='line'><span class="c1">//或者[CATransaction setAnimationDuration:0];</span>
</span><span class='line'><span class="c1">//或者[CATransaction setDisableActions:YES];</span>
</span><span class='line'><span class="p">[</span><span class="n">CATransaction</span> <span class="nl">setValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCFBooleanTrue</span> <span class="nl">forKey:</span><span class="n">kCATransactionDisableActions</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">myView</span><span class="p">.</span><span class="n">myCALayer</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">){</span> <span class="p">{</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span> <span class="p">}</span> <span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">CATransaction</span> <span class="n">commit</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>7.程序突然运行不起来</h3>

<p>先记着后面写，可能是因为最开始建工程时候包含storyboard，中途删掉了storyboard改了Main Interface和AppDelegate和plist，但是可能设备里还是有storyboard的。这样删了程序重新跑的时候就错了。很悲剧的时，设置了异常断点，而问题出在main.m里，这个都没报错的，去掉了才说找不到storyboard。<br/>
试了一下只是简单的在viewDidLoad里改背景颜色，感觉还是怪怪的。直接删了storyboard不改工程配置也能运行，完了删了app重新运行也行，甚至删掉makeKeyAndVisible都能，但是这时候再把Main Interface里的Main删掉，就是黑屏了。</p>

<h3>6.Decode Mutable的东西时要注意mutableCopy</h3>

<blockquote><p>Decoding an archive gives you immutable objects regardless of whether they were mutable or immutable when you encoded them.</p></blockquote>

<p>需要<code>[self setMyArray:[[decoder decodeObjectForKey:@"myArray"] mutableCopy];</code><br/>
还要注意的就是object要copy不然会autorelease <code>You must also copy or retain the string object, otherwise it will be autoreleased:</code>。链接在<a href="http://stackoverflow.com/questions/10391803/nskeyedarchiver-and-nskeyedunarchiver-with-nsmutablearray/10392017#10392017">NSKeyedArchiver and NSKeyedUnarchiver with NSMutableArray</a></p>

<h3>5.toolbar死活不显示</h3>

<p>navigationController的setToolbarHidden属性没设置默认是TRUE。</p>

<h3>4.CGBitmapContext画透明图的实现</h3>

<p>之前是先用一个特定的颜色填充，然后画内容，画完之后再把之前那个颜色mask掉。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Use a &quot;strange or unique&quot; color fill the context add mask it after drawing</span>
</span><span class='line'><span class="n">UIColor</span> <span class="o">*</span><span class="n">fillColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRed:</span><span class="mf">220.0</span><span class="o">/</span><span class="mf">255.0</span> <span class="nl">green:</span><span class="mf">198.0</span><span class="o">/</span><span class="mf">255.0</span> <span class="nl">blue:</span><span class="mf">225.0</span><span class="o">/</span><span class="mf">255.0</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">];</span>
</span><span class='line'><span class="n">CGContextSetFillColorWithColor</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bitmapContext</span><span class="p">,</span> <span class="n">fillColor</span><span class="p">.</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class='line'><span class="n">CGContextFillRect</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">bitmapContext</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">realDisplayWidth</span><span class="p">,</span> <span class="n">realDisplayHeight</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Mask</span>
</span><span class='line'><span class="n">CGImageRef</span> <span class="n">pageImageRef</span> <span class="o">=</span> <span class="n">CGBitmapContextCreateImage</span><span class="p">(</span><span class="n">bitmapContext</span><span class="p">);</span>
</span><span class='line'><span class="k">const</span> <span class="kt">float</span> <span class="n">colorMasking</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">220</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">198</span><span class="p">,</span> <span class="mi">198</span><span class="p">,</span> <span class="mi">225</span><span class="p">,</span> <span class="mi">225</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">};</span>
</span><span class='line'><span class="n">CGImageRef</span> <span class="n">pageImageMask</span> <span class="o">=</span> <span class="n">CGImageCreateWithMaskingColors</span><span class="p">(</span><span class="n">pageImageRef</span><span class="p">,</span> <span class="n">colorMasking</span><span class="p">);</span>
</span><span class='line'><span class="n">UIImage</span> <span class="o">*</span><span class="n">pageImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageWithCGImage:</span><span class="n">pageImageMask</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样的实现非常2，内存开销增加了很大。用<code>CGContextClearRect(bitmapContext, CGRectMake(0, 0, realDisplayWidth, realDisplayHeight));</code>就好了，函数说明就是<code>Paints a transparent rectangle</code>。实现新功能时候先查查比较好的实现方式或者查文档很重要。<br/>
同时要注意，要创建透明位图就要在初始化位图上下文时指定CGBitmapInfo为<code>kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedLast</code>，也可以换成<code>kCGImageAlphaPremultipliedFirst</code>，last就是RGBA反之是ARGB，预乘alpha就代表图像是有alpha通道的，不设置这个clearRect后会是黑色。假如一个像素(A，R，G，B)的四个分量都用规一化的数值表示，(A，R，G，B)为(1，1，0，0)时显示红色。当像素为 (0.5,1,0,0)时，预乘的结果就变成(0.5,0.5,0,0)，这表示原来该像素显示的红色的强度为1，而现在显示的红色的强度降了一半。<br/>
另，<code>颜色深度</code>就是颜色位数，比如RGB一个分量用8位，总共24位，每个像素可以用2的24次方就是16777216中颜色表示，也就是几年前卖手机时候说的1600w色- -！</p>

<h3>3.使用CGBitmapContext并行绘图时报错</h3>

<p>用如下代码进行简单的并行绘制每个字符，结果出现<code>CGContextAddLineToPoint: no current point</code>的错误，就是说在<code>CGContextAddLineToPoint</code>之前并没有一个<code>CGContextMoveToPoint</code>的操作。<br/>
想了一下下面代码有问题，并行绘图的代码里会有这两个操作，待绘制字符多的时候并行程度高，就可能在绘制单个字符的代码中一个的<code>CGContextStrokePath</code>刚执行完，<strong>Stroking the path resets the context&rsquo;s current path to empty, so there is no currentpoint after you call CGContextStrokePath().</strong> context中move到的point已经释放，而另一个正好要执行<code>CGContextAddLineToPoint</code>，于是就<code>no current point</code>了。下面的引文来自<a href="http://lists.apple.com/archives/quartz-dev/2011/Feb/msg00030.html">这里</a></p>

<blockquote><p>Stroking the path resets the context&rsquo;s current path to empty, so there is no currentpoint after you call CGContextStrokePath().ClosePath() isn&rsquo;t there to balance BeginPath() — it modifies the current path by adding a line segment from the current point to the beginning of the current subpath (in such a way that there&rsquo;s a linejoin at that point rather than a pair of line ends).</p></blockquote>

<p>并行绘制最终没想到一个好的并行办法，因为context必须用同一个。最后的解决办法是，能保留上次绘制的context就保留，在其基础上接着绘制- -！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//Draw characters concurrently</span>
</span><span class='line'><span class="n">NSIndexSet</span> <span class="o">*</span><span class="n">indexSetToDraw</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSIndexSet</span> <span class="nl">indexSetWithIndexesInRange:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">characterNum</span><span class="p">)];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">dataUnitArray</span> <span class="nl">enumerateObjectsAtIndexes:</span><span class="n">indexSetToDraw</span>
</span><span class='line'>                                      <span class="nl">options:</span><span class="n">NSEnumerationConcurrent</span>
</span><span class='line'>                                   <span class="nl">usingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">DRDCharUnit</span> <span class="o">*</span><span class="n">charUnitToDraw</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                                       <span class="n">currentCharUnit</span> <span class="o">=</span> <span class="n">charUnitToDraw</span><span class="p">;</span>
</span><span class='line'>                                       <span class="n">originPoint</span> <span class="o">=</span> <span class="n">dataUnitUpperLeftPoints</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="n">startIndex</span><span class="p">];</span>
</span><span class='line'>                                       <span class="p">[</span><span class="n">self</span> <span class="nl">drawCharacter:</span><span class="n">currentCharUnit</span> <span class="nl">withOrigin:</span><span class="n">originPoint</span> <span class="nl">inContext:</span><span class="n">bitmapContext</span><span class="p">];</span>
</span><span class='line'>                                   <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://stackoverflow.com/questions/9150665/trouble-drawing-coregraphics-lines-in-drawrect-method">Trouble drawing CoreGraphics lines in drawRect() method</a> 里的回答:You have to place CGContextStrokePath(context); outside the for loop. Otherwise it will create a fresh path on every run through the loop and that fails.
这个人的问题在于for循环最后都strokePath了，而for循环开头都没有moveToPoint，于是错误发生。<br/>
<a href="http://stackoverflow.com/questions/9799682/cgcontextaddlinetopoint-no-current-point">CGContextAddLineToPoint: no current point</a> 还有一个回答：You must first create a path with CGContextBeginPath before you can start adding points and lines to it. 然后有一个针对这个答案的评论：Not true. A CGContext always has a current path (possibly an empty one) which you can add elements to. You need CGContextBeginPath only when you want to discard the current path and start with a new empty path.</p>

<h3>2.创建支持Retina的CGBitmapContext</h3>

<p>原理是创建两倍长两倍宽的位图，同时ScaleCTM使系统绘图时进行坐标转换。代码如下，摘自<a href="http://stackoverflow.com/questions/10867767/how-to-create-a-cgbitmapcontext-which-works-for-retina-display-and-not-wasting-s">这里</a>：</p>

<blockquote><p>A key factor is that, CGContextScaleCTM(context, scaleFactor, scaleFactor); is used to adjust the coordinate system, so that any drawing by Core Graphics, such as CGContextMoveToPoint, etc, will automatically work, no matter it is standard resolution or the Retina resolution.</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//The sample is to create a 768 x 768 point region.  </span>
</span><span class='line'><span class="c1">//On The New iPad, it will be 1536 x 1536 pixel.  </span>
</span><span class='line'><span class="c1">//On iPad 2, it is 768 x 768 pixel.</span>
</span><span class='line'><span class="kt">float</span> <span class="n">scaleFactor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">scale</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGSize</span> <span class="n">size</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">768</span><span class="p">,</span> <span class="mi">768</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGColorSpaceRef</span> <span class="n">colorSpace</span> <span class="o">=</span> <span class="n">CGColorSpaceCreateDeviceRGB</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGContextRef</span> <span class="n">context</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                           <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">scaleFactor</span><span class="p">,</span>
</span><span class='line'>                           <span class="mi">8</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scaleFactor</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">colorSpace</span><span class="p">,</span>
</span><span class='line'>                           <span class="n">kCGImageAlphaPremultipliedFirst</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">scaleFactor</span><span class="p">,</span> <span class="n">scaleFactor</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>1.CGBitmapContextCreate: unsupported parameter combination</h3>

<p>创建位图上下文时出现的错误：</p>

<blockquote><p>CGBitmapContextCreate: unsupported parameter combination: 8 integer bits/component; 32 bits/pixel; 3-component colorspace; kCGImageAlphaNoneSkipFirst; XXX bytes/row.</p></blockquote>

<p>代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">contextToDraw</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">charUnit</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">charUnit</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span>
</span><span class='line'>                                      <span class="mi">8</span><span class="p">,</span>
</span><span class='line'>                                      <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">colorSpace</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">kCGBitmapByteOrderDefault</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在iOS7之前的代码中，最后一个CGBitmapInfo是kCGImageAlphaPremultipliedFirst，在iOS7下用这个会有警告</p>

<blockquote><p>Implicit conversion from enumeration type &lsquo;enum CGImageAlphaInfo&rsquo; to different enumeration type &lsquo;CGBitmapInfo&rsquo; (aka &lsquo;enum CGBitmapInfo&rsquo;)</p></blockquote>

<p>解决办法是改为<code>kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst</code>。这是因为iOS7中最后一个属性有变化，由<code>CGImageAlphaInfo</code>变为<code>CGBitmapInfo</code>。<a href="http://www.cnblogs.com/wuxiufang/p/3397070.html">这里</a>说的很详细。</p>
]]></content>
  </entry>
  
</feed>
