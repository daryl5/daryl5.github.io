<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C/C++ | Daryl's Blog]]></title>
  <link href="http://daryl5.github.io/blog/categories/c-slash-c-plus-plus/atom.xml" rel="self"/>
  <link href="http://daryl5.github.io/"/>
  <updated>2014-04-27T23:11:52+08:00</updated>
  <id>http://daryl5.github.io/</id>
  <author>
    <name><![CDATA[Daryl5]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction to C++ for iOS Developers]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers/"/>
    <updated>2014-04-24T21:43:30+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers</id>
    <content type="html"><![CDATA[<p>摘自<a href="http://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1">Introduction to C++ for iOS Developers</a>，这篇文章第二部分在<a href="http://www.raywenderlich.com/62990/introduction-c-ios-developers-part-2">这里</a>。<br/>
写了太久OC再去看C++，最好的方式当然是比较着来学习，所以说这篇博文真的太赞了。先挖坑，明天填。</p>

<!--more-->


<h3>Getting Started: A Brief History of Languages</h3>

<p>C++曾经叫做<code>"C with Classes"</code>，OC其实也是在C上做了类这一扩展，两者的区别在于：C++的很多行为发生在编译期而OC更多在运行时期。所以像<code>Method Swizzling</code>这种东西C++是不可能有的。C++也没有<code>Introspection</code>和<code>Reflection methods</code>，不可能知道一个对象属于哪个类。</p>

<h3>C++ Classes</h3>

<p>```objective-c
// MyClass.h</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface MyClass : NSObject
@end</p>

<p>// MyClass.m</p>

<h1>import “MyClass.h”</h1>

<p>@implementation MyClass
@end
<code>
</code>c++
// MyClass.h
class MyClass {
};</p>

<p>// MyClass.cpp</p>

<h1>include “MyClass.h”</h1>

<p>/<em> Nothing else in here </em>/
<code>``
在OC中所有的类都集成自NSObject，如果删掉会编译报错</code>Class &lsquo;Test&rsquo; defined without specifying a base class`。<br/>
OC给C引入了#import来保证一个文件只能被包含一次，C++无对应机制。</p>

<h3>Class Member Variables and Functions</h3>

<p>1.C++里叫<code>成员变量&amp;成员函数</code>，OC里叫<code>实例变量&amp;实例方法</code>。C++中没有<code>method</code>这个术语。在OC中，method就是通过消息派送来调用的东西，而函数是静态的C方式的函数调用如myFunction(intValue)。<br/>
2.C++中成员变量和方法默认是<code>Private</code>的，OC中没有绝对的private。<br/>
3.C++使用类：
<code>c++
//注意这里没有星号，m是存在栈上的，在Memory Management部分可以看到，OC里所有对象都必须加星号声明，使之存在堆
//存在栈上的所以不用new
MyClass m;
m.x = 10;
m.y = 20;
m.foo();
</code></p>

<h3>Implementing Class Member Functions</h3>

<p>1.<code>MyClass::foo() {}</code>这里的<code>::</code>就是表示foo函数是作为MyClass的一部分实现的。<br/>
2.在头文件中直接实现成员函数就是<code>让编译器去尝试内联</code>。内联就是说当调用该函数时，不会跳到一个新的函数块，而是把整个函数的代码都在编译时候内联在了调用处。
```c++
// MyClass.h
class MyClass {</p>

<pre><code>int x;
int y;
void foo() {
    // Do something
}
</code></pre>

<p>};
```</p>

<h3>Namespaces</h3>

<p>1.比如<code>::</code>就是对命名空间的一种指定方式，用来告诉编译器<code>应该去哪里找这个foo函数</code>。<br/>
2.C++命名空间的使用。OC无命名空间，只有设定工程的<code>类名前缀</code>。
```c++
namespace MyNamespace {</p>

<pre><code>class Person { … };
</code></pre>

<p>}</p>

<p>namespace LibraryNamespace {</p>

<pre><code>class Person { … };
</code></pre>

<p>}</p>

<p>MyNamespace::Person pOne;
LibraryNamespace::Person pTwo;
```</p>

<h3>Memory Management</h3>

<p>1.栈和堆<br/>
a.栈固定大小；当指定函数运行时，数据将会入栈，函数运行完同样数量的数据将会出栈。因此随着程序运行，对栈容量的需求不会持续增长。<br/>
b.堆也是一块用于运行程序的内存，不过大小不固定；随着程序运行，占用堆将会增多；程序会把在函数外还会使用的东西放在堆上（比如函数调用传指针，用来当做参数的指针在栈里，而指针所指内容在外部需要用到，因此指针内容在堆上）；此外比较大的数据也会在堆上因为栈很小。
2.C++和OC对堆栈使用的区别
<code>c++
int stackInt = 5; //用的栈空间，函数返回时存储数字'5'的内存会被自动释放
//heapInt用堆空间，需要手动释放
//是不是应该说存储5的内存是分配在堆上的而不是heapInt，heapInt和stackInt应该在符号表什么的吧
int *heapInt = malloc(sizeof(int));
*heapInt = 5;
free(heapInt);
</code>
在OC中尝试分配到栈上<code>NSString stackString;</code>将会有编译错误<code>interface type cannot be statically allocated</code>。OC需要所有object都在堆上这样RC就能控制所有对象的生存与否。<br/>
C++中对象也可以在栈上，如<code>MyPerson person</code>vs<code>MyPerson *person = new MyPerson()</code>，参考Implementing Class Member Functions部分和下面这一部分。</p>

<h3>C++ new and delete</h3>

<p>C++引入new和delete来创建&amp;摧毁堆上的对象
```c++
Person *person = new Person(); //对应OC里的alloc init
delete person; //OC里没有delete，这一操作由运行时在对象的引用计数为0时自动完成</p>

<p>//标量也行
int <em>x = new int();
</em>x = 5;
delete x;
```</p>

<h3>Accessing Members of Stack and Heap Objects</h3>

<p>1.C++访问栈里对象的成员变量或调用成员函数要用点，堆里的用->。
```c++
Person stackPerson;
stackPerson.name = “Bob Smith”; ///&lt; Setting a member variable
stackPerson.doSomething(); ///&lt; Calling a member function</p>

<p>Person *heapPerson = new Person();
heapPerson->name = “Bob Smith”; ///&lt; Setting a member variable
heapPerson->doSomething(); ///&lt; Calling a member function
```
OC里面对property的访问用消息发送和点操作符都行（点操作符会被转为消息发送，应该是在编译阶段），对非property的实例变量直接访问或者用->都行（无property则不会响应这一消息所以点操作符不行）。<br/>
2.this和self对应，用来在类成员函数（实例方法）内部访问当前对象。<br/>
3.OC里给nil发送任何消息都ok，C++里对NULL对象去调用函数会崩溃（nullObject->doSomething();）。</p>

<h3>References</h3>

<p>```c++
class Foo {
  public:</p>

<pre><code>int x;
</code></pre>

<p>};</p>

<p>void changeValue(Foo foo) {</p>

<pre><code>foo.x = 5;
</code></pre>

<p>}</p>

<p>Foo foo; //注意这个声明方式
foo.x = 1;
changeValue(foo); //foo.x还是1，因为C++会做一个foo的拷贝作为参数并不是想的
<code>
上面是`传值`，`传址`和`传引用`都会真正改变foo.x，如下
</code>c++
//传址
void changeValue(Foo *foo) {</p>

<pre><code>foo-&gt;x = 5;
</code></pre>

<p>}</p>

<p>//传引用。对上述例子直接加&amp;就好了
void changeValue(int &amp;x) {</p>

<pre><code>x = 5;
</code></pre>

<p>}
```</p>

<h3>Inheritance</h3>

<p>1.普通继承
```objective-c
@interface Person : NSObject
@end</p>

<p>@interface Employee : Person
@end
<code>
</code>c++
class Person {
};</p>

<p>//public说明Person中所有public的成员变量在Employee仍然是public
//这块可以看看文章-<a href="http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/">http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/</a>
class Employee : public Person {
};
<code>
2.多继承  
OC也可以实现“多继承”，不过如下play和manage方法都必须实现，对C++只需要在base class中实现就行了，子类自动继承其实现。  
当两个base class都实现了就要消除歧义；OC用协议的话PlayerManager必须自己去实现foo，就没有这个问题。
</code>c++
class Player {</p>

<pre><code>void play();
</code></pre>

<p>};</p>

<p>class Manager {</p>

<pre><code>void manage();
</code></pre>

<p>};</p>

<p>class PlayerManager : public Player, public Manager {
};</p>

<p>//Player和Manager都有foo函数
PlayerManager p;
p.foo();          ///&lt; Error! Which foo?
p.Player::foo();  ///&lt; Call foo from Player
p.Manager::foo(); ///&lt; Call foo from Manager
<code>
</code>objective-c
@protocol Player
&ndash; (void)play;
@end</p>

<p>@protocol Manager
&ndash; (void)manage;
@end</p>

<p>@interface Player : NSObject <Player>
@end</p>

<p>@interface Manager : NSObject <Manager>
@end</p>

<p>@interface PlayerManager : NSObject &lt;Player, Manager>
@end
```</p>
]]></content>
  </entry>
  
</feed>
