<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Daryl's Blog]]></title>
  <link href="http://daryl5.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://daryl5.github.io/"/>
  <updated>2015-06-26T18:02:50+08:00</updated>
  <id>http://daryl5.github.io/</id>
  <author>
    <name><![CDATA[Daryl5]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UITableView优化方法]]></title>
    <link href="http://daryl5.github.io/blog/2015/06/06/uitableview-optimize/"/>
    <updated>2015-06-06T14:21:29+08:00</updated>
    <id>http://daryl5.github.io/blog/2015/06/06/uitableview-optimize</id>
    <content type="html"><![CDATA[<!--more-->


<p>先看一下UITableView的<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableView_Class/">官方文档</a>，看看有没有什么以前不知道的细节。</p>

<ul>
<li>NSIndexPath
官方文档里：

<blockquote><p>The NSIndexPath class represents the path to a specific node in a tree of nested array collections. This path is known as an index path.</p></blockquote></li>
</ul>


<p>UITableView对NSIndexPath做了个类扩展所以能直接取section和row，实际就是长度为2的index path第一个指明在sections里的位置第二个指明在rows里的位置。对于indexPath1.4.2.3如下图，以前除了在tableView几乎没用过indexPath。什么时候有用？OC写个b树？<br/>
<img src="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSIndexPath_Class/Art/indexpath.gif" alt="" /></p>

<p>vvebo 缓存力度 专门针对uitableview的缓存框架</p>

<p>国外搜一搜 问问师兄们
用layer
runloop
<a href="http://www.atatech.org/articles/27707">http://www.atatech.org/articles/27707</a> 圆角优化</p>

<p>注意iOS8中字体变大变小</p>

<p>iOS 7 Programming Pushing the limits</p>

<p>hack weixin
25 tips to optimize <a href="http://traximus.github.io/blog/2014/01/21/ios-performance-tips-and-tricksks/">http://traximus.github.io/blog/2014/01/21/ios-performance-tips-and-tricksks/</a></p>

<p>像素对齐
ata 蚂蚁搜索一下</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《iOS设计模式解析》笔记]]></title>
    <link href="http://daryl5.github.io/blog/2015/05/21/ios-design-pattern/"/>
    <updated>2015-05-21T14:14:16+08:00</updated>
    <id>http://daryl5.github.io/blog/2015/05/21/ios-design-pattern</id>
    <content type="html"><![CDATA[<!--more-->


<h2>第1章 你好，设计模式</h2>

<h4>1.5.4 作为复合设计模式的MVC</h4>

<p>MVC本身并不是最基本的设计模式，它包含了很多更加基本的设计模式，在MVC中，基本设计模式相互配合。<br/>
Cocoa及Cocoa Touch的MVC中包含的基本模式有：Composite、Command、Mediator、Strategy、Observer。</p>

<ul>
<li>Composite：视图间的相互组合</li>
<li>Command：Target-Action模式，action代码的执行被延迟到特定事件发生</li>
<li>Mediator：Controller在Model和View中起的作用</li>
<li>Strategy：原话是“控制器可以是视图对象的一个策略”，我理解类似代理吧</li>
<li>Observer：模型对象向它所关注的控制器等对象发出内部状态变化的通知，KVO嘛，应该是模型对象向关注它的控制器等对象发出通知</li>
</ul>


<h4>1.6 影响设计的几个问题</h4>

<p>说了GoF提的<code>针对接口编程，而不是针对实现编程</code>以及<code>优先使用对象组合而不是类继承</code>。</p>

<h2>第2章 案例分析：设计一个应用程序</h2>

<p>这一章打眼一看就感觉很亲切，因为我做过一个类似的应用。等我读了一小半后甚至发现跟我做的东西几乎一样，思考过程也很类似，不过我的功能更多点。</p>

<h4>设计过程中3个重要的里程碑</h4>

<ul>
<li>想法的概念化<br/>
我要做一个手写记事本，大概有abcd功能。头脑风暴，罗列需求，明确需求，细化需求。</li>
<li>界面外观设计<br/>
文件展示用collectionView，点击一个就进入编辑界面，这个界面可以切换工具实现写字、绘画、手势编辑功能，要做一个有时差效果的工具栏能四处拖拽，工具栏上还要有redo、undo按钮，设置要做在右上角popover，帮助要用webview呈现用markdown来导出html页。</li>
<li>架构设计<br/>
主要的功能有写字、绘画、手势编辑，那么可以做一个FingerTracker的父类，做三个子View，Model层用point类和inkPoint类，存储用UIDocument。</li>
</ul>


<h4>2.3.1 视图管理</h4>

<p>为了避免Canvas、Palette、Thumbnail这3个viewController间的耦合引入了CoordinatingController，然后用requestViewChangeByObject:(UIBarButtonItem)来处理视图切换。<br/>
想起以前的项目里类似的东西:
```objective-c
//TBCityNavigatorRegister
[TBNavigator registerClass:@&ldquo;TBCityHomeController&rdquo; withPath:TBCityURLHome];</p>

<p>//TBNavigator
BOOL TBOpenURLFromSourceAndParams(NSString<em> urlPath, id source, NSDictionary</em> params);
BOOL TBOpenURLFromTarget(NSString* urlPath, id target);</p>

<p>//UIViewController实现UIViewControllerTBNavigator协议来接参数完成初始化
//为什么要接URL我也不知道
&ndash; (id)initWithNavigatorURL:(NSURL<em>)URL query:(NSDictionary</em>)query;
```
当然这里为了从外部打开，url处理成了scheme形式，如果没有这个需求可以直接是类名。对于解耦还是有好处的。</p>

<h4>2.3.2 如何表现涂鸦</h4>

<p>我的app里model有<code>Point</code>和<code>InkPoint</code>，前者有x、y坐标，后者继承自前者，多一个<code>strokeWidth</code>属性用来实现数字墨水效果，多一个<code>isEnd</code>记录是否是笔划终结点；然后有一个<code>CharUnit</code>代表字符，里面存字符单元的宽、高，一个数组存所有的inkPoint，一个数组存pointsNumPerStroke；然后<code>Document</code>对象有一个NSMutableArray记录所有的charUnit、imageUnit等等，绘制的时候判断当前对象类型来绘制，总的说就是<code>访问者模式</code>。<br/>
这里引入<code>Vertex</code>存储location，用来记录一个笔划上的一个点，然后<code>Dot</code>继承自Vertext，多一个color和size，记录单独的点，然后一个<code>Stroke</code>实现addMark、count、lastChild等方法，有一个<code>Mark Protocol</code>，声明了addMark、removeMark、childAtIndex、<code>drawWithContext</code>等方法。<strong>Mark协议存在的意义</strong>就在于，Vertex、Dot、Stroke都实现了自己的drawWithContext等方法后，就可以统一的对待所有对象。Vertext就是addLineToPoint到自己的location，Dot就是以自己的frameSize等画出自身就一个点，Stroke就是<code>对所有id&lt;Mark Protocol&gt; child执行drawWithContext然后执行strokePath</code>。这里就是所谓的<code>组合模式</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Software Architecture Patterns』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2015/04/08/reading-software-architecture-patterns/"/>
    <updated>2015-04-08T20:29:54+08:00</updated>
    <id>http://daryl5.github.io/blog/2015/04/08/reading-software-architecture-patterns</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Node.js开发RESTful WebService]]></title>
    <link href="http://daryl5.github.io/blog/2014/08/07/learn-node-dot-js/"/>
    <updated>2014-08-07T19:26:41+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/08/07/learn-node-dot-js</id>
    <content type="html"><![CDATA[<!--more-->


<h2>Node.js的Hello World</h2>

<p>```javascript
var http = require(&lsquo;http&rsquo;);</p>

<p>//当有http请求发送过来时，就会调用此回调函数
http.createServer(function (req, res) {</p>

<pre><code>res.writeHead(200, {'Content-Type': 'text/plain'});
res.end('Hello World\n');
</code></pre>

<p>}).listen(80, &ldquo;127.0.0.1&rdquo;);
```</p>

<h2>Node.js是什么</h2>

<p>在Chrome V8引擎上进行扩展从而生成的一个<code>Javascript运行环境/引擎</code>。一般JS都运行在客户端，Node.js使得JS可以在服务器端运行。</p>

<h2>Node.js的特点</h2>

<p><code>1.事件驱动、异步编程</code><br/>
在传统的网络编程中会用到回调函数，比如当socket资源达到某一状态时注册的回调函数就会执行。以Node.js中的Net模块为例，net.Socket对象就有connect、data、end等事件，开发者可以根据自己的业务逻辑注册响应的回调函数到这些事件。在代码中这些事件看上去是顺次注册的，但是它们并<code>不依赖自身出现的顺序</code>，而是在相应事件发生时触发。<br/>
这两个特点得益于Node.js采用的语言是<code>Javascript</code>，Javascript的<code>匿名函数</code>和<code>闭包</code>特性非常适合事件驱动、异步编程。<br/>
<code>2.高性能</code><br/>
选择C++和V8而不选择Ruby或其他虚拟机就是出于性能考虑。<br/>
事实上Node.js是以<code>单进程、单线程</code>模式运行的，事件驱动机制是Node.js通过对内部单线程高效率的维护时间循环队列来实现，没有多线程的资源占用和上下文切换。面对大规模http请求，Node.js凭借事件驱动搞定一切。实验表明Node.js的事件驱动机制和单进程单线程模式导致CPU占用很高。现在已经有一些支持多进程的模块。</p>

<h2>使用Express</h2>

<p><a href="http://expressjs.com/">Express</a>是基于Node.js的web开发框架，它被作为Node.js的一个module导入项目。下面借助Express来实现简单的REST API，这个主题的内容来自<a href="http://blog.modulus.io/nodejs-and-express-create-rest-api">这里</a>。什么是<code>REST API</code>？可以看<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_APIs">维基</a>。简单来说是由GET, PUT, POST和DELETE四种类型的方法组成。<br/>
<code>1.集成Express到项目</code><br/>
修改<code>package.json</code>然后使用<code>npm install</code>来集成。
```javascript
{</p>

<pre><code>"name": "first-express-app",
"description": "a fine piece of express art",
"version": "0.0.1",
"dependencies": {
    "express": "3.x"
}
</code></pre>

<p>}
<code>
上例中会有警告，没有README之类的，添加private为true就没有警告了。  
`2.Express版的Hello World`  
</code>javascript
var express = require(&lsquo;express&rsquo;);
var app = express(); //app是Express server的一个实例</p>

<p>app.get(&lsquo;/&rsquo;, function(req, res) {</p>

<pre><code>res.type('text/plain');
res.send('Hello World from Express');
</code></pre>

<p>});</p>

<p>//使用process.env.PORT就是说如果设置了PORT环境变量那就会用设置的端口，否则就是自己设定的3000
app.listen(process.env.PORT || 3000);</p>

<p>console.log(&lsquo;Server is running&hellip;&rsquo;);
<code>
然后`node filename.js`并在浏览器访问`http://localhost:3000`即可。  
`3.添加route实现新的API`  
route可以译作路由，就是访问网站时站点名后加的参数等等，用于实现在网站内跳转。在上面的代码中添加代码
</code>javascript
var quotes = [
{ author : &lsquo;Audrey Hepburn&rsquo;, text : &ldquo;Nothing is impossible, the word itself says &lsquo;I&rsquo;m possible&rsquo;!&rdquo;},
{ author : &lsquo;Walt Disney&rsquo;, text : &ldquo;You may not realize it when it happens,</p>

<pre><code>        but a kick in the teeth may be the best thing in the world for you"},
</code></pre>

<p>{ author : &lsquo;Unknown&rsquo;, text : &ldquo;Even the greatest was once a beginner. Don&rsquo;t be afraid to take that first step.&rdquo;},
{ author : &lsquo;Neale Donald Walsch&rsquo;, text : &ldquo;You are afraid to die, and you&rsquo;re afraid to live. What a way to exist.&rdquo;}
];</p>

<p>//bodyParser中间件，可以parse请求的body，然后把body传给request的body property
//用于解析POST请求的内容
app.use(express.bodyParser());</p>

<p>app.get(&lsquo;/&rsquo;, function(req, res) {</p>

<pre><code>res.json(quotes);
</code></pre>

<p>});</p>

<p>app.get(&lsquo;/quote/random&rsquo;, function(req, res) {</p>

<pre><code>var id = Math.floor(Math.random() * quotes.length);
var q = quotes[id];
res.json(q);
</code></pre>

<p>});</p>

<p>//支持传入参数
//<a href="http://localhost:3000/quote/2">http://localhost:3000/quote/2</a>
app.get(&lsquo;/quote/:id&rsquo;, function(req, res) {</p>

<pre><code>if(quotes.length &lt;= req.params.id || req.params.id &lt; 0) {
    res.statusCode = 404;
    return res.send('Error 404: No quote found');
}

var q = quotes[req.params.id];
res.json(q);
</code></pre>

<p>});</p>

<p>//curl -v -H &ldquo;Accept: application/json&rdquo; -H &ldquo;Content-type: application/json&rdquo; -X<br/>
//POST -d &lsquo;{&ldquo;author&rdquo;: &ldquo;daryl&rdquo;, &ldquo;text&rdquo;: &ldquo;daryls post&rdquo;}&rsquo; <a href="http://localhost:3000/quote/">http://localhost:3000/quote/</a>
app.post(&lsquo;/quote&rsquo;, function(req, res) {</p>

<pre><code>if(!req.body.hasOwnProperty('author') || !req.body.hasOwnProperty('text')) {
    res.statusCode = 400;
    return res.send('Error 400: Post syntax incorrect.');
}

var newQuote = {
    author : req.body.author,
    text : req.body.text
}; 

quotes.push(newQuote);
res.json(true);
</code></pre>

<p>});</p>

<p>//curl -I -X DELETE <a href="http://localhost:3000/quote/7">http://localhost:3000/quote/7</a>
app.delete(&lsquo;/quote/:id&rsquo;, function(req, res) {</p>

<pre><code>if(quotes.length &lt;= req.params.id) {
    res.statusCode = 404;
    return res.send('Error 404: No quote found');
}

quotes.splice(req.params.id, 1);
    res.json(true);
</code></pre>

<p>});
```</p>

<h2>参考文献</h2>

<p>1.<a href="http://www.infoq.com/cn/articles/what-is-nodejs">深入浅出Node.js（一）：什么是Node.js</a>  系列文章在<a href="http://www.infoq.com/cn/master-nodejs">这里</a><br/>
2.<a href="http://blog.modulus.io/nodejs-and-express-create-rest-api">NODE.JS AND EXPRESS &ndash; CREATING A REST API</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make A Swipeable TableviewCell]]></title>
    <link href="http://daryl5.github.io/blog/2014/06/25/swipeable-table-view-cell/"/>
    <updated>2014-06-25T19:59:06+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/06/25/swipeable-table-view-cell</id>
    <content type="html"><![CDATA[<p>来自RW的博文<a href="http://www.raywenderlich.com/62435/make-swipeable-table-view-cell-actions-without-going-nuts-scroll-views">How To Make A Swipeable Table View Cell With Actions – Without Going Nuts With Scroll Views</a>。</p>

<!--more-->


<h3>1.UITableViewCell结构解析</h3>

<p><code>给view添加背景色</code>和<code>recursiveDescription</code>都可以用来解析控件结构。
```objective-c</p>

<h1>ifdef DEBUG</h1>

<p>NSLog(@&ldquo;Cell recursive description:\n\n%@\n\n&rdquo;, [cell performSelector:@selector(recursiveDescription)]);</p>

<h1>endif</h1>

<p><code>
iOS7上tableViewCell的结构如下：
</code>objective-c
TableViewCell</p>

<pre><code>CellScrollView
    //SeparatorView
    Button                 disclosure button
        ImageView          button's image
    ContentView
        Label              cell text label
    //SeparatorView
</code></pre>

<p><code>
删除时候结构如下：
</code>objective-c
TableViewCell</p>

<pre><code>CellScrollView
    DeleteConfirmationView
        Confirmation Button
            Label          "Delete"
    //SeparatorView
    ContentView
        Label
    //Separator View
    Button
        ImageView
</code></pre>

<p><code>
iOS8上如下，对比iOS7主要是少了`UITableViewCellScrollView`，这是个UIScrollView的实例：
</code>objective-c
TableViewCell</p>

<pre><code>ContentView
    Label                  cell text label
//SeparatorView
Button
    ImageView
</code></pre>

<p>```
根据官方文档，自定义cell只能在ContentView上添加subview。我们要做的，就是参照苹果实现滑动展示删除按钮的思路，在ContentView上另外实现一套，然后把原本的删除禁掉。</p>

<h3>2.一个Swipeable TableViewCell的必要成分</h3>

<p>由上一部分最后一段可以知道，我们需要一些<code>需要展示的UIButton</code>，然后一个位于这些按钮之上的<code>Container view</code>来显示所有内容，然后需要一个UIScrollView或者<code>UIPanGestureRecognizer</code>来显示或者隐藏按钮，这里我们用后者。最后，<code>需要展示cell内容的views</code>。然后把这些内容都贴到cell的ContentView上。这里有点拗口，对应上面iOS7的cell结构。<br/>
需要禁掉系统cell的滑动删除：
```objective-c
&ndash; (BOOL)tableView:(UITableView <em>)tableView canEditRowAtIndexPath:(NSIndexPath </em>)indexPath {</p>

<pre><code>return NO;
</code></pre>

<p>}
```</p>

<h3>3.建立自定义cell</h3>

<p>直接在storyboard中编辑prototypecell，然后绑定cell所属类，并在tableview代理中返回相应的类型。这里非常坑，半天显示不出来两个按钮，基础太差代码写的太少了，哎。原因见<a href="http://stackoverflow.com/questions/22352587/xcode-5-1-uitableview-in-uiviewcontroller-custom-tableviewcell-outlets-are-nil">Xcode 5.1 UITableView in UIViewController &ndash; Custom TableViewCell Outlets are nil</a>。具体原因是：</p>

<ol>
<li>如果在xib或者storyboard中建立cell了，那么直接deque就能获得cell；</li>
<li>如果要用自定义的cell，那么就要先registerclass，然后重用的时候deque；这时候虽然没有xib，但是运行时也知道如何去建立cell，就用刚注册过的类建立。</li>
</ol>


<p>未完待续&hellip;</p>
]]></content>
  </entry>
  
</feed>
