<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Daryl's Blog]]></title>
  <link href="http://daryl5.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://daryl5.github.io/"/>
  <updated>2015-04-13T11:24:41+08:00</updated>
  <id>http://daryl5.github.io/</id>
  <author>
    <name><![CDATA[Daryl5]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[『Software Architecture Patterns』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2015/04/08/reading-software-architecture-patterns/"/>
    <updated>2015-04-08T20:29:54+08:00</updated>
    <id>http://daryl5.github.io/blog/2015/04/08/reading-software-architecture-patterns</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Node.js开发RESTful WebService]]></title>
    <link href="http://daryl5.github.io/blog/2014/08/07/learn-node-dot-js/"/>
    <updated>2014-08-07T19:26:41+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/08/07/learn-node-dot-js</id>
    <content type="html"><![CDATA[<!--more-->


<h2>Node.js的Hello World</h2>

<p>```javascript
var http = require(&lsquo;http&rsquo;);</p>

<p>//当有http请求发送过来时，就会调用此回调函数
http.createServer(function (req, res) {</p>

<pre><code>res.writeHead(200, {'Content-Type': 'text/plain'});
res.end('Hello World\n');
</code></pre>

<p>}).listen(80, &ldquo;127.0.0.1&rdquo;);
```</p>

<h2>Node.js是什么</h2>

<p>在Chrome V8引擎上进行扩展从而生成的一个<code>Javascript运行环境/引擎</code>。一般JS都运行在客户端，Node.js使得JS可以在服务器端运行。</p>

<h2>Node.js的特点</h2>

<p><code>1.事件驱动、异步编程</code><br/>
在传统的网络编程中会用到回调函数，比如当socket资源达到某一状态时注册的回调函数就会执行。以Node.js中的Net模块为例，net.Socket对象就有connect、data、end等事件，开发者可以根据自己的业务逻辑注册响应的回调函数到这些事件。在代码中这些事件看上去是顺次注册的，但是它们并<code>不依赖自身出现的顺序</code>，而是在相应事件发生时触发。<br/>
这两个特点得益于Node.js采用的语言是<code>Javascript</code>，Javascript的<code>匿名函数</code>和<code>闭包</code>特性非常适合事件驱动、异步编程。<br/>
<code>2.高性能</code><br/>
选择C++和V8而不选择Ruby或其他虚拟机就是出于性能考虑。<br/>
事实上Node.js是以<code>单进程、单线程</code>模式运行的，事件驱动机制是Node.js通过对内部单线程高效率的维护时间循环队列来实现，没有多线程的资源占用和上下文切换。面对大规模http请求，Node.js凭借事件驱动搞定一切。实验表明Node.js的事件驱动机制和单进程单线程模式导致CPU占用很高。现在已经有一些支持多进程的模块。</p>

<h2>使用Express</h2>

<p><a href="http://expressjs.com/">Express</a>是基于Node.js的web开发框架，它被作为Node.js的一个module导入项目。下面借助Express来实现简单的REST API，这个主题的内容来自<a href="http://blog.modulus.io/nodejs-and-express-create-rest-api">这里</a>。什么是<code>REST API</code>？可以看<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#RESTful_web_APIs">维基</a>。简单来说是由GET, PUT, POST和DELETE四种类型的方法组成。<br/>
<code>1.集成Express到项目</code><br/>
修改<code>package.json</code>然后使用<code>npm install</code>来集成。
```javascript
{</p>

<pre><code>"name": "first-express-app",
"description": "a fine piece of express art",
"version": "0.0.1",
"dependencies": {
    "express": "3.x"
}
</code></pre>

<p>}
<code>
上例中会有警告，没有README之类的，添加private为true就没有警告了。  
`2.Express版的Hello World`  
</code>javascript
var express = require(&lsquo;express&rsquo;);
var app = express(); //app是Express server的一个实例</p>

<p>app.get(&lsquo;/&rsquo;, function(req, res) {</p>

<pre><code>res.type('text/plain');
res.send('Hello World from Express');
</code></pre>

<p>});</p>

<p>//使用process.env.PORT就是说如果设置了PORT环境变量那就会用设置的端口，否则就是自己设定的3000
app.listen(process.env.PORT || 3000);</p>

<p>console.log(&lsquo;Server is running&hellip;&rsquo;);
<code>
然后`node filename.js`并在浏览器访问`http://localhost:3000`即可。  
`3.添加route实现新的API`  
route可以译作路由，就是访问网站时站点名后加的参数等等，用于实现在网站内跳转。在上面的代码中添加代码
</code>javascript
var quotes = [
{ author : &lsquo;Audrey Hepburn&rsquo;, text : &ldquo;Nothing is impossible, the word itself says &lsquo;I&rsquo;m possible&rsquo;!&rdquo;},
{ author : &lsquo;Walt Disney&rsquo;, text : &ldquo;You may not realize it when it happens,</p>

<pre><code>        but a kick in the teeth may be the best thing in the world for you"},
</code></pre>

<p>{ author : &lsquo;Unknown&rsquo;, text : &ldquo;Even the greatest was once a beginner. Don&rsquo;t be afraid to take that first step.&rdquo;},
{ author : &lsquo;Neale Donald Walsch&rsquo;, text : &ldquo;You are afraid to die, and you&rsquo;re afraid to live. What a way to exist.&rdquo;}
];</p>

<p>//bodyParser中间件，可以parse请求的body，然后把body传给request的body property
//用于解析POST请求的内容
app.use(express.bodyParser());</p>

<p>app.get(&lsquo;/&rsquo;, function(req, res) {</p>

<pre><code>res.json(quotes);
</code></pre>

<p>});</p>

<p>app.get(&lsquo;/quote/random&rsquo;, function(req, res) {</p>

<pre><code>var id = Math.floor(Math.random() * quotes.length);
var q = quotes[id];
res.json(q);
</code></pre>

<p>});</p>

<p>//支持传入参数
//<a href="http://localhost:3000/quote/2">http://localhost:3000/quote/2</a>
app.get(&lsquo;/quote/:id&rsquo;, function(req, res) {</p>

<pre><code>if(quotes.length &lt;= req.params.id || req.params.id &lt; 0) {
    res.statusCode = 404;
    return res.send('Error 404: No quote found');
}

var q = quotes[req.params.id];
res.json(q);
</code></pre>

<p>});</p>

<p>//curl -v -H &ldquo;Accept: application/json&rdquo; -H &ldquo;Content-type: application/json&rdquo; -X<br/>
//POST -d &lsquo;{&ldquo;author&rdquo;: &ldquo;daryl&rdquo;, &ldquo;text&rdquo;: &ldquo;daryls post&rdquo;}&rsquo; <a href="http://localhost:3000/quote/">http://localhost:3000/quote/</a>
app.post(&lsquo;/quote&rsquo;, function(req, res) {</p>

<pre><code>if(!req.body.hasOwnProperty('author') || !req.body.hasOwnProperty('text')) {
    res.statusCode = 400;
    return res.send('Error 400: Post syntax incorrect.');
}

var newQuote = {
    author : req.body.author,
    text : req.body.text
}; 

quotes.push(newQuote);
res.json(true);
</code></pre>

<p>});</p>

<p>//curl -I -X DELETE <a href="http://localhost:3000/quote/7">http://localhost:3000/quote/7</a>
app.delete(&lsquo;/quote/:id&rsquo;, function(req, res) {</p>

<pre><code>if(quotes.length &lt;= req.params.id) {
    res.statusCode = 404;
    return res.send('Error 404: No quote found');
}

quotes.splice(req.params.id, 1);
    res.json(true);
</code></pre>

<p>});
```</p>

<h2>参考文献</h2>

<p>1.<a href="http://www.infoq.com/cn/articles/what-is-nodejs">深入浅出Node.js（一）：什么是Node.js</a>  系列文章在<a href="http://www.infoq.com/cn/master-nodejs">这里</a><br/>
2.<a href="http://blog.modulus.io/nodejs-and-express-create-rest-api">NODE.JS AND EXPRESS &ndash; CREATING A REST API</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make A Swipeable TableviewCell]]></title>
    <link href="http://daryl5.github.io/blog/2014/06/25/swipeable-table-view-cell/"/>
    <updated>2014-06-25T19:59:06+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/06/25/swipeable-table-view-cell</id>
    <content type="html"><![CDATA[<p>来自RW的博文<a href="http://www.raywenderlich.com/62435/make-swipeable-table-view-cell-actions-without-going-nuts-scroll-views">How To Make A Swipeable Table View Cell With Actions – Without Going Nuts With Scroll Views</a>。</p>

<!--more-->


<h3>1.UITableViewCell结构解析</h3>

<p><code>给view添加背景色</code>和<code>recursiveDescription</code>都可以用来解析控件结构。
```objective-c</p>

<h1>ifdef DEBUG</h1>

<p>NSLog(@&ldquo;Cell recursive description:\n\n%@\n\n&rdquo;, [cell performSelector:@selector(recursiveDescription)]);</p>

<h1>endif</h1>

<p><code>
iOS7上tableViewCell的结构如下：
</code>objective-c
TableViewCell</p>

<pre><code>CellScrollView
    //SeparatorView
    Button                 disclosure button
        ImageView          button's image
    ContentView
        Label              cell text label
    //SeparatorView
</code></pre>

<p><code>
删除时候结构如下：
</code>objective-c
TableViewCell</p>

<pre><code>CellScrollView
    DeleteConfirmationView
        Confirmation Button
            Label          "Delete"
    //SeparatorView
    ContentView
        Label
    //Separator View
    Button
        ImageView
</code></pre>

<p><code>
iOS8上如下，对比iOS7主要是少了`UITableViewCellScrollView`，这是个UIScrollView的实例：
</code>objective-c
TableViewCell</p>

<pre><code>ContentView
    Label                  cell text label
//SeparatorView
Button
    ImageView
</code></pre>

<p>```
根据官方文档，自定义cell只能在ContentView上添加subview。我们要做的，就是参照苹果实现滑动展示删除按钮的思路，在ContentView上另外实现一套，然后把原本的删除禁掉。</p>

<h3>2.一个Swipeable TableViewCell的必要成分</h3>

<p>由上一部分最后一段可以知道，我们需要一些<code>需要展示的UIButton</code>，然后一个位于这些按钮之上的<code>Container view</code>来显示所有内容，然后需要一个UIScrollView或者<code>UIPanGestureRecognizer</code>来显示或者隐藏按钮，这里我们用后者。最后，<code>需要展示cell内容的views</code>。然后把这些内容都贴到cell的ContentView上。这里有点拗口，对应上面iOS7的cell结构。<br/>
需要禁掉系统cell的滑动删除：
```objective-c
&ndash; (BOOL)tableView:(UITableView <em>)tableView canEditRowAtIndexPath:(NSIndexPath </em>)indexPath {</p>

<pre><code>return NO;
</code></pre>

<p>}
```</p>

<h3>3.建立自定义cell</h3>

<p>直接在storyboard中编辑prototypecell，然后绑定cell所属类，并在tableview代理中返回相应的类型。这里非常坑，半天显示不出来两个按钮，基础太差代码写的太少了，哎。原因见<a href="http://stackoverflow.com/questions/22352587/xcode-5-1-uitableview-in-uiviewcontroller-custom-tableviewcell-outlets-are-nil">Xcode 5.1 UITableView in UIViewController &ndash; Custom TableViewCell Outlets are nil</a>。具体原因是：</p>

<ol>
<li>如果在xib或者storyboard中建立cell了，那么直接deque就能获得cell；</li>
<li>如果要用自定义的cell，那么就要先registerclass，然后重用的时候deque；这时候虽然没有xib，但是运行时也知道如何去建立cell，就用刚注册过的类建立。</li>
</ol>


<p>未完待续&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Language Highlights: An Objective-C Developer’s Perspective]]></title>
    <link href="http://daryl5.github.io/blog/2014/06/06/swift-language-highlights-an-objc-develpers-perspective/"/>
    <updated>2014-06-06T13:57:06+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/06/06/swift-language-highlights-an-objc-develpers-perspective</id>
    <content type="html"><![CDATA[<!--more-->


<p><a href="http://www.raywenderlich.com/73997/swift-language-highlights">原文</a>是RW Tutorials里Matt Galloway写的，跟之前自己写的<a href="http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers/">Introduction to C++ for iOS Developers</a>类似，这篇文章是站在Objc开发者的角度来看Swift。这种通过比较两种语言的特性来学习的方法，我认为是最好的。</p>

<h4>1.Types</h4>

<p>a.Swift引入了<a href="http://en.wikipedia.org/wiki/Type_inference">Type Inference</a>，开发者不需要显式指定变量类型，<code>编译器</code>会根据变量被赋的值来推断变量的类型，如下例。
<code>objective-c
// automatically inferred
var name1 = "Matt"
// explicit typing (optional in this case)
var name2:String = "Matt"
</code>
Swift还引入了<a href="http://en.wikipedia.org/wiki/Type_safety">Type Safety</a>。在Swift中，大多数情形下编译器明确知道一个对象所属的类型，这使得编译器能够在编译期间做更多的事，比如优化。其他少数情形可以参考C++中的<a href="http://en.wikipedia.org/wiki/Vtable">虚表</a>适用情形。<br/>
b.Objc是<code>Dynamic Typing</code>的，编译期间不会知道变量类型，<code>运行时</code>负责处理对象类型分析、消息分派等。这使得我们拥有在运行时给一个类动态添加方法等等黑魔法。
<code>objective-c
Person *matt = [[Person alloc] initWithName:@"Matt Galloway"];
[matt sayHello];
</code>
对上面的代码，编译器会去Person类的头文件去查看是否有sayHello方法，但是只会进行最简单的方法存在确认，由于Objc的动态特性，编译器不知道sayHello方法是否会在运行时改变，甚至不知道sayHello到底有没有实现。这种情形需要手动调用<code>respondsToSelector:</code>来检查。<br/>
正是因为这种动态类型的特性，编译器能做的优化很少。系统用<code>objc_msgSend</code>来处理方法调度，在这个方法中运行时会根据调用方法的selector去寻找其对应实现并调用。这个过程增加了一些开销。<br/>
c.下面分析Swifit对于类型的处理，如下例。
<code>python
var matt = Person(name:"Matt Galloway")
matt.sayHello()
</code>
编译器明确知道matt是Person类的实例，并知道sayHello方法具体定义在哪儿。那么在编译时就可以优化使得运行时能直接跳到方法实现的地方，而不需要动态调用。在其他特殊情形下，会利用类似C++<a href="http://en.wikipedia.org/wiki/Vtable">虚表</a>的机制来实现，这虽然增加了一些开销但是比<code>Dynamic Dispatch</code>少了很多。</p>

<blockquote><p>总的来说：<br/>
The compiler is much more helpful in Swift. It will help stop subtle type related bugs from entering your codebase. It will also make your code run faster by enabling smart optimisations.</p></blockquote>

<h4>2.Generics</h4>

<p>Swift引入了<a href="http://en.wikipedia.org/wiki/Generic_programming">泛型</a>，类似C++中的<code>模板</code>。这里有引文：</p>

<blockquote><p> Swift is strict about types, you must declare a function to take parameters of certain types. But sometimes you have some functionality that is the same for multiple different types.</p></blockquote>

<p>```objective-c
struct IntPair {</p>

<pre><code>let a: Int!
let b: Int!

init(a: Int, b: Int) {
    self.a = a
    self.b = b
}

func equal() -&gt; Bool {
    return a == b
}
</code></pre>

<p>}</p>

<p>let intPair = IntPair(a: 5, b: 10)
intPair.a // 5
intPair.b // 10
intPair.equal() // false
<code>
如果还需要一个FloatPair的话，就需要用到泛型了。
</code>objective-c
struct Pair&lt;T: Equatable> {</p>

<pre><code>let a: T!
let b: T!

init(a: T, b: T) {
    self.a = a
    self.b = b
}

func equal() -&gt; Bool {
    return a == b
}
</code></pre>

<p>}</p>

<p>let pair = Pair(a: 5, b: 10)
pair.a // 5
pair.b // 10
pair.equal() // false</p>

<p>let floatPair = Pair(a: 3.14159, b: 2.0)
floatPair.a // 3.14159
floatPair.b // 2.0
floatPair.equal() // false
```</p>

<h4>3.Containers</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Objective-C高级编程』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/05/10/pro-multithreading-and-memory-management-for-ios-and-os-x/"/>
    <updated>2014-05-10T19:20:32+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/05/10/pro-multithreading-and-memory-management-for-ios-and-os-x</id>
    <content type="html"><![CDATA[<!--more-->


<h1>第一章 ARC</h1>

<h2>1.2 内存管理</h2>

<h4>1.2.2 ARC进行内存管理的思考方式</h4>

<ul>
<li>自己生成的对象，自己持有（alloc/new/copy/mutableCopy了就也retain了）</li>
<li>非自己生成的对象，自己也能持有（retain）</li>
<li>自己不再需要持有的对象时释放（release）</li>
<li>非自己持有的对象无法释放（没retain/alloc/new/copy/mutableCopy就不能release）</li>
</ul>


<p>1.OC的内存管理方法实际上不在OC语言里，而是包含在Cocoa框架中的。（OC是C的超集，Cocoa是对OC加了内存管理、多媒体、网络通讯等等的类库形成的用来给OS X开发应用的框架，Cocoa Touch是对Cocoa进行移动适配形成的另一套OC的类库）<br/>
2.Cocoa框架中Foundation框架类库中的NSObject类担负内存管理的职责，内存管理调用的alloc、retain等方法指代的就是NSObject类中的alloc类方法、retain实例方法等。（所有对象继承自NSObject，alloc、retain等内存管理方法在NSObject中实现，这也就是为什么初始化对象时候要先[super init]以及dealloc最末要[super dealloc]）<br/>
3.<code>[NSObject new</code>和<code>[[NSObject alloc] init]</code>是完全等价的。<br/>
4.类似<code>id obj = [NSMutableArray array]</code>这样的生成的类对象并不会被obj所持有，也就是说这行代码里不包含<code>[obj retain]</code>(有<code>[obj autorelease]</code>)，总是这么写不过都是在ARC下，没意识到这个问题。如果是手动管理，加retain就好。</p>

<h4>1.2.3 alloc/retain/release/dealloc实现</h4>

<p>1.NSZone是为了防止内存碎片化而引入的结构。如果分配几块内存依次是小大小大小大，这样释放所有的“小”之后就形成了碎片，所以要有一大一小两种<code>区域</code>，小的去小的大的去大的。<br/>
<strong>现在的运行时的内存管理已经很高效，使用NSZone反而可能会降低效率或使源代码复杂，所以运行时都会忽略NSZone</strong>。<br/>
2.GNUstep是Cocoa框架的互换框架，两者实现不一定相同不过行为是一样的，这一节主要通过读GNUstep中<code>NSObject.m</code>中alloc、retain等方法的源代码来深入了解内存管理。<br/>
3.GNUstep使用<code>内存块头部管理引用计数</code>，苹果使用<code>引用计数表</code>管理引用计数。</p>

<h4>1.2.5 autorelease</h4>

<p>1.和C语言的<code>局部变量(Automatic Variable)</code>类似，如在函数内定义的int，除了函数就废掉了。autorelease的作用范围是NSAutoreleasePool，在<code>[pool drain]</code>时每个调用过autorelease的对象都会调用release。
2.只要不drain pool，生成的对象就不会被释放，内存就越来越少，所以在for循环里如果有很多autorelease对象那就定义一个NSAutoreleasePool来降低内存峰值。
3.Cocoa框架也有很多类方法会返回autorelease的对象。如<code>[NSMutableArray arrayWithCapacity:1]</code>等效于<code>[[[NSMutableArray alloc] initWithCapacity:1] autorelease]</code>。</p>

<h3>1.2.6 autorelease的实现</h3>

<p>1.本质就是<code>调用NSAutoreleasePool的addObject方法</code>。<br/>
2.NSAutoreleasePool的管理应该用的是栈，一个pool是就是栈中的一个项目。</p>

<h2>1.3 ARC规则</h2>

<h4>1.3.3 所有权修饰符</h4>

<p>1.ARC有效时，一共有4种修饰符：</p>

<ol type="a">
<li>__strong</li>
<li>__weak</li>
<li>__unsafe__unretained</li>
<li>__autoreleasing</li>
</ol>


<p>2.所有id和对象都必须加上所有权修饰符，默认是<em>_strong，也就是说:
<code>objective-c
//这两个等效
id obj = [[NSObject alloc] init];
id __strong obj = [[NSObject alloc] init];
</code>
3.所谓强/弱引用实际就是<code>指针对一块内存（或者说一个对象）的引用</code>。<br/>
强引用就是，别人可以release，但是运行时不能销毁这个对象，因为我还强引用着呢。其实就是给retainCounter加了1，所以对象不会被销毁，除非自己再去调用release。<br/>
弱引用就是我在用但是我没给引用计数加1，别人release了我也就用不了了。<br/>
4.简单总结<br/>
<code>ARC实现方式</code><br/>
GNUstep中每个对象头部都存储着自身的引用计数；<br/>
Apple用runtime统一存储所有对象的引用计数，用的是哈希表，以对象地址作为key，引用计数值和真正的内存地址作为值。有一个好处，即使因为故障导致对象所在内存被破坏，但只要引用计数表还在，就能确认内存块位置（这里真的没太懂，可以参考下面__weak的部分，存储指针的地址）。<br/>
<code>__autoreleasing</code><br/>
用该关键词修饰的变量会被注册到autoreleasepool；<br/>
当方法名不是alloc/new/copy/mutablecopy时候，如果要返回object，这个object会被注册到autoreleasepool；<br/>
访问_</em>weak修饰的变量时，该变量会被注册到autoreleasepool，以确保不会因为原有对象被释放而非法访问，因为只要pool还在，该对象都是有效的。<br/>
<code>__weak</code><br/>
也称智能指针，因为当对象被release时候指针会被置nil。<br/>
实现原理是：本质也是<code>哈希表</code>，把对象地址作为key，然后把指向对象的指针的地址（可能有多个指针都指着）作为value。这样当release对象的时候就在weak表中找到所有指向该对象的指针的地址，进而将所有指针都设置为nil。然后还会在weak表中删除该键值对。</p>
]]></content>
  </entry>
  
</feed>
