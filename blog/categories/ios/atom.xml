<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Daryl's Blog]]></title>
  <link href="http://daryl5.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://daryl5.github.io/"/>
  <updated>2014-04-25T22:35:37+08:00</updated>
  <id>http://daryl5.github.io/</id>
  <author>
    <name><![CDATA[Daryl5]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction to C++ for iOS Developers]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers/"/>
    <updated>2014-04-24T21:43:30+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers</id>
    <content type="html"><![CDATA[<p>摘自<a href="http://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1">Introduction to C++ for iOS Developers</a>，这篇文章第二部分在<a href="http://www.raywenderlich.com/62990/introduction-c-ios-developers-part-2">这里</a>。<br/>
写了太久OC再去看C++，最好的方式当然是比较着来学习，所以说这篇博文真的太赞了。先挖坑，明天填。</p>

<h3>Getting Started: A Brief History of Languages</h3>

<p>C++曾经叫做<code>"C with Classes"</code>，OC其实也是在C上做了类这一扩展，两者的区别在于：C++的很多行为发生在编译期而OC更多在运行时期。所以像<code>Method Swizzling</code>这种东西C++是不可能有的。C++也没有<code>Introspection</code>和<code>Reflection methods</code>，不可能知道一个对象属于哪个类。</p>

<h3>C++ Classes</h3>

<p>```objective-c
// MyClass.h</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface MyClass : NSObject
@end</p>

<p>// MyClass.m</p>

<h1>import “MyClass.h”</h1>

<p>@implementation MyClass
@end
<code>
</code>c++
// MyClass.h
class MyClass {
};</p>

<p>// MyClass.cpp</p>

<h1>include “MyClass.h”</h1>

<p>/<em> Nothing else in here </em>/
<code>``
在OC中所有的类都集成自NSObject，如果删掉会编译报错</code>Class &lsquo;Test&rsquo; defined without specifying a base class`。<br/>
OC给C引入了#import来保证一个文件只能被包含一次，C++无对应机制。</p>

<h3>Class Member Variables and Functions</h3>

<p>1.C++里叫<code>成员变量&amp;成员函数</code>，OC里叫<code>实例变量&amp;实例方法</code>。C++中没有<code>method-方法</code>这个术语。在OC中，method就是通过消息派送来调用的东西，而函数是静态的C方式的函数调用如abs(intValue)。<br/>
2.C++中成员变量和方法默认是<code>Private</code>的，OC中没有绝对的private。
3.C++使用类：
<code>c++
//注意这里没有星号，m是存在栈上的，在Memory Management部分可以看到，OC里所有对象都必须加星号声明，使之存在堆
//存在栈上的所以不用new
MyClass m;
m.x = 10;
m.y = 20;
m.foo();
</code></p>

<h3>Implementing Class Member Functions</h3>

<p>1.<code>MyClass::foo() {}</code>这里的<code>::</code>就是表示foo函数是作为MyClass的一部分实现的。<br/>
2.在头文件中直接实现成员函数就是<code>让编译器去尝试内联</code>。内联就是说当调用该函数时，不会跳到一个新的函数块，而是把整个函数的代码都在编译时候内联在了调用处。
```c++
// MyClass.h
class MyClass {</p>

<pre><code>int x;
int y;
void foo() {
    // Do something
}
</code></pre>

<p>};
```</p>

<h3>Namespaces</h3>

<p>1.比如<code>::</code>就是对命名空间的一种指定方式，用来告诉编译器<code>应该去哪里找这个foo函数</code>。<br/>
2.命名空间的使用。OC无命名空间，只有设定工程的<code>类名前缀</code>。
```c++
namespace MyNamespace {</p>

<pre><code>class Person { … };
</code></pre>

<p>}</p>

<p>namespace LibraryNamespace {</p>

<pre><code>class Person { … };
</code></pre>

<p>}</p>

<p>MyNamespace::Person pOne;
LibraryNamespace::Person pTwo;
```</p>

<h3>Memory Management</h3>

<p>1.栈和堆<br/>
a.栈固定大小；当指定函数运行时，数据将会入栈，函数运行完同样数量的数据将会出栈。因此随着程序运行，对栈容量的需求不会持续增长。
b.堆也是一块用于运行程序的内存，不过大小不固定；随着程序运行，占用堆将会增多；程序会把在函数外还会使用的东西放在堆上（比如函数调用传指针，用来当做参数的指针在栈里，而指针所指内容在外部需要用到，因此指针内容在堆上）；此外比较大的数据也会在堆上因为栈很小。<br/>
2.C++和OC对堆栈使用的区别
<code>c++
int stackInt = 5; //用的栈空间，函数返回时存储数字'5'的内存会被自动释放
//heapInt用堆空间，需要手动释放
//是不是应该说存储5的内存是分配在堆上的而不是heapInt，heapInt和stackInt应该在符号表什么的吧
int *heapInt = malloc(sizeof(int));
*heapInt = 5;
free(heapInt);
</code>
在OC中尝试分配到栈上<code>NSString stackString;</code>将会有编译错误<code>interface type cannot be statically allocated</code>。OC需要所有object都在堆上这样RC就能控制所有对象的生存与否。<br/>
C++中对象也可以在栈上，如<code>MyPerson person</code>vs<code>MyPerson person = new MyPerson</code>，参考Implementing Class Member Functions部分和下面这一部分。</p>

<h3>C++ new and delete</h3>

<p>C++引入new和delete来创建&amp;摧毁堆上的对象
```c++
Person *person = new Person(); //对应OC里的alloc init
delete person; //OC里没有delete，这一操作由运行时在对象的引用计数为0时自动完成</p>

<p>//标量也行
int <em>x = new int();
</em>x = 5;
delete x;
```</p>

<h3>Accessing Members of Stack and Heap Objects</h3>

<p>1.C++访问栈里对象的成员变量或调用成员函数要用点，堆里的用->。
```c++
Person stackPerson;
stackPerson.name = “Bob Smith”; ///&lt; Setting a member variable
stackPerson.doSomething(); ///&lt; Calling a member function</p>

<p>Person *heapPerson = new Person();
heapPerson->name = “Bob Smith”; ///&lt; Setting a member variable
heapPerson->doSomething(); ///&lt; Calling a member function
```
OC里面对property的访问用消息发送和点操作符都行（点操作符会被转为消息发送，应该是在编译阶段），对非property的实例变量直接访问或者用->都行（无property则不会响应这一消息所以点操作符不行）。<br/>
2.this和self对应，用来在类成员函数（实例方法）内部访问当前对象。<br/>
3.OC里给nil发送任何消息都ok，C++里对NULL对象去调用函数会崩溃（nullObject->doSomething();）。</p>

<h3>References</h3>

<p>```c++
class Foo {
  public:</p>

<pre><code>int x;
</code></pre>

<p>};</p>

<p>void changeValue(Foo foo) {</p>

<pre><code>foo.x = 5;
</code></pre>

<p>}</p>

<p>Foo foo; //注意这个声明方式
foo.x = 1;
changeValue(foo); //foo.x还是1，因为C++会做一个foo的拷贝作为参数并不是想的
<code>
上面是`传值`，`传址`和`传引用`都会真正改变foo.x，如下
</code>c++
//传址
void changeValue(Foo *foo) {</p>

<pre><code>foo-&gt;x = 5;
</code></pre>

<p>}</p>

<p>//传引用。对上述例子直接加&amp;就好了
void changeValue(int &amp;x) {</p>

<pre><code>x = 5;
</code></pre>

<p>}
```</p>

<h3>Inheritance</h3>

<p>1.普通继承
```objective-c
@interface Person : NSObject
@end</p>

<p>@interface Employee : Person
@end
<code>
</code>c++
class Person {
};</p>

<p>//public说明Person中所有public的成员变量在Employee仍然是public
//这块可以看看文章-<a href="http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/">http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/</a>
class Employee : public Person {
};
<code>
2.多继承  
OC也可以实现“多继承”，不过如下play和manage方法都必须实现，对C++只需要在base class中实现就行了，子类自动继承其实现。  
当两个base class都实现了就要消除歧义；OC用协议的话PlayerManager必须自己去实现foo，就没有这个问题。
</code>c++
class Player {</p>

<pre><code>void play();
</code></pre>

<p>};</p>

<p>class Manager {</p>

<pre><code>void manage();
</code></pre>

<p>};</p>

<p>class PlayerManager : public Player, public Manager {
};</p>

<p>//Player和Manager都有foo函数
PlayerManager p;
p.foo();          ///&lt; Error! Which foo?
p.Player::foo();  ///&lt; Call foo from Player
p.Manager::foo(); ///&lt; Call foo from Manager
<code>
</code>objective-c
@protocol Player
&ndash; (void)play;
@end</p>

<p>@protocol Manager
&ndash; (void)manage;
@end</p>

<p>@interface Player : NSObject <Player>
@end</p>

<p>@interface Manager : NSObject <Manager>
@end</p>

<p>@interface PlayerManager : NSObject &lt;Player, Manager>
@end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Practices & Tips]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c/"/>
    <updated>2014-04-23T19:19:22+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c</id>
    <content type="html"><![CDATA[<!--more-->


<h3>4.用block实现代理</h3>

<p>关于block的大致介绍，<a href="http://onevcat.com/2011/11/objective-c%E4%B8%AD%E7%9A%84block/">Objective-C中的Block</a>这篇博文写的挺好。其中提到的一点需要注意，如下：
```objective-c
int price = 1.99;</p>

<p>float (^finalPrice)(int) = ^(int quantity) {</p>

<pre><code>//Price is accessible here
return quantiy * price;
</code></pre>

<p>}</p>

<p>int orderQuantity = 10;
//Ordering 10 units, final price is: $19.90
NSLog(@&ldquo;Ordering %d units, final price is: $%2.2f&rdquo;, orderQuantity, finalPrice(orderQuantity));</p>

<p>price = .99;
//Ordering 10 units, final price is: $19.90
NSLog(@&ldquo;Ordering %d units, final price is: $%2.2f&rdquo;, orderQuantity, finalPrice(orderQuantity));
```</p>

<blockquote><p>可以理解为在block内的price是readonly的，只在定义block时能够被赋值（补充说明，实际上是因为price是value type，block内的price是在申明block时复制了一份到block内，block外面的price无论怎么变化都和block内的price无关了。如果是reference type的话，外部的变化实际上是会影响block内的）。</p></blockquote>

<p>解决办法有两种：<br/>
1.将局部变量声明为__block，表示外部变化将会在block内进行同样操作;<br/>
2.使用实例变量。关于这点有引文：</p>

<blockquote><p>这个比较没什么好说的，实例内的变量横行于整个实例内..可谓霸道无敌…=_=
block外的对象和基本数据一样，也可以作为block的参数。而让人开心的是，block将自动retain传递进来的参数，而不需担心在block执行之前局部对象变量已经被释放的问题。这里就不深究这个问题了，只要严格遵循Apple的thread safe来写，block的内存管理并不存在问题。（更新，ARC的引入再次简化了这个问题，完全不用担心内存管理的问题了）</p></blockquote>

<p>这里有个问题就是：因为block会自动retain传进来的参数，所以会出现<a href="http://stackoverflow.com/questions/14556605/capturing-self-strongly-in-this-block-is-likely-to-lead-to-a-retain-cycle">capturing self strongly in this block is likely to lead to a retain cycle</a>的问题，即就是传进去<code>self.xxx</code>之后，会retain self，即构成了循环引用。解决办法是定义一个<code>__weak</code>的self然后在block中使用。</p>

<p><strong>回到正题，block代替protocol</strong>
```objective-c
//In DRDHandWriting.h
typedef void(^didFinishWriting)(NSMutableArray *);
@property (copy, nonatomic) didFinishWriting didFinishWritingBlock;//注意这里是copy</p>

<p>//In DRDHandWriting.m
//Submit charUnitArray to Document
self.didFinishWritingBlock(segmentedCharUnitArray);</p>

<p>//In DRDManuscriptController::loadHandWritingView
handWritingView = [[DRDHandWriting alloc] initWithFrame:handWritingRect];
__weak DRDManuscriptController <em>weakSelf = self;
//这里的参数只是被代理对象需要返回给代理的数据，具体就是手写视图需要返回切分好的字符给controller
//另一种情形就是多个AlertView的代理，这里就可以传回当前alertView
[handWritingView setDidFinishWritingBlock:^(NSMutableArray </em>segmentedArray) {</p>

<pre><code>[weakSelf.document addOrInsertCharUnitArray:segmentedArray];
</code></pre>

<p>}];
```
关于上例中block的copy，有<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">官方文档</a>：</p>

<blockquote><p>Note: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. For more information, see Blocks Programming Topics.</p></blockquote>

<p>block在创建的时候是分配在栈上的，如果<code>retain</code>（栈上的东西不能retain），在调用block的时候程序就会崩溃，实际上ARC下测试了一下retain，只是代码编辑阶段即给出警告<code>Retain'ed block property does not copy the block - use copy attribute instead</code>并且程序正常运行。而如果是<code>copy</code>，将会把这个block拷贝到堆里，同时retain这个block所引用的所有东西。block在堆上的时候进行copy就没事，不会再拷贝一遍，只是相当于retain。这段摘自<a href="http://blog.refractalize.org/post/10476042560/copy-vs-retain-for-objective-c-blocks">Copy vs retain for Objective-C blocks</a>。</p>

<p><strong>结论：</strong><br/>
自己实验了一下上面那个改变price输出总价不变的例子，block在创建的时候是分配在栈上的。<br/>
1.如果block里用到了局部变量，那么就会拷贝一份：比如<code>int a = 5</code>就会拷贝一个int变量其值为5；如果是<code>int *ptr = 5</code>就会拷贝ptr这个指针，这样改变*ptr的值，block里也会跟着变。<br/>
2.如果用到了实例变量，那么不管是value type还是指针型的，都不会出现外部更新而block内部没跟着变的情况，猜想是因为block引用实例变量其实就是对self指针的弱引用，用到实例变量时候用指针去读的。<br/>
3.上面<code>capturing self strongly in this block is likely to lead to a retain cycle</code>这一问题，是因为用到了实例变量。两种情况：如果是property那么隐含<code>self.propertyXXX</code>；如果是非property的实例变量，隐含<code>self-&gt;iVar</code>，都有self。因为是用block实现代理，那么需要传block给被代理对象，被代理对象copy block，同时运行时会copy block到堆上并retain block里所有的东西，这就相当于被代理对象里声明了一个<code>@property (strong, nonatomic) id&lt;XXXProtocol&gt; delegate</code>，所以就造成了循环引用。上面那个SO的链接讲得很清楚。<br/>
4.最后，什么时候用block什么时候用delegation，<a href="http://stablekernel.com/blog/blocks-or-delegation/">Blocks or Delegation</a>讲了，实在不想看了，先马克- -！</p>

<h3>3.Category也能Conform to a protocol</h3>

<h3>2.对集合中每个对象发送消息</h3>

<p><code>objective-c
// remove all subviews
[[self.scrollView subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)];
</code></p>

<h3>1.<a href="http://ironwolf.dangerousgames.com/blog/archives/913">The Code Commandments: Best Practices for Objective-C Coding </a></h3>

<p><strong>a.在实例变量前加<code>@private</code></strong>[放在类扩展就好]</p>

<ul>
<li>表明该变量与API无关</li>
<li>默认是<code>@protected</code>即就是子类可以访问，如果子类不需要那就不要暴露，面向对象的<code>信息隐藏</code>，（其实最好的应该是子类和其他类用到的在.h，私有变量和方法在类扩展）</li>
</ul>


<p><strong>b.为每一个<code>data member</code>创建<code>@property</code>，在.m中都用<code>self.name</code>来访问</strong>[这个有问题]</p>

<ul>
<li>property会把访问权限加入，如readonly</li>
<li>property会把内存管理加入，strong&amp;weak</li>
</ul>


<p><strong>c.<code>实例变量</code>就是只给当前类及其子类使用，<code>@property</code>就是外部类也能用</strong><br/>
之前看到在头文件里interface部分定义实例变量，同时又用@property重新写一遍。对于想要公开给这个类及其子类以外的类的实例变量，那么就为其写一个对应的property。<br/>
<strong>d.关于<code>readonly</code></strong>
就是说这个property在外界不能修改，如<code>self.document.displayHeight</code>会产生<code>assign to readonly property</code>。在类的实现文件里可以通过实例变量来修改，如<code>_displayHeight = 600</code>，此外，在实现文件还可以通过<code>self-&gt;_displayHeight = 600</code>来修改，这里之所以用->大概是因为类本身拥有这个实例变量就意味着类的实例有一个指向这个实例变量的指针，而property只是用于公开给外部，在这里没property什么事。
另外还可以在类扩展里告诉编译器我还需要一个setter，但只是在实现文件里：
<code>objective-c
//公有可读，私有可写
@interface YourClass ()
@property (nonatomic, copy) NSString* eventDomain;
@end
</code>
这个问题在<a href="http://stackoverflow.com/questions/4586516/readonly-properties-in-objective-c">Readonly Properties in Objective-C?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Effective Objective-C 2.0』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0/"/>
    <updated>2014-04-07T13:22:29+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0</id>
    <content type="html"><![CDATA[<p>《Effective Objective-C 2.0：52 Specific Ways to Improve Your iOS and OS X Programs》 作者：<a href="http://www.galloway.me.uk/">Matt Galloway</a></p>

<h2><strong>1: Accustoming Yourself to Objective-C</strong></h2>

<h3>Item 2: 缩减头文件&mdash;Minimize Importing Headers in Headers</h3>

<p>a.如下引文，试了一下互相import，没有报错- -！</p>

<blockquote><p>The use of #import rather than #include doesn&rsquo;t end in an infinite loop but does mean that one of ther classes won&rsquo;t compile correctly.</p></blockquote>

<p>b.协议相关<br/>
一些代理相关的协议，可以把协议头文件在.m文件里再引入，把代理<code>id&lt;XXXProtocol&gt; delegate</code>定义放在类扩展里。
也可以考虑单独创建一个头文件，里面只放协议定义。</p>

<!--more-->


<h3>Item 3: 使用字面量语法而不是其等价方法&mdash;Prefer Literal Syntax over the Equivalent Methods</h3>

<p>a.字面量使用</p>

<pre><code>NSString *str           = @"Test String";
NSNumber *boolValue     = @YES;
NSNumber *charValue     = @'a';
NSNumber *expressionVal = @(x * y);//int x &amp; float y

NSArray *animals        = @[@"cat", @"dog"];
NSString *dog           = animails[1];//下标直接访问

NSDictionary *person    = @{@"firstName" : @"Matt", @"age" : @28};
NSString *firstName     = person[@"firstName"];//key值直接访问value

//Assign value or replace
mutableArray[1] = @"dog";
mutableDictionary[@"lastName"] = @"Galloway";
</code></pre>

<p>b.好处<br/>
如果NSArray用3个object来初始化，第二个是nil，那么arrayWithObjects将会返回一个只包含object1的array，而字面量初始化会报错。<strong>“报错”比“少了个数”更安全。</strong>
对于NSDictonary，初始化会在遇到nil时候停止，dictionaryWithObjectsAndKeys可能会少了某一个value；字面量更安全。<br/>
c.缺点<br/>
字面量语法只能用于Foundation框架的一些类，对于自定义的类没法这样定义（显然）。<br/>
对于mutable对象的定义，需要进行mutableCopy。增加了额外的方法调用和对象创建</p>

<pre><code>NSMutableArray *mutable = [@[@1, @2, @3] mutableCopy];
</code></pre>

<h3>Item 4: 使用类型化常量而不是预处理指令#define&mdash;Prefer Typed Constants to Preprocessor #define</h3>

<p>a.#define的缺点<br/>
预处理指令<code>#define ANIMATION_DURATION 0.3</code>只是在预处理阶段进行<code>替换</code>，它没有包含类型信息。（如果定义在头文件，所有包含该头文件的文件也都会进行替换。）<br/>
b.类型化常量的使用（static const）<br/>
用上编译器让常量有类型信息：<code>static const NSTimerInterval kAnimationDuration = 0.3;</code>
常量命名规范：</p>

<blockquote><p>The usual convertion for constants is to prefix with lettr k for constants that are local to a translation unit(implementation file). For constants that are exposed outside of a class, it is usual to prefix with the class name.<br/>
在.m中定义，对于这个translation unit是局部变量的话用k作前缀；如果要暴露给外界，用类名开头，如EOCViewClassAnimationDuration。</p></blockquote>

<p><code>static</code>关键词说明这个变量对于当前translation unit是局部的，如果没定义为static，编译器将会为其创建一个external symbol，如果另一translation unit声明了一个同名变量，链接器将会报错；<code>const</code>关键词说明不能被修改。</p>

<blockquote><p>A translation unit is the input the compiler receives to generate one object file. In OC, this usually means that there is one translation unit per class: every .m file.</p></blockquote>

<p>SO的一个问题：<a href="http://stackoverflow.com/questions/11382502/how-different-static-variable-declarations-in-objective-c">How different static variable declarations in Objective-C?</a><br/>
c.类型化常量的使用（extern）<br/>
跟<code>NSNotification</code>相关，通知名应该这样处理：</p>

<pre><code>// In .h
// extern--"Trust me, there's a variable called EOCStringConstant declared in another file"
// EOC是类名
extern NSString *const EOCStringConstant;

// In .m
//反着读：EOCStringConstantis a const pointer point to NSString
NSString *const EOCStringConstant = @"NotificationName";
//如果不是对象那这里是const NSTimeInterval EOCAnimated...
</code></pre>

<p>d.总结<br/>
类型化常量有类型- -！
类型化常量借助编译器来确保常量的一致性（const），预处理指令#define可以在别的地方重定义。<br/>
.m的局部变量如动画时间等用k开头放在.m文件里用static；通知名等用类名+通知名，.m里声明+定义，.h里extern，如UIApplication类里声明+定义的UIApplicationDidEnterBackGroundNotifation。</p>

<h2><strong>2: Objects, Messaging, and the Runtime</strong></h2>

<h3>Item 6: 理解Properties-Understand Properties【需要再看】</h3>

<p>a.自己写了Accessor中的一个，编译器将会synthesize另一个，LazyLoading就是这样的。如果不想让编译器自动synthesize，可以用<code>@dynamitc</code>指令，这样编译器不会生成Accessor和对应的实例变量名，而且编译时候编译器会忽略Accessor还没有被定义但是已经在self.property，编译器会认为Accessor在runtime时会有的。<br/>
b.<code>weak</code>不会release旧值，也不会retain新值，类似assign，不过这个property所指对象被销毁时，这个property会被nilled out。<br/>
<code>unsafe_unretained</code>也和assign类似，只是关于object的assign，unretained对应nonowning，unsafe对应不会被nilled out，这一点和weak不一样。<br/>
<code>copy</code>对应mutable copy，如果不想让对象把传进来的值改变了，应该做一下copy，也就是immutable copy。虽然增加了拷贝操作，但是会更安全。<br/>
c.关于自定义getter名在BOOL上的应用，为了加is为什么不直接把property命名成isXxx。</p>

<h3>Item 10: 在既有类中适用关联对象存放自定义数据-Use Associated Objects to Attach Custom Data to Existing Classed</h3>

<p>a.一般都是通过<code>继承</code>来给既有类添加数据，但行不通的时候就要用到<code>关联对象</code>了。以UIAlertView为例：</p>

<ul>
<li>一般的实现中buttonIndex和其action的对应，即button的定义和其响应方法的声明不在一个地方，这样可读性不好；</li>
<li><p>如果同一个类里有多个alertView，那么在代理方法中还要判断是哪一个，然后再判断buttonIndex；
```objective-c
static const void *EOCMyAlertViewKey = &ldquo;EOCMyAlertViewKey&rdquo;;</p></li>
<li><p>(void)askUserAQuestion {
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&ldquo;Question&rdquo;
                                                  message:@&ldquo;What do you want to do?&rdquo;
                                                 delegate:self
                                        cancelButtonTitle:@&ldquo;Cancel&rdquo;
                                        otherButtonTitles:@&ldquo;Continue&rdquo;, nil];</p>

<p>  void(^block)(NSInteger) = ^(NSInteger buttonIndex) {
      if (buttonIndex == 0) {
          [self doCancel];
      } else {
          [self doContinue];
      }
  };</p>

<p>  objc_setAssociatedObject(alert, EOCMyAlertViewKey, block, OBJC_ASSOCIATION_COPY);</p>

<p>  [alert show];
}</p></li>
</ul>


<p>// UIAlertViewDelegate protocol method
&ndash; (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex {</p>

<pre><code>void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);
block(buttonIndex);
</code></pre>

<p>}
<code>``
b.总结  
关联对象就是把两个object链接在一起了；关联对象只有在其他方法都不可行的时候才使用，因为很容易造成</code>Retain Cycle`；上例中还可以通过继承AlertView并附加这个block对象来实现，如果类中alertView要多次用到，更建议继承而不是关联对象。</p>

<h3>Item 14: 理解类的对象- Understand What a Class Object Is</h3>

<p>a.OC是<code>动态类型</code>的，对象的类型并不是在编译时候进行绑定的，而是在运行时进行查找。</p>

<h2><strong>4: Protocols and Categories</strong></h2>

<h3>Item 23: 通过委托和数据源协议进行对象间通信</h3>

<p>a.有一句话没太懂，这个单词居然查不出来，完了看看Item6，里面有这个单词：</p>

<blockquote><p>A delegate property will always be defined using either the weak attribute to benefit from <code>autonilling</code> or unsafe_unretained if autonilling is not required.</p></blockquote>

<p>b.在interface中声明遵守协议的话，别的类会知道这一行为，一般把“遵守协议”放在类扩展部分，虽然没太多影响。要知道一个对象是否遵守某个协议可以这样：<code>[self conformsToProtocol:@protocol(DRDHandWritingProtocol)]</code><br/>
c.可以把正在代理的对象也传回给代理，这样方便判断具体是哪个代理对象在调用代理方法。
```objective-c
&ndash; (void)networkFetcher:(EOCNetworkFetcher <em>)fetcher didReceiveData:(NSData </em>)data {</p>

<pre><code>if (fetcher == _myFetcherA) {
    //Handle data
} else if (fetcher == _myFetcherB) {
    //Handle data
}
</code></pre>

<p>}
<code>
d.如果开发API，用代理可以实现一些属性设置，如`- (BOOL)networkFetcher:(EOCNetworkFetcher *)fetcher shouldFollowRedirectToURL:(NSURL *)url;`，甚至这里可以给fetcher传递一个NSDictionary来进行Fetcher一系列属性的设置。  
e.对`@optional`的代理方法，方法调用者负责通过`[delegate respondsToSelector]`确保程序不会崩溃，unrecognized selector。`@required`的话编译器会确认。如果没设置，默认都是required。  
f.对dataSource类的delegate，在获取每一个小的data piece的时候都查询一次respondsToSelector是低效的，应该将当前对象对协议的遵守情况缓存下来。如下：
</code>objective-c
//有个DataModel或者ViewController是该对象的代理
//In class extension
@interface EOCNetworkFetcher() {</p>

<pre><code>struct {
    unsigned int didReceiveData      : 1;
    unsigned int didFailWithError    : 1;
    unsigned int didUpdateProgressTO : 1;
}_delegateFlags;
</code></pre>

<p>}</p>

<p>//In delegate Setter
&ndash; (void)setDelegate:(id<EOCNetworkFetcher>)delegate {</p>

<pre><code>_delegate = delegate;
_delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];
...
</code></pre>

<p>}</p>

<p>//Query if responds to selector (FRENQUENTLY)
if (_delegateFlags.didReceiveData) {</p>

<pre><code>[_delegate networkFetcher:self didReceiveData:dataReceived];
</code></pre>

<p>}
<code>
g.协议的“继承”
</code>objective-c
@protocol A</p>

<pre><code>-(void) methodA;
</code></pre>

<p>@end</p>

<p>@protocol B <A></p>

<pre><code>-(void) methodB;
</code></pre>

<p>@end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIDocument的使用]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument/"/>
    <updated>2014-04-01T21:42:32+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument</id>
    <content type="html"><![CDATA[<p>读<a href="https://github.com/sprang/Inkpad">Inkpad</a>源码时看到使用了<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIDocument_Class/UIDocument/UIDocument.html#//apple_ref/c/tdef/UIDocumentState">UIDocument</a>，然后搜到了Ray Wenderlich的博文：<a href="http://www.raywenderlich.com/12779/icloud-and-uidocument-beyond-the-basics-part-1">iCloud and UIDocument: Beyond the Basics</a>，整理了一下大致用法。</p>

<h3>1. 继承UIDocument并重写方法</h3>

<p>需要重写<code>loadFromContents:ofType:error</code>方法来读，重写<code>contentsForType:error</code>方法来写。</p>

<h3>2. 输入输出格式</h3>

<p>UIDocument支持两种类，<code>NSData</code>适用于文档只是一个单一文档，<code>NSFileWrapper</code>相当于文件夹，适用于文档包含多个想要单独加载的文件，比如矢量图绘制App要显示一个缩略图，这个需要单独提前加载。FileWrapper内部是Key-Value形式的存储，文件名是key，文件存在本地的archive内容（或是archive文件名）是value，所以会有：</p>

<!--more-->


<pre><code>//从文件名（如xxxx.title，不是xxxx.note）得到FileWrapper
NSFileWrapper *fileWrapper = [self.fileWrapper.fileWrappers objectForKey:preferredFilename];

//从FileWrapper得到文件内容
NSData *data = [fileWrapper regularFileContents];
NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
</code></pre>

<h3>3. iCloud</h3>

<p>Apple规定，应用的所有documents要么在沙盒，要么在iCloud本地文件夹，用户不能选择某一文件来让其单独的存储在iCloud。</p>

<blockquote><p>All documents of an application are stored either in the local sandbox or in an iCloud container directory. A user should not be able to select individual documents for storage in iCloud.</p></blockquote>

<!--more-->


<h3>4. 关于undo/redo</h3>

<p>UIDocument有undo/redo支持，访问器是注册undo动作最合适的地方，所以document类里，对需要添加undo/redo功能的数据要重写访问器。对不需要undo/redo功能的数据，直接给document用property添加一个model就好。</p>

<h3>5. 整体的实现结构</h3>

<p>以记事本为例，title和content两个model，其中都只包含一个NSString。主视图直接在title，detailViewController再加载content。</p>

<blockquote><p><code>TitleModel</code>和<code>ContentModel</code>都实现<code>NSCoding</code>协议方法，这里可以考虑把<code>VersionNumber</code>encode进去以便后期支持文件格式扩展。
<strong>NoteDocument.h</strong></p>

<blockquote><p><code>@property (nonatomic, strong) TitleModel *titleModel;
//这里对ContentModel中的内容实现访问器，原因第4条有，方便undo/redo</code>
<code>- (NSString *)contentString;</code><br/>
<code>- (void)setContentString:(NSString *)str;</code></p></blockquote>

<p><strong>NoteDocument.m</strong></p>

<blockquote><ul>
<li>类扩展里定义<code>contentModel</code>和<code>fileWrapper</code>(读文件时候用)，<code>titleModel</code>直接放在头文件是因为It’s OK if the user accesses the metadata directly though, as it’s not something the app will modify. Instead, the metadata will be automatically updated when the user sets the photo.</li>
<li>重写<code>loadFromContents</code>和<code>contentsForType</code>，loadFromContents里面self.wrapper = (NSFileWrapper *)contents;给wrapper赋值，contentsForType里面把两个model encode进wrapper</li>
<li>重写<code>titleModel</code>和<code>contentModel</code>两个getter实现Lazy Loading，需要的时候再decode；如果文件不存在则把model初始化为nil</li>
<li>实现ContentModel的content的Accessor来实现undo/redo，在Setter里面执行如下代码块：
```objective-c
if ([self.contentModel.content isEqual:str]) {
  return;
}</li>
</ul>
</blockquote></blockquote>

<p>NSString *oldContent = self.contentModel.content;
self.contentModel.content = str;</p>

<p>[self.undoManager setActionName:@&ldquo;Content Change&rdquo;];
[self.undoManager registerUndoWithTarget:self selector:@selector(setContentString:) object:oldContent];
```</p>

<h2>其他</h2>

<h3>1. 设备旋转支持</h3>

<p>好多大厂的App居然也能支持反过来操作，真是不可理解。代码摘自引用博文实现的工程。
```objective-c
&ndash; (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation
{</p>

<pre><code>return (interfaceOrientation != UIInterfaceOrientationPortraitUpsideDown);
</code></pre>

<p>}
```</p>

<h3>2. Undo/Redo</h3>

<p><a href="http://blog.163.com/chenchen..1986/blog/static/760631462013222314817/">这里</a>的例子简单有效。</p>

<h3>3. 自己画的大致思路，实际实现没这么做。</h3>

<p><img src="/blogimage/2014/useuidocument.jpg" alt="useuidocument" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读Inkpad源代码]]></title>
    <link href="http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code/"/>
    <updated>2014-03-30T19:55:11+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/sprang/Inkpad">Inkpad</a>是一个开源的基于OpenGLES的画矢量图的App，这篇博文记录阅读其源代码时的收获。</p>

<h3>0. 内联函数的使用</h3>

<p>内联函数只是给编译器的提示，最终能不能内联还要看编译器。</p>

<h4>(1)相同点</h4>

<p><code>static inline double radians (double degrees) { return degrees * M_PI/180; }</code>；都是在与处理阶段对代码块进行替换。</p>

<h4>(2)不同点</h4>

<p>内联函数是值传递，宏定义是简单替换。内联函数有类型检查，此外<code>省去了很多函数调用汇编代码如：call和ret等</code>。<br/>
<code>#define MAX(a, b) a&gt;b?a:b</code>如果<code>MAX( num1, num2 )</code>就没问题，但是如果是<code>MAX( 17+32, 25+21)</code>，展开后是<code>17+32&gt;25+21?17+32:25+21</code>。甚至<code>#define A 2+3</code>，然后<code>c = 4 * A</code>都会成为<code>4 * 2 + 3</code>。比较安全的写法是<code>#define MAX( (a), (b) ) (a)&gt;(b)?(a)b)</code>，但是这样还是有问题，<code>MAX(i++,j++)</code>完了每个都会加2了。
宏定义执行快是因为没有<code>函数调用</code>的开销，但是如果宏用的多文件就会变很大，执行文件太大可能导致执行时换页频繁（略夸张）。</p>

<h3>1. 一些简洁的写法</h3>

<ul>
<li><p><code>CGRectGetWidth</code>，以前总是写成<code>self.frame.size.width</code>。此外还有<code>CGRectGetMidX</code>，直接得到矩形中心点的X坐标。</p>

<pre><code>  CGPointMake(CGRectGetWidth(frame) / 2, CGRectGetHeight(frame) / 2);
</code></pre></li>
<li><p><code>[NSDictionary objectForKey]</code>，可以直接<code>dictionary[key]</code>。</p></li>
<li><p><code>BOOL isolate</code>转NSString，<code>@(isolate)</code>。NSArray的类似写法：</p>

<pre><code>  NSArray *items = @[actionItem_, gearItem_, albumItem_, zoomToFitItem_];
</code></pre></li>
</ul>


<h3>2. Best Practice</h3>

<h4>(1) “帮助”、“关于”视图</h4>

<p>应用的<strong><code>帮助</code></strong>, <strong><code>关于</code></strong>等信息可以做成html页面。建立本地文件夹，在其中放置html、图片、css等，然后直接<code>self.view = webview;</code>即可。</p>

<!--more-->


<p>```objective-c
&ndash; (NSURL *) helpURL
{</p>

<pre><code>NSString *resource = NSLocalizedString(@"index", @"Name of Help html file");
NSString *path = [[NSBundle mainBundle] pathForResource:resource ofType:@"html" inDirectory:@"Help"];
return [NSURL fileURLWithPath:path isDirectory:NO];
</code></pre>

<p>}
&ndash; (void)loadView
{</p>

<pre><code>UIWebView *webView = [[UIWebView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
webView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
self.view = webView;
[webView loadRequest:[NSURLRequest requestWithURL:[self helpURL]]];
</code></pre>

<p>}
```</p>

<h4>(2) 应用“设置”功能</h4>

<p>以“显示网格”这一设置项为例，通过<code>UILable  UISwitch</code>来实现。其实可以全部通过NSUserDefaults实现，但inkpad中有个NSMutableDictionary的settings_作为”中间变量“:</p>

<ul>
<li>可能是考虑到在初始化时一次读取NSUserDefaults而不是需要属性就去查NSUserDefaults更好;</li>
<li>还有个原因就是每个drawing都会把settings_当做Document的一部分进行存储，NSMutableDictionary才能去存储。</li>
</ul>


<p>在<code>WDDrawingController</code>中有<code>WDPropertyManager</code>。除了下面的示例代码，很多属性的管理都在这里，<strong>区别是</strong>settings<em>只管理<code>设置</code>视图里能改变的属性，并且其值会被存储到document里，跟单独drawing相关；<del>而propertyManager管理<code>应用状态</code>，比如不选路径的时候“路径”的popover tableView里就全部不可用，如添加锚点、合并路径。</del>
```objective-c
// constantly updating the user defaults kills responsiveness after the keyboard has been made visible
// so use this temporary dictionary to avoid hitting the defaults all the time<br/>
NSMutableDictionary *defaults</em> = [[NSMutableDictionary alloc] init];//in init</p>

<p>//&ndash; (void) didEnterBackground:(NSNotification *)aNotification
&ndash; (void) updateUserDefaults
{</p>

<pre><code>for (NSString *key in [defaults_ allKeys]) {
    [[NSUserDefaults standardUserDefaults] setObject:defaults_[key] forKey:key];
}
</code></pre>

<p>}
<code>
相关代码如下：
</code>objective-c
//属性设置-在“设置”界面控件响应方法中
//WDSettingsController
&ndash; (void) takeShowGridFrom:(id)sender
{</p>

<pre><code>UISwitch    *mySwitch = (UISwitch *)sender;

[[NSUserDefaults standardUserDefaults] setBool:mySwitch.isOn forKey:WDShowGrid];
[[NSUserDefaults standardUserDefaults] synchronize];

drawing_.showGrid = mySwitch.isOn;//Setter方法
</code></pre>

<p>}</p>

<p>//属性管理的中间类-在Accessor中设置和应用，发送通知最终应用设置
//WDDrawing:NSObject
&ndash; (void) setShowGrid:(BOOL)showGrid
{</p>

<pre><code>settings_[WDShowGrid] = @(showGrid);//settings_是NSMutableDictionary，WDShowGrid是NSString “WDShowGrid”
[[NSNotificationCenter defaultCenter] postNotificationName:WDDrawingChangedNotification object:self];

// this isn't an undoable action so it does not dirty the document
[self.document markChanged];
</code></pre>

<p>}</p>

<ul>
<li>(BOOL) showGrid
{
  return [settings_[WDShowGrid] boolValue];
}</li>
</ul>


<p>//属性改变的即时应用-接收通知并通过setNeedsDisplay处发drawRect重绘
//WDCanvas
&ndash; (void) invalidateFromNotification:(NSNotification *)aNotification
{</p>

<pre><code>NSValue     *rectValue = [aNotification userInfo][@"rect"];
NSArray     *rects = [aNotification userInfo][@"rects"];
CGRect      dirtyRect;
float       fudge = (-1.0f) / viewScale_;

if (rectValue) {
    //...
} else if (rects) {
    //...
} else {//没有任何userInfo，对应showGrid这一属性的改变
    [self setNeedsDisplay];
}
</code></pre>

<p>}</p>

<ul>
<li>(void)drawRect:(CGRect)rect
{
  //&hellip;
  if (drawing_.showGrid &amp;&amp; !drawingIsolatedLayer) {
      [self drawGrid:ctx];
  }
  //&hellip;
}</li>
</ul>


<p>//属性的保存-主要在WDSettingsController，设置并同步
借助NSUserDefaults</p>

<p>//属性的加载-各种init方法中从NSUserDefaults初始化settings_
//WDDrawing
&ndash; (id) initWithSize:(CGSize)size andUnits:(NSString *)units
{</p>

<pre><code>// each drawing saves its own settings, but when a user alters them they become the default settings for new documents
// since this is a new document, look up the values in the defaults...
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
NSArray *keyArray = @[WDShowGrid, WDSnapToGrid, WDSnapToPoints, WDSnapToEdges, WDDynamicGuides, WDRulersVisible];
for (NSString *key in keyArray) {
    settings_[key] = @([defaults boolForKey:key]);
}
</code></pre>

<p>}
```</p>

<h3>3. <code>NSNotification</code>的名字应该在哪定义</h3>

<p>在<code>WDToolManager.m</code>中，<code>NSString *WDActiveToolDidChange = @"WDActiveToolDidChange";</code>，然后在头文件中<code>extern NSString *WDActiveToolDidChange;</code>。一般来说关心这个通知（当前工具改变）的类都引用了这个类的头文件，这样比放在一个<code>ConstantsDefine.h</code>里要好。</p>

<h3>4.枚举定义中为什么要用左移</h3>

<p>这里解释的很详细<a href="http://stackoverflow.com/questions/3999922/why-use-the-bitwise-shift-operator-for-values-in-a-c-enum-definition">Why use the Bitwise-Shift operator for values in a C enum definition?</a>。如果用</p>

<pre><code>typedef enum { WDToolDefault, WDToolShiftKey, WDToolOptionKey }  
</code></pre>

<p>那么<code>WDToolDefault | WDToolShiftKey</code>就是<code>1 | 2</code>会得到3！！用左移就不会有这个问题，就是<strong><em>可以在一个变量中支持多个枚举值</em></strong>（将其相加或者取或），判断的时候取与。</p>

<pre><code>typedef enum {
    WDToolDefault           = 0,
    WDToolShiftKey          = 1 &lt;&lt; 0,
    WDToolOptionKey         = 1 &lt;&lt; 1,
    WDToolControlKey        = 1 &lt;&lt; 2,
    WDToolSecondaryTouch    = 1 &lt;&lt; 3
} WDToolFlags;  
</code></pre>

<h3>5. 子类不能重写touchesBegan但要在其发生同时完成处理</h3>

<p><code>FingerTackerView</code>重写<code>touchesBegan</code>等等方法，然后在其内部进行一些操作后调用<code>[self methodForSubclassOverwritten]</code>，这个方法可以置空。<code>HandWritingView</code>，<code>GestureEditorView</code>等继承自<code>FingerTrackerView</code>的类里重写<code>[self methodForSubclassOverwritten]</code>，这样就能在采集点的同时，对点的处理根据当前选择功能（即所处的视图）来由对应的子类来处理。子类不会出现<code>touchesBegan</code>等，但是可以通过重写方法来实现手势运动时处理。</p>
]]></content>
  </entry>
  
</feed>
