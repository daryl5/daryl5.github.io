<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Daryl's Blog]]></title>
  <link href="http://daryl5.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://daryl5.github.io/"/>
  <updated>2014-07-30T09:23:18+08:00</updated>
  <id>http://daryl5.github.io/</id>
  <author>
    <name><![CDATA[Daryl5]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Make A Swipeable TableviewCell]]></title>
    <link href="http://daryl5.github.io/blog/2014/06/25/swipeable-table-view-cell/"/>
    <updated>2014-06-25T19:59:06+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/06/25/swipeable-table-view-cell</id>
    <content type="html"><![CDATA[<p>来自RW的博文<a href="http://www.raywenderlich.com/62435/make-swipeable-table-view-cell-actions-without-going-nuts-scroll-views">How To Make A Swipeable Table View Cell With Actions – Without Going Nuts With Scroll Views</a>。</p>

<!--more-->


<h3>1.UITableViewCell结构解析</h3>

<p><code>给view添加背景色</code>和<code>recursiveDescription</code>都可以用来解析控件结构。
```objective-c</p>

<h1>ifdef DEBUG</h1>

<p>NSLog(@&ldquo;Cell recursive description:\n\n%@\n\n&rdquo;, [cell performSelector:@selector(recursiveDescription)]);</p>

<h1>endif</h1>

<p><code>
iOS7上tableViewCell的结构如下：
</code>objective-c
TableViewCell</p>

<pre><code>CellScrollView
    //SeparatorView
    Button                 disclosure button
        ImageView          button's image
    ContentView
        Label              cell text label
    //SeparatorView
</code></pre>

<p><code>
删除时候结构如下：
</code>objective-c
TableViewCell</p>

<pre><code>CellScrollView
    DeleteConfirmationView
        Confirmation Button
            Label          "Delete"
    //SeparatorView
    ContentView
        Label
    //Separator View
    Button
        ImageView
</code></pre>

<p><code>
iOS8上如下，对比iOS7主要是少了`UITableViewCellScrollView`，这是个UIScrollView的实例：
</code>objective-c
TableViewCell</p>

<pre><code>ContentView
    Label                  cell text label
//SeparatorView
Button
    ImageView
</code></pre>

<p>```
根据官方文档，自定义cell只能在ContentView上添加subview。我们要做的，就是参照苹果实现滑动展示删除按钮的思路，在ContentView上另外实现一套，然后把原本的删除禁掉。</p>

<h3>2.一个Swipeable TableViewCell的必要成分</h3>

<p>由上一部分最后一段可以知道，我们需要一些<code>需要展示的UIButton</code>，然后一个位于这些按钮之上的<code>Container view</code>来显示所有内容，然后需要一个UIScrollView或者<code>UIPanGestureRecognizer</code>来显示或者隐藏按钮，这里我们用后者。最后，<code>需要展示cell内容的views</code>。然后把这些内容都贴到cell的ContentView上。这里有点拗口，对应上面iOS7的cell结构。<br/>
需要禁掉系统cell的滑动删除：
```objective-c
&ndash; (BOOL)tableView:(UITableView <em>)tableView canEditRowAtIndexPath:(NSIndexPath </em>)indexPath {</p>

<pre><code>return NO;
</code></pre>

<p>}
```</p>

<h3>3.建立自定义cell</h3>

<p>直接在storyboard中编辑prototypecell，然后绑定cell所属类，并在tableview代理中返回相应的类型。这里非常坑，半天显示不出来两个按钮，基础太差代码写的太少了，哎。原因见<a href="http://stackoverflow.com/questions/22352587/xcode-5-1-uitableview-in-uiviewcontroller-custom-tableviewcell-outlets-are-nil">Xcode 5.1 UITableView in UIViewController &ndash; Custom TableViewCell Outlets are nil</a>。具体原因是：</p>

<ol>
<li>如果在xib或者storyboard中建立cell了，那么直接deque就能获得cell；</li>
<li>如果要用自定义的cell，那么就要先registerclass，然后重用的时候deque；这时候虽然没有xib，但是运行时也知道如何去建立cell，就用刚注册过的类建立。</li>
</ol>


<p>未完待续&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Language Highlights: An Objective-C Developer’s Perspective]]></title>
    <link href="http://daryl5.github.io/blog/2014/06/06/swift-language-highlights-an-objc-develpers-perspective/"/>
    <updated>2014-06-06T13:57:06+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/06/06/swift-language-highlights-an-objc-develpers-perspective</id>
    <content type="html"><![CDATA[<!--more-->


<p><a href="http://www.raywenderlich.com/73997/swift-language-highlights">原文</a>是RW Tutorials里Matt Galloway写的，跟之前自己写的<a href="http://daryl5.github.io/blog/2014/04/24/introduction-to-cplusplus-for-ios-developers/">Introduction to C++ for iOS Developers</a>类似，这篇文章是站在Objc开发者的角度来看Swift。这种通过比较两种语言的特性来学习的方法，我认为是最好的。</p>

<h4>1.Types</h4>

<p>a.Swift引入了<a href="http://en.wikipedia.org/wiki/Type_inference">Type Inference</a>，开发者不需要显式指定变量类型，<code>编译器</code>会根据变量被赋的值来推断变量的类型，如下例。
<code>objective-c
// automatically inferred
var name1 = "Matt"
// explicit typing (optional in this case)
var name2:String = "Matt"
</code>
Swift还引入了<a href="http://en.wikipedia.org/wiki/Type_safety">Type Safety</a>。在Swift中，大多数情形下编译器明确知道一个对象所属的类型，这使得编译器能够在编译期间做更多的事，比如优化。其他少数情形可以参考C++中的<a href="http://en.wikipedia.org/wiki/Vtable">虚表</a>适用情形。<br/>
b.Objc是<code>Dynamic Typing</code>的，编译期间不会知道变量类型，<code>运行时</code>负责处理对象类型分析、消息分派等。这使得我们拥有在运行时给一个类动态添加方法等等黑魔法。
<code>objective-c
Person *matt = [[Person alloc] initWithName:@"Matt Galloway"];
[matt sayHello];
</code>
对上面的代码，编译器会去Person类的头文件去查看是否有sayHello方法，但是只会进行最简单的方法存在确认，由于Objc的动态特性，编译器不知道sayHello方法是否会在运行时改变，甚至不知道sayHello到底有没有实现。这种情形需要手动调用<code>respondsToSelector:</code>来检查。<br/>
正是因为这种动态类型的特性，编译器能做的优化很少。系统用<code>objc_msgSend</code>来处理方法调度，在这个方法中运行时会根据调用方法的selector去寻找其对应实现并调用。这个过程增加了一些开销。<br/>
c.下面分析Swifit对于类型的处理，如下例。
<code>python
var matt = Person(name:"Matt Galloway")
matt.sayHello()
</code>
编译器明确知道matt是Person类的实例，并知道sayHello方法具体定义在哪儿。那么在编译时就可以优化使得运行时能直接跳到方法实现的地方，而不需要动态调用。在其他特殊情形下，会利用类似C++<a href="http://en.wikipedia.org/wiki/Vtable">虚表</a>的机制来实现，这虽然增加了一些开销但是比<code>Dynamic Dispatch</code>少了很多。</p>

<blockquote><p>总的来说：<br/>
The compiler is much more helpful in Swift. It will help stop subtle type related bugs from entering your codebase. It will also make your code run faster by enabling smart optimisations.</p></blockquote>

<h4>2.Generics</h4>

<p>Swift引入了<a href="http://en.wikipedia.org/wiki/Generic_programming">泛型</a>，类似C++中的<code>模板</code>。这里有引文：</p>

<blockquote><p> Swift is strict about types, you must declare a function to take parameters of certain types. But sometimes you have some functionality that is the same for multiple different types.</p></blockquote>

<p>```objective-c
struct IntPair {</p>

<pre><code>let a: Int!
let b: Int!

init(a: Int, b: Int) {
    self.a = a
    self.b = b
}

func equal() -&gt; Bool {
    return a == b
}
</code></pre>

<p>}</p>

<p>let intPair = IntPair(a: 5, b: 10)
intPair.a // 5
intPair.b // 10
intPair.equal() // false
<code>
如果还需要一个FloatPair的话，就需要用到泛型了。
</code>objective-c
struct Pair&lt;T: Equatable> {</p>

<pre><code>let a: T!
let b: T!

init(a: T, b: T) {
    self.a = a
    self.b = b
}

func equal() -&gt; Bool {
    return a == b
}
</code></pre>

<p>}</p>

<p>let pair = Pair(a: 5, b: 10)
pair.a // 5
pair.b // 10
pair.equal() // false</p>

<p>let floatPair = Pair(a: 3.14159, b: 2.0)
floatPair.a // 3.14159
floatPair.b // 2.0
floatPair.equal() // false
```</p>

<h4>3.Containers</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Objective-C高级编程』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/05/10/pro-multithreading-and-memory-management-for-ios-and-os-x/"/>
    <updated>2014-05-10T19:20:32+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/05/10/pro-multithreading-and-memory-management-for-ios-and-os-x</id>
    <content type="html"><![CDATA[<!--more-->


<h1>第一章 ARC</h1>

<h2>1.2 内存管理</h2>

<h4>1.2.2 ARC进行内存管理的思考方式</h4>

<ul>
<li>自己生成的对象，自己持有（alloc/new/copy/mutableCopy了就也retain了）</li>
<li>非自己生成的对象，自己也能持有（retain）</li>
<li>自己不再需要持有的对象时释放（release）</li>
<li>非自己持有的对象无法释放（没retain/alloc/new/copy/mutableCopy就不能release）</li>
</ul>


<p>1.OC的内存管理方法实际上不在OC语言里，而是包含在Cocoa框架中的。（OC是C的超集，Cocoa是对OC加了内存管理、多媒体、网络通讯等等的类库形成的用来给OS X开发应用的框架，Cocoa Touch是对Cocoa进行移动适配形成的另一套OC的类库）<br/>
2.Cocoa框架中Foundation框架类库中的NSObject类担负内存管理的职责，内存管理调用的alloc、retain等方法指代的就是NSObject类中的alloc类方法、retain实例方法等。（所有对象继承自NSObject，alloc、retain等内存管理方法在NSObject中实现，这也就是为什么初始化对象时候要先[super init]以及dealloc最末要[super dealloc]）<br/>
3.<code>[NSObject new</code>和<code>[[NSObject alloc] init]</code>是完全等价的。<br/>
4.类似<code>id obj = [NSMutableArray array]</code>这样的生成的类对象并不会被obj所持有，也就是说这行代码里不包含<code>[obj retain]</code>(有<code>[obj autorelease]</code>)，总是这么写不过都是在ARC下，没意识到这个问题。如果是手动管理，加retain就好。</p>

<h4>1.2.3 alloc/retain/release/dealloc实现</h4>

<p>1.NSZone是为了防止内存碎片化而引入的结构。如果分配几块内存依次是小大小大小大，这样释放所有的“小”之后就形成了碎片，所以要有一大一小两种<code>区域</code>，小的去小的大的去大的。<br/>
<strong>现在的运行时的内存管理已经很高效，使用NSZone反而可能会降低效率或使源代码复杂，所以运行时都会忽略NSZone</strong>。<br/>
2.GNUstep是Cocoa框架的互换框架，两者实现不一定相同不过行为是一样的，这一节主要通过读GNUstep中<code>NSObject.m</code>中alloc、retain等方法的源代码来深入了解内存管理。<br/>
3.GNUstep使用<code>内存块头部管理引用计数</code>，苹果使用<code>引用计数表</code>管理引用计数。</p>

<h4>1.2.5 autorelease</h4>

<p>1.和C语言的<code>局部变量(Automatic Variable)</code>类似，如在函数内定义的int，除了函数就废掉了。autorelease的作用范围是NSAutoreleasePool，在<code>[pool drain]</code>时每个调用过autorelease的对象都会调用release。
2.只要不drain pool，生成的对象就不会被释放，内存就越来越少，所以在for循环里如果有很多autorelease对象那就定义一个NSAutoreleasePool来降低内存峰值。
3.Cocoa框架也有很多类方法会返回autorelease的对象。如<code>[NSMutableArray arrayWithCapacity:1]</code>等效于<code>[[[NSMutableArray alloc] initWithCapacity:1] autorelease]</code>。</p>

<h3>1.2.6 autorelease的实现</h3>

<p>1.本质就是<code>调用NSAutoreleasePool的addObject方法</code>。<br/>
2.NSAutoreleasePool的管理应该用的是栈，一个pool是就是栈中的一个项目。</p>

<h2>1.3 ARC规则</h2>

<h4>1.3.3 所有权修饰符</h4>

<p>1.ARC有效时，一共有4种修饰符：</p>

<ol type="a">
<li>__strong</li>
<li>__weak</li>
<li>__unsafe__unretained</li>
<li>__autoreleasing</li>
</ol>


<p>2.所有id和对象都必须加上所有权修饰符，默认是<em>_strong，也就是说:
<code>objective-c
//这两个等效
id obj = [[NSObject alloc] init];
id __strong obj = [[NSObject alloc] init];
</code>
3.所谓强/弱引用实际就是<code>指针对一块内存（或者说一个对象）的引用</code>。<br/>
强引用就是，别人可以release，但是运行时不能销毁这个对象，因为我还强引用着呢。其实就是给retainCounter加了1，所以对象不会被销毁，除非自己再去调用release。<br/>
弱引用就是我在用但是我没给引用计数加1，别人release了我也就用不了了。<br/>
4.简单总结<br/>
<code>ARC实现方式</code><br/>
GNUstep中每个对象头部都存储着自身的引用计数；<br/>
Apple用runtime统一存储所有对象的引用计数，用的是哈希表，以对象地址作为key，引用计数值和真正的内存地址作为值。有一个好处，即使因为故障导致对象所在内存被破坏，但只要引用计数表还在，就能确认内存块位置（这里真的没太懂，可以参考下面__weak的部分，存储指针的地址）。<br/>
<code>__autoreleasing</code><br/>
用该关键词修饰的变量会被注册到autoreleasepool；<br/>
当方法名不是alloc/new/copy/mutablecopy时候，如果要返回object，这个object会被注册到autoreleasepool；<br/>
访问_</em>weak修饰的变量时，该变量会被注册到autoreleasepool，以确保不会因为原有对象被释放而非法访问，因为只要pool还在，该对象都是有效的。<br/>
<code>__weak</code><br/>
也称智能指针，因为当对象被release时候指针会被置nil。<br/>
实现原理是：本质也是<code>哈希表</code>，把对象地址作为key，然后把指向对象的指针的地址（可能有多个指针都指着）作为value。这样当release对象的时候就在weak表中找到所有指向该对象的指针的地址，进而将所有指针都设置为nil。然后还会在weak表中删除该键值对。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Practices & Tips]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c/"/>
    <updated>2014-04-23T19:19:22+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c</id>
    <content type="html"><![CDATA[<!--more-->


<h3>4.用block实现代理</h3>

<p>关于block的大致介绍，<a href="http://onevcat.com/2011/11/objective-c%E4%B8%AD%E7%9A%84block/">Objective-C中的Block</a>这篇博文写的挺好。其中提到的一点需要注意，如下：
```objective-c
int price = 1.99;</p>

<p>float (^finalPrice)(int) = ^(int quantity) {</p>

<pre><code>//Price is accessible here
return quantiy * price;
</code></pre>

<p>}</p>

<p>int orderQuantity = 10;
//Ordering 10 units, final price is: $19.90
NSLog(@&ldquo;Ordering %d units, final price is: $%2.2f&rdquo;, orderQuantity, finalPrice(orderQuantity));</p>

<p>price = .99;
//Ordering 10 units, final price is: $19.90
NSLog(@&ldquo;Ordering %d units, final price is: $%2.2f&rdquo;, orderQuantity, finalPrice(orderQuantity));
```</p>

<blockquote><p>可以理解为在block内的price是readonly的，只在定义block时能够被赋值（补充说明，实际上是因为price是value type，block内的price是在申明block时复制了一份到block内，block外面的price无论怎么变化都和block内的price无关了。如果是reference type的话，外部的变化实际上是会影响block内的）。</p></blockquote>

<p>解决办法有两种：<br/>
1.将局部变量声明为__block，表示外部变化将会在block内进行同样操作;<br/>
2.使用实例变量。关于这点有引文：</p>

<blockquote><p>这个比较没什么好说的，实例内的变量横行于整个实例内..可谓霸道无敌…=_=
block外的对象和基本数据一样，也可以作为block的参数。而让人开心的是，block将自动retain传递进来的参数，而不需担心在block执行之前局部对象变量已经被释放的问题。这里就不深究这个问题了，只要严格遵循Apple的thread safe来写，block的内存管理并不存在问题。（更新，ARC的引入再次简化了这个问题，完全不用担心内存管理的问题了）</p></blockquote>

<p>这里有个问题就是：因为block会自动retain传进来的参数，所以会出现<a href="http://stackoverflow.com/questions/14556605/capturing-self-strongly-in-this-block-is-likely-to-lead-to-a-retain-cycle">capturing self strongly in this block is likely to lead to a retain cycle</a>的问题，即就是传进去<code>self.xxx</code>之后，会retain self，即构成了循环引用。解决办法是定义一个<code>__weak</code>的self然后在block中使用。</p>

<p><strong>回到正题，block代替protocol</strong>
```objective-c
//In DRDHandWriting.h
typedef void(^didFinishWriting)(NSMutableArray *);
@property (copy, nonatomic) didFinishWriting didFinishWritingBlock;//注意这里是copy</p>

<p>//In DRDHandWriting.m
//Submit charUnitArray to Document
self.didFinishWritingBlock(segmentedCharUnitArray);</p>

<p>//In DRDManuscriptController::loadHandWritingView
handWritingView = [[DRDHandWriting alloc] initWithFrame:handWritingRect];
__weak DRDManuscriptController <em>weakSelf = self;
//这里的参数只是被代理对象需要返回给代理的数据，具体就是手写视图需要返回切分好的字符给controller
//另一种情形就是多个AlertView的代理，这里就可以传回当前alertView
[handWritingView setDidFinishWritingBlock:^(NSMutableArray </em>segmentedArray) {</p>

<pre><code>[weakSelf.document addOrInsertCharUnitArray:segmentedArray];
</code></pre>

<p>}];
```
关于上例中block的copy，有<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">官方文档</a>：</p>

<blockquote><p>Note: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. For more information, see Blocks Programming Topics.</p></blockquote>

<p>block在创建的时候是分配在栈上的，如果<code>retain</code>（栈上的东西不能retain），在调用block的时候程序就会崩溃，实际上ARC下测试了一下retain，只是代码编辑阶段即给出警告<code>Retain'ed block property does not copy the block - use copy attribute instead</code>并且程序正常运行。而如果是<code>copy</code>，将会把这个block拷贝到堆里，同时retain这个block所引用的所有东西。block在堆上的时候进行copy就没事，不会再拷贝一遍，只是相当于retain。这段摘自<a href="http://blog.refractalize.org/post/10476042560/copy-vs-retain-for-objective-c-blocks">Copy vs retain for Objective-C blocks</a>。</p>

<p><strong>结论：</strong><br/>
自己实验了一下上面那个改变price输出总价不变的例子，block在创建的时候是分配在栈上的。<br/>
1.如果block里用到了局部变量，那么就会拷贝一份：比如<code>int a = 5</code>就会拷贝一个int变量其值为5；如果是<code>int *ptr = 5</code>就会拷贝ptr这个指针，这样改变*ptr的值，block里也会跟着变。<br/>
2.如果用到了实例变量，那么不管是value type还是指针型的，都不会出现外部更新而block内部没跟着变的情况，猜想是因为block引用实例变量其实就是对self指针的弱引用，用到实例变量时候用指针去读的。<br/>
3.上面<code>capturing self strongly in this block is likely to lead to a retain cycle</code>这一问题，是因为用到了实例变量。两种情况：如果是property那么隐含<code>self.propertyXXX</code>；如果是非property的实例变量，隐含<code>self-&gt;iVar</code>，都有self。因为是用block实现代理，那么需要传block给被代理对象，被代理对象copy block，同时运行时会copy block到堆上并retain block里所有的东西，这就相当于被代理对象里声明了一个<code>@property (strong, nonatomic) id&lt;XXXProtocol&gt; delegate</code>，所以就造成了循环引用。上面那个SO的链接讲得很清楚。<br/>
4.最后，什么时候用block什么时候用delegation，<a href="http://stablekernel.com/blog/blocks-or-delegation/">Blocks or Delegation</a>讲了，实在不想看了，先马克- -！</p>

<h3>3.Category也能Conform to a protocol</h3>

<h3>2.对集合中每个对象发送消息</h3>

<p><code>objective-c
// remove all subviews
[[self.scrollView subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)];
</code></p>

<h3>1.<a href="http://ironwolf.dangerousgames.com/blog/archives/913">The Code Commandments: Best Practices for Objective-C Coding </a></h3>

<p><strong>a.在实例变量前加<code>@private</code></strong>[放在类扩展就好]</p>

<ul>
<li>表明该变量与API无关</li>
<li>默认是<code>@protected</code>即就是子类可以访问，如果子类不需要那就不要暴露，面向对象的<code>信息隐藏</code>，（其实最好的应该是子类和其他类用到的在.h，私有变量和方法在类扩展）</li>
</ul>


<p><strong>b.为每一个<code>data member</code>创建<code>@property</code>，在.m中都用<code>self.name</code>来访问</strong>[这个有问题]</p>

<ul>
<li>property会把访问权限加入，如readonly</li>
<li>property会把内存管理加入，strong&amp;weak</li>
</ul>


<p><strong>c.<code>实例变量</code>就是只给当前类及其子类使用，<code>@property</code>就是外部类也能用</strong><br/>
之前看到在头文件里interface部分定义实例变量，同时又用@property重新写一遍。对于想要公开给这个类及其子类以外的类的实例变量，那么就为其写一个对应的property。<br/>
<strong>d.关于<code>readonly</code></strong>
就是说这个property在外界不能修改，如<code>self.document.displayHeight</code>会产生<code>assign to readonly property</code>。在类的实现文件里可以通过实例变量来修改，如<code>_displayHeight = 600</code>，此外，在实现文件还可以通过<code>self-&gt;_displayHeight = 600</code>来修改，这里之所以用->大概是因为类本身拥有这个实例变量就意味着类的实例有一个指向这个实例变量的指针，而property只是用于公开给外部，在这里没property什么事。
另外还可以在类扩展里告诉编译器我还需要一个setter，但只是在实现文件里：
<code>objective-c
//公有可读，私有可写
@interface YourClass ()
@property (nonatomic, copy) NSString* eventDomain;
@end
</code>
这个问题在<a href="http://stackoverflow.com/questions/4586516/readonly-properties-in-objective-c">Readonly Properties in Objective-C?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Effective Objective-C 2.0』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0/"/>
    <updated>2014-04-07T13:22:29+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0</id>
    <content type="html"><![CDATA[<p>《Effective Objective-C 2.0：52 Specific Ways to Improve Your iOS and OS X Programs》 作者：<a href="http://www.galloway.me.uk/">Matt Galloway</a></p>

<!--more-->


<h2><strong>1: Accustoming Yourself to Objective-C</strong></h2>

<h3>Item 2: 缩减头文件&mdash;Minimize Importing Headers in Headers</h3>

<p>a.如下引文，试了一下互相import，没有报错- -！</p>

<blockquote><p>The use of #import rather than #include doesn&rsquo;t end in an infinite loop but does mean that one of ther classes won&rsquo;t compile correctly.</p></blockquote>

<p>b.协议相关<br/>
一些代理相关的协议，可以把协议头文件在.m文件里再引入，把代理<code>id&lt;XXXProtocol&gt; delegate</code>定义放在类扩展里。
也可以考虑单独创建一个头文件，里面只放协议定义。</p>

<!--more-->


<h3>Item 3: 使用字面量语法而不是其等价方法&mdash;Prefer Literal Syntax over the Equivalent Methods</h3>

<p>a.字面量使用</p>

<pre><code>NSString *str           = @"Test String";
NSNumber *boolValue     = @YES;
NSNumber *charValue     = @'a';
NSNumber *expressionVal = @(x * y);//int x &amp; float y

NSArray *animals        = @[@"cat", @"dog"];
NSString *dog           = animails[1];//下标直接访问

NSDictionary *person    = @{@"firstName" : @"Matt", @"age" : @28};
NSString *firstName     = person[@"firstName"];//key值直接访问value

//Assign value or replace
mutableArray[1] = @"dog";
mutableDictionary[@"lastName"] = @"Galloway";
</code></pre>

<p>b.好处<br/>
如果NSArray用3个object来初始化，第二个是nil，那么arrayWithObjects将会返回一个只包含object1的array，而字面量初始化会报错。<strong>“报错”比“少了个数”更安全。</strong>
对于NSDictonary，初始化会在遇到nil时候停止，dictionaryWithObjectsAndKeys可能会少了某一个value；字面量更安全。<br/>
c.缺点<br/>
字面量语法只能用于Foundation框架的一些类，对于自定义的类没法这样定义（显然）。<br/>
对于mutable对象的定义，需要进行mutableCopy。增加了额外的方法调用和对象创建</p>

<pre><code>NSMutableArray *mutable = [@[@1, @2, @3] mutableCopy];
</code></pre>

<h3>Item 4: 使用类型化常量而不是预处理指令#define&mdash;Prefer Typed Constants to Preprocessor #define</h3>

<p>a.#define的缺点<br/>
预处理指令<code>#define ANIMATION_DURATION 0.3</code>只是在预处理阶段进行<code>替换</code>，它没有包含类型信息。（如果定义在头文件，所有包含该头文件的文件也都会进行替换。）<br/>
b.类型化常量的使用（static const）<br/>
用上编译器让常量有类型信息：<code>static const NSTimerInterval kAnimationDuration = 0.3;</code>
常量命名规范：</p>

<blockquote><p>The usual convertion for constants is to prefix with lettr k for constants that are local to a translation unit(implementation file). For constants that are exposed outside of a class, it is usual to prefix with the class name.<br/>
在.m中定义，对于这个translation unit是局部变量的话用k作前缀；如果要暴露给外界，用类名开头，如EOCViewClassAnimationDuration。</p></blockquote>

<p><code>static</code>关键词说明这个变量对于当前translation unit是局部的，如果没定义为static，编译器将会为其创建一个external symbol，如果另一translation unit声明了一个同名变量，链接器将会报错；<code>const</code>关键词说明不能被修改。</p>

<blockquote><p>A translation unit is the input the compiler receives to generate one object file. In OC, this usually means that there is one translation unit per class: every .m file.</p></blockquote>

<p>SO的一个问题：<a href="http://stackoverflow.com/questions/11382502/how-different-static-variable-declarations-in-objective-c">How different static variable declarations in Objective-C?</a><br/>
c.类型化常量的使用（extern）<br/>
跟<code>NSNotification</code>相关，通知名应该这样处理：</p>

<pre><code>// In .h
// extern--"Trust me, there's a variable called EOCStringConstant declared in another file"
// EOC是类名
extern NSString *const EOCStringConstant;

// In .m
//反着读：EOCStringConstantis a const pointer point to NSString
NSString *const EOCStringConstant = @"NotificationName";
//如果不是对象那这里是const NSTimeInterval EOCAnimated...
</code></pre>

<p>d.总结<br/>
类型化常量有类型- -！
类型化常量借助编译器来确保常量的一致性（const），预处理指令#define可以在别的地方重定义。<br/>
.m的局部变量如动画时间等用k开头放在.m文件里用static；通知名等用类名+通知名，.m里声明+定义，.h里extern，如UIApplication类里声明+定义的UIApplicationDidEnterBackGroundNotifation。</p>

<h2><strong>2: Objects, Messaging, and the Runtime</strong></h2>

<h3>Item 6: 理解Properties-Understand Properties【需要再看】</h3>

<p>a.自己写了Accessor中的一个，编译器将会synthesize另一个，LazyLoading就是这样的。如果不想让编译器自动synthesize，可以用<code>@dynamitc</code>指令，这样编译器不会生成Accessor和对应的实例变量名，而且编译时候编译器会忽略Accessor还没有被定义但是已经在self.property，编译器会认为Accessor在runtime时会有的。<br/>
b.<code>weak</code>不会release旧值，也不会retain新值，类似assign，不过这个property所指对象被销毁时，这个property会被nilled out。<br/>
<code>unsafe_unretained</code>也和assign类似，只是关于object的assign，unretained对应nonowning，unsafe对应不会被nilled out，这一点和weak不一样。<br/>
<code>copy</code>对应mutable copy，如果不想让对象把传进来的值改变了，应该做一下copy，也就是immutable copy。虽然增加了拷贝操作，但是会更安全。<br/>
c.关于自定义getter名在BOOL上的应用，为了加is为什么不直接把property命名成isXxx。</p>

<h3>Item 7: Access Instance Variables Primarily Directly When Accessing Them Internally</h3>

<p><strong>a.总结</strong></p>

<ol>
<li>一般来说，要读实例变量的时候就直接访问，要写实例变量的时候就用property。</li>
<li>如果在初始化方法（或dealloc）中改变property的值，那么也是直接访问实例变量。因为如果初始化方法也用property，那么父类初始化时候其实会调用子类的初始化方法，可能会产生问题。另外，有时候是必须在初始化方法中使用setter的，比如当实例变量在父类中声明，那子类只能通过setter来访问。</li>
<li>如果property使用了<code>Lazy Loading</code>，那么需要使用getter来获取，不如可能获得空值。</li>
</ol>


<p><strong>b.<code>直接访问</code>和<code>使用property</code>的区别</strong></p>

<ol>
<li>直接访问无需<code>method dispatch</code>那么肯定更快；</li>
<li>直接使用实例变量会绕过property所设置的内存管理策略；</li>
<li>直接访问实例变量，KVO可能不会触发了；</li>
<li>使用property可以方便debug，知道谁在什么时候访问了某一实例变量。</li>
</ol>


<h3>Item 8: Understand Object Equality</h3>

<p>a.有的类实现了判断相等的方法，如NSString的<code>isEqualToString:</code>，这个比<code>isEqual:</code>，因为后者还需要查看所比较对象所属的类。</p>

<h1>看不下去了</h1>

<h3>Item 10: 在既有类中适用关联对象存放自定义数据-Use Associated Objects to Attach Custom Data to Existing Classed</h3>

<p>a.一般都是通过<code>继承</code>来给既有类添加数据，但行不通的时候就要用到<code>关联对象</code>了。以UIAlertView为例：</p>

<ul>
<li>一般的实现中buttonIndex和其action的对应，即button的定义和其响应方法的声明不在一个地方，这样可读性不好；</li>
<li><p>如果同一个类里有多个alertView，那么在代理方法中还要判断是哪一个，然后再判断buttonIndex；
```objective-c
static const void *EOCMyAlertViewKey = &ldquo;EOCMyAlertViewKey&rdquo;;</p></li>
<li><p>(void)askUserAQuestion {
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&ldquo;Question&rdquo;
                                                  message:@&ldquo;What do you want to do?&rdquo;
                                                 delegate:self
                                        cancelButtonTitle:@&ldquo;Cancel&rdquo;
                                        otherButtonTitles:@&ldquo;Continue&rdquo;, nil];</p>

<p>  void(^block)(NSInteger) = ^(NSInteger buttonIndex) {
      if (buttonIndex == 0) {
          [self doCancel];
      } else {
          [self doContinue];
      }
  };</p>

<p>  objc_setAssociatedObject(alert, EOCMyAlertViewKey, block, OBJC_ASSOCIATION_COPY);</p>

<p>  [alert show];
}</p></li>
</ul>


<p>// UIAlertViewDelegate protocol method
&ndash; (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex {</p>

<pre><code>void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);
block(buttonIndex);
</code></pre>

<p>}
<code>``
b.总结  
关联对象就是把两个object链接在一起了；关联对象只有在其他方法都不可行的时候才使用，因为很容易造成</code>Retain Cycle`；上例中还可以通过继承AlertView并附加这个block对象来实现，如果类中alertView要多次用到，更建议继承而不是关联对象。</p>

<h3>Item 14: 理解类的对象- Understand What a Class Object Is</h3>

<p>a.OC是<code>动态类型</code>的，对象的类型并不是在编译时候进行绑定的，而是在运行时进行查找。</p>

<h2><strong>4: Protocols and Categories</strong></h2>

<h3>Item 23: 通过委托和数据源协议进行对象间通信</h3>

<p>a.有一句话没太懂，这个单词居然查不出来，完了看看Item6，里面有这个单词(尼玛，就是自动设置空的意思，对应weak)：</p>

<blockquote><p>A delegate property will always be defined using either the weak attribute to benefit from <code>autonilling</code> or unsafe_unretained if autonilling is not required.</p></blockquote>

<p>b.在interface中声明遵守协议的话，别的类会知道这一行为，一般把“遵守协议”放在类扩展部分，虽然没太多影响。要知道一个对象是否遵守某个协议可以这样：<code>[self conformsToProtocol:@protocol(DRDHandWritingProtocol)]</code><br/>
c.可以把正在代理的对象也传回给代理，这样方便判断具体是哪个代理对象在调用代理方法。
```objective-c
&ndash; (void)networkFetcher:(EOCNetworkFetcher <em>)fetcher didReceiveData:(NSData </em>)data {</p>

<pre><code>if (fetcher == _myFetcherA) {
    //Handle data
} else if (fetcher == _myFetcherB) {
    //Handle data
}
</code></pre>

<p>}
<code>
d.如果开发API，用代理可以实现一些属性设置，如`- (BOOL)networkFetcher:(EOCNetworkFetcher *)fetcher shouldFollowRedirectToURL:(NSURL *)url;`，甚至这里可以给fetcher传递一个NSDictionary来进行Fetcher一系列属性的设置。  
e.对`@optional`的代理方法，方法调用者负责通过`[delegate respondsToSelector]`确保程序不会崩溃，unrecognized selector。`@required`的话编译器会确认。如果没设置，默认都是required。  
f.对dataSource类的delegate，在获取每一个小的data piece的时候都查询一次respondsToSelector是低效的，应该将当前对象对协议的遵守情况缓存下来。如下：
</code>objective-c
//有个DataModel或者ViewController是该对象的代理
//In class extension
@interface EOCNetworkFetcher() {</p>

<pre><code>struct {
    unsigned int didReceiveData      : 1;
    unsigned int didFailWithError    : 1;
    unsigned int didUpdateProgressTO : 1;
}_delegateFlags;
</code></pre>

<p>}</p>

<p>//In delegate Setter
&ndash; (void)setDelegate:(id<EOCNetworkFetcher>)delegate {</p>

<pre><code>_delegate = delegate;
_delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];
...
</code></pre>

<p>}</p>

<p>//Query if responds to selector (FRENQUENTLY)
if (_delegateFlags.didReceiveData) {</p>

<pre><code>[_delegate networkFetcher:self didReceiveData:dataReceived];
</code></pre>

<p>}
<code>
g.协议的“继承”
</code>objective-c
@protocol A</p>

<pre><code>-(void) methodA;
</code></pre>

<p>@end</p>

<p>@protocol B <A></p>

<pre><code>-(void) methodB;
</code></pre>

<p>@end
```</p>
]]></content>
  </entry>
  
</feed>
