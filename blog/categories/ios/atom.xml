<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Daryl's Blog]]></title>
  <link href="http://daryl5.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://daryl5.github.io/"/>
  <updated>2014-05-22T14:41:57+08:00</updated>
  <id>http://daryl5.github.io/</id>
  <author>
    <name><![CDATA[Daryl5]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[『Objective-C高级编程』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/05/10/pro-multithreading-and-memory-management-for-ios-and-os-x/"/>
    <updated>2014-05-10T19:20:32+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/05/10/pro-multithreading-and-memory-management-for-ios-and-os-x</id>
    <content type="html"><![CDATA[<!--more-->


<h1>第一章 ARC</h1>

<h2>1.2 内存管理</h2>

<h3>1.2.2 内存管理的思考方式</h3>

<ul>
<li>自己生成的对象，自己持有（alloc/new/copy/mutableCopy了就也retain了）</li>
<li>非自己生成的对象，自己也能持有（retain）</li>
<li>不再需要自己持有的对象时释放（release）</li>
<li>非自己持有的对象无法释放（没retain/alloc/new/copy/mutableCopy就不能release）</li>
</ul>


<p>1.OC的内存管理方法实际上不在OC语言里，而是包含在Cocoa框架中的。（OC是C的超集，Cocoa是对OC加了内存管理、多媒体、网络通讯等等的类库形成的用来给OS X开发应用的框架，Cocoa Touch是对Cocoa进行移动适配形成的另一套OC的类库）<br/>
2.Cocoa框架中Foundation框架类库中的NSObject类担负内存管理的职责，内存管理调用的alloc、retain等方法指代的就是NSObject类中的alloc类方法、retain实例方法等。（所有对象继承自NSObject，alloc、retain等内存管理方法在NSObject中实现，这也就是为什么初始化对象时候要先[super init]以及dealloc最末要[super dealloc]）<br/>
3.<code>[NSObject new</code>和<code>[[NSObject alloc] init]</code>是完全等价的。<br/>
4.类似<code>id obj = [NSMutableArray array]</code>这样的生成的类对象并不会被obj所持有，也就是说这行代码里不包含<code>[obj retain]</code>，总是这么写不过都是在ARC下，没意识到这个问题。如果是手动管理，加retain就好。</p>

<h3>1.2.3 alloc/retain/release/dealloc实现</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Practices & Tips]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c/"/>
    <updated>2014-04-23T19:19:22+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/23/best-practices-for-objective-c</id>
    <content type="html"><![CDATA[<!--more-->


<h3>4.用block实现代理</h3>

<p>关于block的大致介绍，<a href="http://onevcat.com/2011/11/objective-c%E4%B8%AD%E7%9A%84block/">Objective-C中的Block</a>这篇博文写的挺好。其中提到的一点需要注意，如下：
```objective-c
int price = 1.99;</p>

<p>float (^finalPrice)(int) = ^(int quantity) {</p>

<pre><code>//Price is accessible here
return quantiy * price;
</code></pre>

<p>}</p>

<p>int orderQuantity = 10;
//Ordering 10 units, final price is: $19.90
NSLog(@&ldquo;Ordering %d units, final price is: $%2.2f&rdquo;, orderQuantity, finalPrice(orderQuantity));</p>

<p>price = .99;
//Ordering 10 units, final price is: $19.90
NSLog(@&ldquo;Ordering %d units, final price is: $%2.2f&rdquo;, orderQuantity, finalPrice(orderQuantity));
```</p>

<blockquote><p>可以理解为在block内的price是readonly的，只在定义block时能够被赋值（补充说明，实际上是因为price是value type，block内的price是在申明block时复制了一份到block内，block外面的price无论怎么变化都和block内的price无关了。如果是reference type的话，外部的变化实际上是会影响block内的）。</p></blockquote>

<p>解决办法有两种：<br/>
1.将局部变量声明为__block，表示外部变化将会在block内进行同样操作;<br/>
2.使用实例变量。关于这点有引文：</p>

<blockquote><p>这个比较没什么好说的，实例内的变量横行于整个实例内..可谓霸道无敌…=_=
block外的对象和基本数据一样，也可以作为block的参数。而让人开心的是，block将自动retain传递进来的参数，而不需担心在block执行之前局部对象变量已经被释放的问题。这里就不深究这个问题了，只要严格遵循Apple的thread safe来写，block的内存管理并不存在问题。（更新，ARC的引入再次简化了这个问题，完全不用担心内存管理的问题了）</p></blockquote>

<p>这里有个问题就是：因为block会自动retain传进来的参数，所以会出现<a href="http://stackoverflow.com/questions/14556605/capturing-self-strongly-in-this-block-is-likely-to-lead-to-a-retain-cycle">capturing self strongly in this block is likely to lead to a retain cycle</a>的问题，即就是传进去<code>self.xxx</code>之后，会retain self，即构成了循环引用。解决办法是定义一个<code>__weak</code>的self然后在block中使用。</p>

<p><strong>回到正题，block代替protocol</strong>
```objective-c
//In DRDHandWriting.h
typedef void(^didFinishWriting)(NSMutableArray *);
@property (copy, nonatomic) didFinishWriting didFinishWritingBlock;//注意这里是copy</p>

<p>//In DRDHandWriting.m
//Submit charUnitArray to Document
self.didFinishWritingBlock(segmentedCharUnitArray);</p>

<p>//In DRDManuscriptController::loadHandWritingView
handWritingView = [[DRDHandWriting alloc] initWithFrame:handWritingRect];
__weak DRDManuscriptController <em>weakSelf = self;
//这里的参数只是被代理对象需要返回给代理的数据，具体就是手写视图需要返回切分好的字符给controller
//另一种情形就是多个AlertView的代理，这里就可以传回当前alertView
[handWritingView setDidFinishWritingBlock:^(NSMutableArray </em>segmentedArray) {</p>

<pre><code>[weakSelf.document addOrInsertCharUnitArray:segmentedArray];
</code></pre>

<p>}];
```
关于上例中block的copy，有<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">官方文档</a>：</p>

<blockquote><p>Note: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. For more information, see Blocks Programming Topics.</p></blockquote>

<p>block在创建的时候是分配在栈上的，如果<code>retain</code>（栈上的东西不能retain），在调用block的时候程序就会崩溃，实际上ARC下测试了一下retain，只是代码编辑阶段即给出警告<code>Retain'ed block property does not copy the block - use copy attribute instead</code>并且程序正常运行。而如果是<code>copy</code>，将会把这个block拷贝到堆里，同时retain这个block所引用的所有东西。block在堆上的时候进行copy就没事，不会再拷贝一遍，只是相当于retain。这段摘自<a href="http://blog.refractalize.org/post/10476042560/copy-vs-retain-for-objective-c-blocks">Copy vs retain for Objective-C blocks</a>。</p>

<p><strong>结论：</strong><br/>
自己实验了一下上面那个改变price输出总价不变的例子，block在创建的时候是分配在栈上的。<br/>
1.如果block里用到了局部变量，那么就会拷贝一份：比如<code>int a = 5</code>就会拷贝一个int变量其值为5；如果是<code>int *ptr = 5</code>就会拷贝ptr这个指针，这样改变*ptr的值，block里也会跟着变。<br/>
2.如果用到了实例变量，那么不管是value type还是指针型的，都不会出现外部更新而block内部没跟着变的情况，猜想是因为block引用实例变量其实就是对self指针的弱引用，用到实例变量时候用指针去读的。<br/>
3.上面<code>capturing self strongly in this block is likely to lead to a retain cycle</code>这一问题，是因为用到了实例变量。两种情况：如果是property那么隐含<code>self.propertyXXX</code>；如果是非property的实例变量，隐含<code>self-&gt;iVar</code>，都有self。因为是用block实现代理，那么需要传block给被代理对象，被代理对象copy block，同时运行时会copy block到堆上并retain block里所有的东西，这就相当于被代理对象里声明了一个<code>@property (strong, nonatomic) id&lt;XXXProtocol&gt; delegate</code>，所以就造成了循环引用。上面那个SO的链接讲得很清楚。<br/>
4.最后，什么时候用block什么时候用delegation，<a href="http://stablekernel.com/blog/blocks-or-delegation/">Blocks or Delegation</a>讲了，实在不想看了，先马克- -！</p>

<h3>3.Category也能Conform to a protocol</h3>

<h3>2.对集合中每个对象发送消息</h3>

<p><code>objective-c
// remove all subviews
[[self.scrollView subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)];
</code></p>

<h3>1.<a href="http://ironwolf.dangerousgames.com/blog/archives/913">The Code Commandments: Best Practices for Objective-C Coding </a></h3>

<p><strong>a.在实例变量前加<code>@private</code></strong>[放在类扩展就好]</p>

<ul>
<li>表明该变量与API无关</li>
<li>默认是<code>@protected</code>即就是子类可以访问，如果子类不需要那就不要暴露，面向对象的<code>信息隐藏</code>，（其实最好的应该是子类和其他类用到的在.h，私有变量和方法在类扩展）</li>
</ul>


<p><strong>b.为每一个<code>data member</code>创建<code>@property</code>，在.m中都用<code>self.name</code>来访问</strong>[这个有问题]</p>

<ul>
<li>property会把访问权限加入，如readonly</li>
<li>property会把内存管理加入，strong&amp;weak</li>
</ul>


<p><strong>c.<code>实例变量</code>就是只给当前类及其子类使用，<code>@property</code>就是外部类也能用</strong><br/>
之前看到在头文件里interface部分定义实例变量，同时又用@property重新写一遍。对于想要公开给这个类及其子类以外的类的实例变量，那么就为其写一个对应的property。<br/>
<strong>d.关于<code>readonly</code></strong>
就是说这个property在外界不能修改，如<code>self.document.displayHeight</code>会产生<code>assign to readonly property</code>。在类的实现文件里可以通过实例变量来修改，如<code>_displayHeight = 600</code>，此外，在实现文件还可以通过<code>self-&gt;_displayHeight = 600</code>来修改，这里之所以用->大概是因为类本身拥有这个实例变量就意味着类的实例有一个指向这个实例变量的指针，而property只是用于公开给外部，在这里没property什么事。
另外还可以在类扩展里告诉编译器我还需要一个setter，但只是在实现文件里：
<code>objective-c
//公有可读，私有可写
@interface YourClass ()
@property (nonatomic, copy) NSString* eventDomain;
@end
</code>
这个问题在<a href="http://stackoverflow.com/questions/4586516/readonly-properties-in-objective-c">Readonly Properties in Objective-C?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『Effective Objective-C 2.0』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0/"/>
    <updated>2014-04-07T13:22:29+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0</id>
    <content type="html"><![CDATA[<p>《Effective Objective-C 2.0：52 Specific Ways to Improve Your iOS and OS X Programs》 作者：<a href="http://www.galloway.me.uk/">Matt Galloway</a></p>

<!--more-->


<h2><strong>1: Accustoming Yourself to Objective-C</strong></h2>

<h3>Item 2: 缩减头文件&mdash;Minimize Importing Headers in Headers</h3>

<p>a.如下引文，试了一下互相import，没有报错- -！</p>

<blockquote><p>The use of #import rather than #include doesn&rsquo;t end in an infinite loop but does mean that one of ther classes won&rsquo;t compile correctly.</p></blockquote>

<p>b.协议相关<br/>
一些代理相关的协议，可以把协议头文件在.m文件里再引入，把代理<code>id&lt;XXXProtocol&gt; delegate</code>定义放在类扩展里。
也可以考虑单独创建一个头文件，里面只放协议定义。</p>

<!--more-->


<h3>Item 3: 使用字面量语法而不是其等价方法&mdash;Prefer Literal Syntax over the Equivalent Methods</h3>

<p>a.字面量使用</p>

<pre><code>NSString *str           = @"Test String";
NSNumber *boolValue     = @YES;
NSNumber *charValue     = @'a';
NSNumber *expressionVal = @(x * y);//int x &amp; float y

NSArray *animals        = @[@"cat", @"dog"];
NSString *dog           = animails[1];//下标直接访问

NSDictionary *person    = @{@"firstName" : @"Matt", @"age" : @28};
NSString *firstName     = person[@"firstName"];//key值直接访问value

//Assign value or replace
mutableArray[1] = @"dog";
mutableDictionary[@"lastName"] = @"Galloway";
</code></pre>

<p>b.好处<br/>
如果NSArray用3个object来初始化，第二个是nil，那么arrayWithObjects将会返回一个只包含object1的array，而字面量初始化会报错。<strong>“报错”比“少了个数”更安全。</strong>
对于NSDictonary，初始化会在遇到nil时候停止，dictionaryWithObjectsAndKeys可能会少了某一个value；字面量更安全。<br/>
c.缺点<br/>
字面量语法只能用于Foundation框架的一些类，对于自定义的类没法这样定义（显然）。<br/>
对于mutable对象的定义，需要进行mutableCopy。增加了额外的方法调用和对象创建</p>

<pre><code>NSMutableArray *mutable = [@[@1, @2, @3] mutableCopy];
</code></pre>

<h3>Item 4: 使用类型化常量而不是预处理指令#define&mdash;Prefer Typed Constants to Preprocessor #define</h3>

<p>a.#define的缺点<br/>
预处理指令<code>#define ANIMATION_DURATION 0.3</code>只是在预处理阶段进行<code>替换</code>，它没有包含类型信息。（如果定义在头文件，所有包含该头文件的文件也都会进行替换。）<br/>
b.类型化常量的使用（static const）<br/>
用上编译器让常量有类型信息：<code>static const NSTimerInterval kAnimationDuration = 0.3;</code>
常量命名规范：</p>

<blockquote><p>The usual convertion for constants is to prefix with lettr k for constants that are local to a translation unit(implementation file). For constants that are exposed outside of a class, it is usual to prefix with the class name.<br/>
在.m中定义，对于这个translation unit是局部变量的话用k作前缀；如果要暴露给外界，用类名开头，如EOCViewClassAnimationDuration。</p></blockquote>

<p><code>static</code>关键词说明这个变量对于当前translation unit是局部的，如果没定义为static，编译器将会为其创建一个external symbol，如果另一translation unit声明了一个同名变量，链接器将会报错；<code>const</code>关键词说明不能被修改。</p>

<blockquote><p>A translation unit is the input the compiler receives to generate one object file. In OC, this usually means that there is one translation unit per class: every .m file.</p></blockquote>

<p>SO的一个问题：<a href="http://stackoverflow.com/questions/11382502/how-different-static-variable-declarations-in-objective-c">How different static variable declarations in Objective-C?</a><br/>
c.类型化常量的使用（extern）<br/>
跟<code>NSNotification</code>相关，通知名应该这样处理：</p>

<pre><code>// In .h
// extern--"Trust me, there's a variable called EOCStringConstant declared in another file"
// EOC是类名
extern NSString *const EOCStringConstant;

// In .m
//反着读：EOCStringConstantis a const pointer point to NSString
NSString *const EOCStringConstant = @"NotificationName";
//如果不是对象那这里是const NSTimeInterval EOCAnimated...
</code></pre>

<p>d.总结<br/>
类型化常量有类型- -！
类型化常量借助编译器来确保常量的一致性（const），预处理指令#define可以在别的地方重定义。<br/>
.m的局部变量如动画时间等用k开头放在.m文件里用static；通知名等用类名+通知名，.m里声明+定义，.h里extern，如UIApplication类里声明+定义的UIApplicationDidEnterBackGroundNotifation。</p>

<h2><strong>2: Objects, Messaging, and the Runtime</strong></h2>

<h3>Item 6: 理解Properties-Understand Properties【需要再看】</h3>

<p>a.自己写了Accessor中的一个，编译器将会synthesize另一个，LazyLoading就是这样的。如果不想让编译器自动synthesize，可以用<code>@dynamitc</code>指令，这样编译器不会生成Accessor和对应的实例变量名，而且编译时候编译器会忽略Accessor还没有被定义但是已经在self.property，编译器会认为Accessor在runtime时会有的。<br/>
b.<code>weak</code>不会release旧值，也不会retain新值，类似assign，不过这个property所指对象被销毁时，这个property会被nilled out。<br/>
<code>unsafe_unretained</code>也和assign类似，只是关于object的assign，unretained对应nonowning，unsafe对应不会被nilled out，这一点和weak不一样。<br/>
<code>copy</code>对应mutable copy，如果不想让对象把传进来的值改变了，应该做一下copy，也就是immutable copy。虽然增加了拷贝操作，但是会更安全。<br/>
c.关于自定义getter名在BOOL上的应用，为了加is为什么不直接把property命名成isXxx。</p>

<h3>Item 7: Access Instance Variables Primarily Directly When Accessing Them Internally</h3>

<p><strong>a.总结</strong></p>

<ol>
<li>一般来说，要读实例变量的时候就直接访问，要写实例变量的时候就用property。</li>
<li>如果在初始化方法（或dealloc）中改变property的值，那么也是直接访问实例变量。因为如果初始化方法也用property，那么父类初始化时候其实会调用子类的初始化方法，可能会产生问题。另外，有时候是必须在初始化方法中使用setter的，比如当实例变量在父类中声明，那子类只能通过setter来访问。</li>
<li>如果property使用了<code>Lazy Loading</code>，那么需要使用getter来获取，不如可能获得空值。</li>
</ol>


<p><strong>b.<code>直接访问</code>和<code>使用property</code>的区别</strong></p>

<ol>
<li>直接访问无需<code>method dispatch</code>那么肯定更快；</li>
<li>直接使用实例变量会绕过property所设置的内存管理策略；</li>
<li>直接访问实例变量，KVO可能不会触发了；</li>
<li>使用property可以方便debug，知道谁在什么时候访问了某一实例变量。</li>
</ol>


<h3>Item 8: Understand Object Equality</h3>

<p>a.有的类实现了判断相等的方法，如NSString的<code>isEqualToString:</code>，这个比<code>isEqual:</code>，因为后者还需要查看所比较对象所属的类。</p>

<h1>看不下去了</h1>

<h3>Item 10: 在既有类中适用关联对象存放自定义数据-Use Associated Objects to Attach Custom Data to Existing Classed</h3>

<p>a.一般都是通过<code>继承</code>来给既有类添加数据，但行不通的时候就要用到<code>关联对象</code>了。以UIAlertView为例：</p>

<ul>
<li>一般的实现中buttonIndex和其action的对应，即button的定义和其响应方法的声明不在一个地方，这样可读性不好；</li>
<li><p>如果同一个类里有多个alertView，那么在代理方法中还要判断是哪一个，然后再判断buttonIndex；
```objective-c
static const void *EOCMyAlertViewKey = &ldquo;EOCMyAlertViewKey&rdquo;;</p></li>
<li><p>(void)askUserAQuestion {
  UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&ldquo;Question&rdquo;
                                                  message:@&ldquo;What do you want to do?&rdquo;
                                                 delegate:self
                                        cancelButtonTitle:@&ldquo;Cancel&rdquo;
                                        otherButtonTitles:@&ldquo;Continue&rdquo;, nil];</p>

<p>  void(^block)(NSInteger) = ^(NSInteger buttonIndex) {
      if (buttonIndex == 0) {
          [self doCancel];
      } else {
          [self doContinue];
      }
  };</p>

<p>  objc_setAssociatedObject(alert, EOCMyAlertViewKey, block, OBJC_ASSOCIATION_COPY);</p>

<p>  [alert show];
}</p></li>
</ul>


<p>// UIAlertViewDelegate protocol method
&ndash; (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex {</p>

<pre><code>void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey);
block(buttonIndex);
</code></pre>

<p>}
<code>``
b.总结  
关联对象就是把两个object链接在一起了；关联对象只有在其他方法都不可行的时候才使用，因为很容易造成</code>Retain Cycle`；上例中还可以通过继承AlertView并附加这个block对象来实现，如果类中alertView要多次用到，更建议继承而不是关联对象。</p>

<h3>Item 14: 理解类的对象- Understand What a Class Object Is</h3>

<p>a.OC是<code>动态类型</code>的，对象的类型并不是在编译时候进行绑定的，而是在运行时进行查找。</p>

<h2><strong>4: Protocols and Categories</strong></h2>

<h3>Item 23: 通过委托和数据源协议进行对象间通信</h3>

<p>a.有一句话没太懂，这个单词居然查不出来，完了看看Item6，里面有这个单词：</p>

<blockquote><p>A delegate property will always be defined using either the weak attribute to benefit from <code>autonilling</code> or unsafe_unretained if autonilling is not required.</p></blockquote>

<p>b.在interface中声明遵守协议的话，别的类会知道这一行为，一般把“遵守协议”放在类扩展部分，虽然没太多影响。要知道一个对象是否遵守某个协议可以这样：<code>[self conformsToProtocol:@protocol(DRDHandWritingProtocol)]</code><br/>
c.可以把正在代理的对象也传回给代理，这样方便判断具体是哪个代理对象在调用代理方法。
```objective-c
&ndash; (void)networkFetcher:(EOCNetworkFetcher <em>)fetcher didReceiveData:(NSData </em>)data {</p>

<pre><code>if (fetcher == _myFetcherA) {
    //Handle data
} else if (fetcher == _myFetcherB) {
    //Handle data
}
</code></pre>

<p>}
<code>
d.如果开发API，用代理可以实现一些属性设置，如`- (BOOL)networkFetcher:(EOCNetworkFetcher *)fetcher shouldFollowRedirectToURL:(NSURL *)url;`，甚至这里可以给fetcher传递一个NSDictionary来进行Fetcher一系列属性的设置。  
e.对`@optional`的代理方法，方法调用者负责通过`[delegate respondsToSelector]`确保程序不会崩溃，unrecognized selector。`@required`的话编译器会确认。如果没设置，默认都是required。  
f.对dataSource类的delegate，在获取每一个小的data piece的时候都查询一次respondsToSelector是低效的，应该将当前对象对协议的遵守情况缓存下来。如下：
</code>objective-c
//有个DataModel或者ViewController是该对象的代理
//In class extension
@interface EOCNetworkFetcher() {</p>

<pre><code>struct {
    unsigned int didReceiveData      : 1;
    unsigned int didFailWithError    : 1;
    unsigned int didUpdateProgressTO : 1;
}_delegateFlags;
</code></pre>

<p>}</p>

<p>//In delegate Setter
&ndash; (void)setDelegate:(id<EOCNetworkFetcher>)delegate {</p>

<pre><code>_delegate = delegate;
_delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)];
...
</code></pre>

<p>}</p>

<p>//Query if responds to selector (FRENQUENTLY)
if (_delegateFlags.didReceiveData) {</p>

<pre><code>[_delegate networkFetcher:self didReceiveData:dataReceived];
</code></pre>

<p>}
<code>
g.协议的“继承”
</code>objective-c
@protocol A</p>

<pre><code>-(void) methodA;
</code></pre>

<p>@end</p>

<p>@protocol B <A></p>

<pre><code>-(void) methodB;
</code></pre>

<p>@end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIDocument的使用]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument/"/>
    <updated>2014-04-01T21:42:32+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument</id>
    <content type="html"><![CDATA[<p>读<a href="https://github.com/sprang/Inkpad">Inkpad</a>源码时看到使用了<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIDocument_Class/UIDocument/UIDocument.html#//apple_ref/c/tdef/UIDocumentState">UIDocument</a>，然后搜到了Ray Wenderlich的博文：<a href="http://www.raywenderlich.com/12779/icloud-and-uidocument-beyond-the-basics-part-1">iCloud and UIDocument: Beyond the Basics</a>，整理了一下大致用法。</p>

<!--more-->


<h3>1. 继承UIDocument并重写方法</h3>

<p>需要重写<code>loadFromContents:ofType:error</code>方法来读，重写<code>contentsForType:error</code>方法来写。</p>

<h3>2. 输入输出格式</h3>

<p>UIDocument支持两种类，<code>NSData</code>适用于文档只是一个单一文档，<code>NSFileWrapper</code>相当于文件夹，适用于文档包含多个想要单独加载的文件，比如矢量图绘制App要显示一个缩略图，这个需要单独提前加载。FileWrapper内部是Key-Value形式的存储，文件名是key，文件存在本地的archive内容（或是archive文件名）是value，所以会有：</p>

<!--more-->


<pre><code>//从文件名（如xxxx.title，不是xxxx.note）得到FileWrapper
NSFileWrapper *fileWrapper = [self.fileWrapper.fileWrappers objectForKey:preferredFilename];

//从FileWrapper得到文件内容
NSData *data = [fileWrapper regularFileContents];
NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
</code></pre>

<h3>3. iCloud</h3>

<p>Apple规定，应用的所有documents要么在沙盒，要么在iCloud本地文件夹，用户不能选择某一文件来让其单独的存储在iCloud。</p>

<blockquote><p>All documents of an application are stored either in the local sandbox or in an iCloud container directory. A user should not be able to select individual documents for storage in iCloud.</p></blockquote>

<!--more-->


<h3>4. 关于undo/redo</h3>

<p>UIDocument有undo/redo支持，访问器是注册undo动作最合适的地方，所以document类里，对需要添加undo/redo功能的数据要重写访问器。对不需要undo/redo功能的数据，直接给document用property添加一个model就好。</p>

<h3>5. 整体的实现结构</h3>

<p>以记事本为例，title和content两个model，其中都只包含一个NSString。主视图直接在title，detailViewController再加载content。</p>

<blockquote><p><code>TitleModel</code>和<code>ContentModel</code>都实现<code>NSCoding</code>协议方法，这里可以考虑把<code>VersionNumber</code>encode进去以便后期支持文件格式扩展。
<strong>NoteDocument.h</strong></p>

<blockquote><p><code>@property (nonatomic, strong) TitleModel *titleModel;
//这里对ContentModel中的内容实现访问器，原因第4条有，方便undo/redo</code>
<code>- (NSString *)contentString;</code><br/>
<code>- (void)setContentString:(NSString *)str;</code></p></blockquote>

<p><strong>NoteDocument.m</strong></p>

<blockquote><ul>
<li>类扩展里定义<code>contentModel</code>和<code>fileWrapper</code>(读文件时候用)，<code>titleModel</code>直接放在头文件是因为It’s OK if the user accesses the metadata directly though, as it’s not something the app will modify. Instead, the metadata will be automatically updated when the user sets the photo.</li>
<li>重写<code>loadFromContents</code>和<code>contentsForType</code>，loadFromContents里面self.wrapper = (NSFileWrapper *)contents;给wrapper赋值，contentsForType里面把两个model encode进wrapper</li>
<li>重写<code>titleModel</code>和<code>contentModel</code>两个getter实现Lazy Loading，需要的时候再decode；如果文件不存在则把model初始化为nil</li>
<li>实现ContentModel的content的Accessor来实现undo/redo，在Setter里面执行如下代码块：
```objective-c
if ([self.contentModel.content isEqual:str]) {
  return;
}</li>
</ul>
</blockquote></blockquote>

<p>NSString *oldContent = self.contentModel.content;
self.contentModel.content = str;</p>

<p>[self.undoManager setActionName:@&ldquo;Content Change&rdquo;];
[self.undoManager registerUndoWithTarget:self selector:@selector(setContentString:) object:oldContent];
```</p>

<h2>其他</h2>

<h3>1. 设备旋转支持</h3>

<p>好多大厂的App居然也能支持反过来操作，真是不可理解。代码摘自引用博文实现的工程。
```objective-c
&ndash; (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation
{</p>

<pre><code>return (interfaceOrientation != UIInterfaceOrientationPortraitUpsideDown);
</code></pre>

<p>}
```</p>

<h3>2. Undo/Redo</h3>

<p><a href="http://blog.163.com/chenchen..1986/blog/static/760631462013222314817/">这里</a>的例子简单有效。</p>

<h3>3. 自己画的大致思路，实际实现没这么做。</h3>

<p><img src="/blogimage/2014/useuidocument.jpg" alt="useuidocument" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读Inkpad源代码]]></title>
    <link href="http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code/"/>
    <updated>2014-03-30T19:55:11+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/sprang/Inkpad">Inkpad</a>是一个开源的基于OpenGLES的画矢量图的App，这篇博文记录阅读其源代码时的收获。</p>

<!--more-->


<h3>0. 内联函数的使用</h3>

<p>内联函数只是给编译器的提示，最终能不能内联还要看编译器。</p>

<h4>(1)相同点</h4>

<p><code>static inline double radians (double degrees) { return degrees * M_PI/180; }</code>；都是在与处理阶段对代码块进行替换。</p>

<h4>(2)不同点</h4>

<p>内联函数是值传递，宏定义是简单替换。内联函数有类型检查，此外<code>省去了很多函数调用汇编代码如：call和ret等</code>。<br/>
<code>#define MAX(a, b) a&gt;b?a:b</code>如果<code>MAX( num1, num2 )</code>就没问题，但是如果是<code>MAX( 17+32, 25+21)</code>，展开后是<code>17+32&gt;25+21?17+32:25+21</code>。甚至<code>#define A 2+3</code>，然后<code>c = 4 * A</code>都会成为<code>4 * 2 + 3</code>。比较安全的写法是<code>#define MAX( (a), (b) ) (a)&gt;(b)?(a)b)</code>，但是这样还是有问题，<code>MAX(i++,j++)</code>完了每个都会加2了。
宏定义执行快是因为没有<code>函数调用</code>的开销，但是如果宏用的多文件就会变很大，执行文件太大可能导致执行时换页频繁（略夸张）。</p>

<h3>1. 一些简洁的写法</h3>

<ul>
<li><p><code>CGRectGetWidth</code>，以前总是写成<code>self.frame.size.width</code>。此外还有<code>CGRectGetMidX</code>，直接得到矩形中心点的X坐标。</p>

<pre><code>  CGPointMake(CGRectGetWidth(frame) / 2, CGRectGetHeight(frame) / 2);
</code></pre></li>
<li><p><code>[NSDictionary objectForKey]</code>，可以直接<code>dictionary[key]</code>。</p></li>
<li><p><code>BOOL isolate</code>转NSString，<code>@(isolate)</code>。NSArray的类似写法：</p>

<pre><code>  NSArray *items = @[actionItem_, gearItem_, albumItem_, zoomToFitItem_];
</code></pre></li>
</ul>


<h3>2. Best Practice</h3>

<h4>(1) “帮助”、“关于”视图</h4>

<p>应用的<strong><code>帮助</code></strong>, <strong><code>关于</code></strong>等信息可以做成html页面。建立本地文件夹，在其中放置html、图片、css等，然后直接<code>self.view = webview;</code>即可。</p>

<!--more-->


<p>```objective-c
&ndash; (NSURL *) helpURL
{</p>

<pre><code>NSString *resource = NSLocalizedString(@"index", @"Name of Help html file");
NSString *path = [[NSBundle mainBundle] pathForResource:resource ofType:@"html" inDirectory:@"Help"];
return [NSURL fileURLWithPath:path isDirectory:NO];
</code></pre>

<p>}
&ndash; (void)loadView
{</p>

<pre><code>UIWebView *webView = [[UIWebView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
webView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
self.view = webView;
[webView loadRequest:[NSURLRequest requestWithURL:[self helpURL]]];
</code></pre>

<p>}
```</p>

<h4>(2) 应用“设置”功能</h4>

<p>以“显示网格”这一设置项为例，通过<code>UILable  UISwitch</code>来实现。其实可以全部通过NSUserDefaults实现，但inkpad中有个NSMutableDictionary的settings_作为”中间变量“:</p>

<ul>
<li>可能是考虑到在初始化时一次读取NSUserDefaults而不是需要属性就去查NSUserDefaults更好;</li>
<li>还有个原因就是每个drawing都会把settings_当做Document的一部分进行存储，NSMutableDictionary才能去存储。</li>
</ul>


<p>在<code>WDDrawingController</code>中有<code>WDPropertyManager</code>。除了下面的示例代码，很多属性的管理都在这里，<strong>区别是</strong>settings<em>只管理<code>设置</code>视图里能改变的属性，并且其值会被存储到document里，跟单独drawing相关；<del>而propertyManager管理<code>应用状态</code>，比如不选路径的时候“路径”的popover tableView里就全部不可用，如添加锚点、合并路径。</del>
```objective-c
// constantly updating the user defaults kills responsiveness after the keyboard has been made visible
// so use this temporary dictionary to avoid hitting the defaults all the time<br/>
NSMutableDictionary *defaults</em> = [[NSMutableDictionary alloc] init];//in init</p>

<p>//&ndash; (void) didEnterBackground:(NSNotification *)aNotification
&ndash; (void) updateUserDefaults
{</p>

<pre><code>for (NSString *key in [defaults_ allKeys]) {
    [[NSUserDefaults standardUserDefaults] setObject:defaults_[key] forKey:key];
}
</code></pre>

<p>}
<code>
相关代码如下：
</code>objective-c
//属性设置-在“设置”界面控件响应方法中
//WDSettingsController
&ndash; (void) takeShowGridFrom:(id)sender
{</p>

<pre><code>UISwitch    *mySwitch = (UISwitch *)sender;

[[NSUserDefaults standardUserDefaults] setBool:mySwitch.isOn forKey:WDShowGrid];
[[NSUserDefaults standardUserDefaults] synchronize];

drawing_.showGrid = mySwitch.isOn;//Setter方法
</code></pre>

<p>}</p>

<p>//属性管理的中间类-在Accessor中设置和应用，发送通知最终应用设置
//WDDrawing:NSObject
&ndash; (void) setShowGrid:(BOOL)showGrid
{</p>

<pre><code>settings_[WDShowGrid] = @(showGrid);//settings_是NSMutableDictionary，WDShowGrid是NSString “WDShowGrid”
[[NSNotificationCenter defaultCenter] postNotificationName:WDDrawingChangedNotification object:self];

// this isn't an undoable action so it does not dirty the document
[self.document markChanged];
</code></pre>

<p>}</p>

<ul>
<li>(BOOL) showGrid
{
  return [settings_[WDShowGrid] boolValue];
}</li>
</ul>


<p>//属性改变的即时应用-接收通知并通过setNeedsDisplay处发drawRect重绘
//WDCanvas
&ndash; (void) invalidateFromNotification:(NSNotification *)aNotification
{</p>

<pre><code>NSValue     *rectValue = [aNotification userInfo][@"rect"];
NSArray     *rects = [aNotification userInfo][@"rects"];
CGRect      dirtyRect;
float       fudge = (-1.0f) / viewScale_;

if (rectValue) {
    //...
} else if (rects) {
    //...
} else {//没有任何userInfo，对应showGrid这一属性的改变
    [self setNeedsDisplay];
}
</code></pre>

<p>}</p>

<ul>
<li>(void)drawRect:(CGRect)rect
{
  //&hellip;
  if (drawing_.showGrid &amp;&amp; !drawingIsolatedLayer) {
      [self drawGrid:ctx];
  }
  //&hellip;
}</li>
</ul>


<p>//属性的保存-主要在WDSettingsController，设置并同步
借助NSUserDefaults</p>

<p>//属性的加载-各种init方法中从NSUserDefaults初始化settings_
//WDDrawing
&ndash; (id) initWithSize:(CGSize)size andUnits:(NSString *)units
{</p>

<pre><code>// each drawing saves its own settings, but when a user alters them they become the default settings for new documents
// since this is a new document, look up the values in the defaults...
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
NSArray *keyArray = @[WDShowGrid, WDSnapToGrid, WDSnapToPoints, WDSnapToEdges, WDDynamicGuides, WDRulersVisible];
for (NSString *key in keyArray) {
    settings_[key] = @([defaults boolForKey:key]);
}
</code></pre>

<p>}
```</p>

<h3>3. <code>NSNotification</code>的名字应该在哪定义</h3>

<p>在<code>WDToolManager.m</code>中，<code>NSString *WDActiveToolDidChange = @"WDActiveToolDidChange";</code>，然后在头文件中<code>extern NSString *WDActiveToolDidChange;</code>。一般来说关心这个通知（当前工具改变）的类都引用了这个类的头文件，这样比放在一个<code>ConstantsDefine.h</code>里要好。</p>

<h3>4.枚举定义中为什么要用左移</h3>

<p>这里解释的很详细<a href="http://stackoverflow.com/questions/3999922/why-use-the-bitwise-shift-operator-for-values-in-a-c-enum-definition">Why use the Bitwise-Shift operator for values in a C enum definition?</a>。如果用</p>

<pre><code>typedef enum { WDToolDefault, WDToolShiftKey, WDToolOptionKey }  
</code></pre>

<p>那么<code>WDToolDefault | WDToolShiftKey</code>就是<code>1 | 2</code>会得到3！！用左移就不会有这个问题，就是<strong><em>可以在一个变量中支持多个枚举值</em></strong>（将其相加或者取或），判断的时候取与。</p>

<pre><code>typedef enum {
    WDToolDefault           = 0,
    WDToolShiftKey          = 1 &lt;&lt; 0,
    WDToolOptionKey         = 1 &lt;&lt; 1,
    WDToolControlKey        = 1 &lt;&lt; 2,
    WDToolSecondaryTouch    = 1 &lt;&lt; 3
} WDToolFlags;  
</code></pre>

<h3>5. 子类不能重写touchesBegan但要在其发生同时完成处理</h3>

<p><code>FingerTackerView</code>重写<code>touchesBegan</code>等等方法，然后在其内部进行一些操作后调用<code>[self methodForSubclassOverwritten]</code>，这个方法可以置空。<code>HandWritingView</code>，<code>GestureEditorView</code>等继承自<code>FingerTrackerView</code>的类里重写<code>[self methodForSubclassOverwritten]</code>，这样就能在采集点的同时，对点的处理根据当前选择功能（即所处的视图）来由对应的子类来处理。子类不会出现<code>touchesBegan</code>等，但是可以通过重写方法来实现手势运动时处理。</p>
]]></content>
  </entry>
  
</feed>
