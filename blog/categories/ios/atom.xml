<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Daryl's Blog]]></title>
  <link href="http://daryl5.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://daryl5.github.io/"/>
  <updated>2014-04-07T16:26:32+08:00</updated>
  <id>http://daryl5.github.io/</id>
  <author>
    <name><![CDATA[Daryl5]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[『Effective Objective-C 2.0』笔记]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0/"/>
    <updated>2014-04-07T13:22:29+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/07/reading-effective-objective-c-2-dot-0</id>
    <content type="html"><![CDATA[<p>《Effective Objective-C 2.0：52 Specific Ways to Improve Your iOS and OS X Programs》 作者：<a href="http://www.galloway.me.uk/">Matt Galloway</a></p>

<h2><strong>1: Accustoming Yourself to Objective-C</strong></h2>

<h3>Item 2: 缩减头文件&mdash;Minimize Importing Headers in Headers</font></h3>

<p>a.如下引文，试了一下互相import，没有报错- -！</p>

<blockquote><p>The use of #import rather than #include doesn&rsquo;t end in an infinite loop but does mean that one of ther classes won&rsquo;t compile correctly.</p></blockquote>

<p>b.协议相关<br/>
一些代理相关的协议，可以把协议头文件在.m文件里再引入，把代理<code>id&lt;XXXProtocol&gt; delegate</code>定义放在类扩展里。
也可以考虑单独创建一个头文件，里面只放协议定义。</p>

<h3>Item 3: 使用字面量语法而不是其等价方法&mdash;Prefer Literal Syntax over the Equivalent Methods</h3>

<p>a.字面量使用</p>

<pre><code>NSString *str           = @"Test String";
NSNumber *boolValue     = @YES;
NSNumber *charValue     = @'a';
NSNumber *expressionVal = @(x * y);//int x &amp; float y

NSArray *animals        = @[@"cat", @"dog"];
NSString *dog           = animails[1];//下标直接访问

NSDictionary *person    = @{@"firstName" : @"Matt", @"age" : @28};
NSString *firstName     = person[@"firstName"];//key值直接访问value

//Assign value or replace
mutableArray[1] = @"dog";
mutableDictionary[@"lastName"] = @"Galloway";
</code></pre>

<p>b.好处<br/>
如果NSArray用3个object来初始化，第二个是nil，那么arrayWithObjects将会返回一个只包含object1的array，而字面量初始化会报错。<strong>“报错”比“少了个数”更安全。</strong>
对于NSDictonary，初始化会在遇到nil时候停止，dictionaryWithObjectsAndKeys可能会少了某一个value；字面量更安全。<br/>
c.缺点<br/>
字面量语法只能用于Foundation框架的一些类，对于自定义的类没法这样定义（显然）。<br/>
对于mutable对象的定义，需要进行mutableCopy。增加了额外的方法调用和对象创建</p>

<pre><code>NSMutableArray *mutable = [@[@1, @2, @3] mutableCopy];
</code></pre>

<h3>Item 4: 使用类型化常量而不是预处理指令#define&mdash;Prefer Typed Constants to Preprocessor #define</h3>

<p>a.#define的缺点<br/>
预处理指令<code>#define ANIMATION_DURATION 0.3</code>只是在预处理阶段进行<code>替换</code>，它没有包含类型信息。（如果定义在头文件，所有包含该头文件的文件也都会进行替换。）<br/>
b.类型化常量的使用（static const）<br/>
用上编译器让常量有类型信息：<code>static const NSTimerInterval kAnimationDuration = 0.3;</code>
常量命名规范：</p>

<blockquote><p>The usual convertion for constants is to prefix with lettr k for constants that are local to a translation unit(implementation file). For constants that are exposed outside of a class, it is usual to prefix with the class name.<br/>
在.m中定义，对于这个translation unit是局部变量的话用k作前缀；如果要暴露给外界，用类名开头，如EOCViewClassAnimationDuration。</p></blockquote>

<p><code>static</code>关键词说明这个变量对于当前translation unit是局部的，如果没定义为static，编译器将会为其创建一个external symbol，如果另一translation unit声明了一个同名变量，链接器将会报错；<code>const</code>关键词说明不能被修改。</p>

<blockquote><p>A translation unit is the input the compiler receives to generate one object file. In OC, this usually means that there is one translation unit per class: every .m file.</p></blockquote>

<p>SO的一个问题：<a href="http://stackoverflow.com/questions/11382502/how-different-static-variable-declarations-in-objective-c">How different static variable declarations in Objective-C?</a><br/>
c.类型化常量的使用（extern）<br/>
跟<code>NSNotification</code>相关，通知名应该这样处理：</p>

<pre><code>// In .h
// extern--"Trust me, there's a variable called EOCStringConstant declared in another file"
// EOC是类名
extern NSString *const EOCStringConstant;

// In .m
//反着读：EOCStringConstantis a const pointer point to NSString
NSString *const EOCStringConstant = @"NotificationName";
//如果不是对象那这里是const NSTimeInterval EOCAnimated...
</code></pre>

<p>d.总结<br/>
类型化常量有类型- -！
类型化常量借助编译器来确保常量的一致性（const），预处理指令#define可以在别的地方重定义。<br/>
.m的局部变量如动画时间等用k开头放在.m文件里用static；通知名等用类名+通知名，.m里声明+定义，.h里extern，如UIApplication类里声明+定义的UIApplicationDidEnterBackGroundNotifation。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIDocument的使用]]></title>
    <link href="http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument/"/>
    <updated>2014-04-01T21:42:32+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/04/01/how-to-use-uidocument</id>
    <content type="html"><![CDATA[<p>读<a href="https://github.com/sprang/Inkpad">Inkpad</a>源码时看到使用了<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIDocument_Class/UIDocument/UIDocument.html#//apple_ref/c/tdef/UIDocumentState">UIDocument</a>，然后搜到了Ray Wenderlich的博文：<a href="http://www.raywenderlich.com/12779/icloud-and-uidocument-beyond-the-basics-part-1">iCloud and UIDocument: Beyond the Basics</a>，整理了一下大致用法。</p>

<h3>1. 继承UIDocument并重写方法</h3>

<p>需要重写<code>loadFromContents:ofType:error</code>方法来读，重写<code>contentsForType:error</code>方法来写。</p>

<h3>2. 输入输出格式</h3>

<p>UIDocument支持两种类，<code>NSData</code>适用于文档只是一个单一文档，<code>NSFileWrapper</code>相当于文件夹，适用于文档包含多个想要单独加载的文件，比如矢量图绘制App要显示一个缩略图，这个需要单独提前加载。FileWrapper内部是Key-Value形式的存储，文件名是key，文件存在本地的archive内容（或是archive文件名）是value，所以会有：</p>

<pre><code>//从文件名（如xxxx.title，不是xxxx.note）得到FileWrapper
NSFileWrapper *fileWrapper = [self.fileWrapper.fileWrappers objectForKey:preferredFilename];

//从FileWrapper得到文件内容
NSData *data = [fileWrapper regularFileContents];
NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
</code></pre>

<h3>3. iCloud</h3>

<p>Apple规定，应用的所有documents要么在沙盒，要么在iCloud本地文件夹，用户不能选择某一文件来让其单独的存储在iCloud。</p>

<blockquote><p>All documents of an application are stored either in the local sandbox or in an iCloud container directory. A user should not be able to select individual documents for storage in iCloud.</p></blockquote>

<!--more-->


<h3>4. 关于undo/redo</h3>

<p>UIDocument有undo/redo支持，访问器是注册undo动作最合适的地方，所以document类里，对需要添加undo/redo功能的数据要重写访问器。对不需要undo/redo功能的数据，直接给document用property添加一个model就好。</p>

<h3>5. 整体的实现结构</h3>

<p>以记事本为例，title和content两个model，其中都只包含一个NSString。主视图直接在title，detailViewController再加载content。</p>

<blockquote><p><code>TitleModel</code>和<code>ContentModel</code>都实现<code>NSCoding</code>协议方法，这里可以考虑把<code>VersionNumber</code>encode进去以便后期支持文件格式扩展。
<strong>NoteDocument.h</strong></p>

<blockquote><p><code>@property (nonatomic, strong) TitleModel *titleModel;
//这里对ContentModel中的内容实现访问器，原因第4条有，方便undo/redo</code>
<code>- (NSString *)contentString;</code><br/>
<code>- (void)setContentString:(NSString *)str;</code></p></blockquote>

<p><strong>NoteDocument.m</strong></p>

<blockquote><ul>
<li>类扩展里定义<code>contentModel</code>和<code>fileWrapper</code>(读文件时候用)，<code>titleModel</code>直接放在头文件是因为It’s OK if the user accesses the metadata directly though, as it’s not something the app will modify. Instead, the metadata will be automatically updated when the user sets the photo.</li>
<li>重写<code>loadFromContents</code>和<code>contentsForType</code>，loadFromContents里面self.wrapper = (NSFileWrapper *)contents;给wrapper赋值，contentsForType里面把两个model encode进wrapper</li>
<li>重写<code>titleModel</code>和<code>contentModel</code>两个getter实现Lazy Loading，需要的时候再decode；如果文件不存在则把model初始化为nil</li>
<li>实现ContentModel的content的Accessor来实现undo/redo，在Setter里面执行如下代码块：
```objective-c
if ([self.contentModel.content isEqual:str]) {
  return;
}</li>
</ul>
</blockquote></blockquote>

<p>NSString *oldContent = self.contentModel.content;
self.contentModel.content = str;</p>

<p>[self.undoManager setActionName:@&ldquo;Content Change&rdquo;];
[self.undoManager registerUndoWithTarget:self selector:@selector(setContentString:) object:oldContent];
```</p>

<h2>其他</h2>

<h3>1. 设备旋转支持</h3>

<p>好多大厂的App居然也能支持反过来操作，真是不可理解。代码摘自引用博文实现的工程。
```objective-c
&ndash; (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation
{</p>

<pre><code>return (interfaceOrientation != UIInterfaceOrientationPortraitUpsideDown);
</code></pre>

<p>}
```
<img src="/blogimage/2014/useuidocument.jpg" alt="useuidocument" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读Inkpad源代码]]></title>
    <link href="http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code/"/>
    <updated>2014-03-30T19:55:11+08:00</updated>
    <id>http://daryl5.github.io/blog/2014/03/30/reading-inkpad-source-code</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/sprang/Inkpad">Inkpad</a>是一个开源的基于OpenGLES的画矢量图的App，这篇博文记录阅读其源代码时的收获。</p>

<h3>0. 内联函数的使用</h3>

<h3>1. 一些简洁的写法</h3>

<ul>
<li><p><code>CGRectGetWidth</code>，以前总是写成<code>self.frame.size.width</code>。此外还有<code>CGRectGetMidX</code>，直接得到矩形中心点的X坐标。</p>

<pre><code>  CGPointMake(CGRectGetWidth(frame) / 2, CGRectGetHeight(frame) / 2);
</code></pre></li>
<li><p><code>[NSDictionary objectForKey]</code>，可以直接<code>dictionary[key]</code>。</p></li>
<li><p><code>BOOL isolate</code>转NSString，<code>@(isolate)</code>。NSArray的类似写法：</p>

<pre><code>  NSArray *items = @[actionItem_, gearItem_, albumItem_, zoomToFitItem_];
</code></pre></li>
</ul>


<h3>2. Best Practice</h3>

<p>应用的<strong><code>帮助</code></strong>, <strong><code>关于</code></strong>等信息可以做成html页面。建立本地文件夹，在其中放置html、图片、css等，然后直接<code>self.view = webview;</code>即可。
```objective-c
&ndash; (NSURL *) helpURL
{</p>

<pre><code>NSString *resource = NSLocalizedString(@"index", @"Name of Help html file");
NSString *path = [[NSBundle mainBundle] pathForResource:resource ofType:@"html" inDirectory:@"Help"];
return [NSURL fileURLWithPath:path isDirectory:NO];
</code></pre>

<p>}
&ndash; (void)loadView
{</p>

<pre><code>UIWebView *webView = [[UIWebView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
webView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
self.view = webView;
[webView loadRequest:[NSURLRequest requestWithURL:[self helpURL]]];
</code></pre>

<p>}
```</p>

<h3>3. <code>NSNotification</code>的名字应该在哪定义</h3>

<p>在<code>WDToolManager.m</code>中，<code>NSString *WDActiveToolDidChange = @"WDActiveToolDidChange";</code>，然后在头文件中<code>extern NSString *WDActiveToolDidChange;</code>。一般来说关心这个通知（当前工具改变）的类都引用了这个类的头文件，这样比放在一个<code>ConstantsDefine.h</code>里要好。</p>

<h3>4.枚举定义中为什么要用左移</h3>

<p>这里解释的很详细<a href="http://stackoverflow.com/questions/3999922/why-use-the-bitwise-shift-operator-for-values-in-a-c-enum-definition">Why use the Bitwise-Shift operator for values in a C enum definition?</a>。如果用</p>

<pre><code>typedef enum { WDToolDefault, WDToolShiftKey, WDToolOptionKey }  
</code></pre>

<p>那么<code>WDToolDefault | WDToolShiftKey</code>就是<code>1 | 2</code>会得到3！！用左移就不会有这个问题，就是<strong><em>可以在一个变量中支持多个枚举值</em></strong>（将其相加或者取或），判断的时候取与。</p>

<pre><code>typedef enum {
    WDToolDefault           = 0,
    WDToolShiftKey          = 1 &lt;&lt; 0,
    WDToolOptionKey         = 1 &lt;&lt; 1,
    WDToolControlKey        = 1 &lt;&lt; 2,
    WDToolSecondaryTouch    = 1 &lt;&lt; 3
} WDToolFlags;  
</code></pre>

<h3>5. 子类不能重写touchesBegan但要在其发生同时完成处理</h3>

<p><code>FingerTackerView</code>重写<code>touchesBegan</code>等等方法，然后在其内部进行一些操作后调用<code>[self methodForSubclassOverwritten]</code>，这个方法可以置空。<code>HandWritingView</code>，<code>GestureEditorView</code>等继承自<code>FingerTrackerView</code>的类里重写<code>[self methodForSubclassOverwritten]</code>，这样就能在采集点的同时，对点的处理根据当前选择功能（即所处的视图）来由对应的子类来处理。子类不会出现<code>touchesBegan</code>等，但是可以通过重写方法来实现手势运动时处理。</p>
]]></content>
  </entry>
  
</feed>
